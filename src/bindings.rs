/* automatically generated by rust-bindgen */

pub const EFI_FIRMWARE_VENDOR: &'static [u8; 6usize] = b"INTEL\x00";
pub const EFI_FIRMWARE_MAJOR_REVISION: ::ctypes::c_uint = 12;
pub const EFI_FIRMWARE_MINOR_REVISION: ::ctypes::c_uint = 33;
pub const EFI_FIRMWARE_REVISION: ::ctypes::c_uint = 786465;
pub const _STDINT_H: ::ctypes::c_uint = 1;
pub const _FEATURES_H: ::ctypes::c_uint = 1;
pub const _DEFAULT_SOURCE: ::ctypes::c_uint = 1;
pub const __USE_ISOC11: ::ctypes::c_uint = 1;
pub const __USE_ISOC99: ::ctypes::c_uint = 1;
pub const __USE_ISOC95: ::ctypes::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::ctypes::c_uint = 1;
pub const _POSIX_SOURCE: ::ctypes::c_uint = 1;
pub const _POSIX_C_SOURCE: ::ctypes::c_uint = 200809;
pub const __USE_POSIX: ::ctypes::c_uint = 1;
pub const __USE_POSIX2: ::ctypes::c_uint = 1;
pub const __USE_POSIX199309: ::ctypes::c_uint = 1;
pub const __USE_POSIX199506: ::ctypes::c_uint = 1;
pub const __USE_XOPEN2K: ::ctypes::c_uint = 1;
pub const __USE_XOPEN2K8: ::ctypes::c_uint = 1;
pub const _ATFILE_SOURCE: ::ctypes::c_uint = 1;
pub const __USE_MISC: ::ctypes::c_uint = 1;
pub const __USE_ATFILE: ::ctypes::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::ctypes::c_uint = 0;
pub const _STDC_PREDEF_H: ::ctypes::c_uint = 1;
pub const __STDC_IEC_559__: ::ctypes::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::ctypes::c_uint = 1;
pub const __STDC_ISO_10646__: ::ctypes::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::ctypes::c_uint = 1;
pub const __GNU_LIBRARY__: ::ctypes::c_uint = 6;
pub const __GLIBC__: ::ctypes::c_uint = 2;
pub const __GLIBC_MINOR__: ::ctypes::c_uint = 25;
pub const _SYS_CDEFS_H: ::ctypes::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::ctypes::c_uint = 1;
pub const __WORDSIZE: ::ctypes::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::ctypes::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::ctypes::c_uint = 64;
pub const __GLIBC_USE_LIB_EXT2: ::ctypes::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::ctypes::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::ctypes::c_uint = 0;
pub const _BITS_TYPES_H: ::ctypes::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::ctypes::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::ctypes::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::ctypes::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::ctypes::c_uint = 1;
pub const __FD_SETSIZE: ::ctypes::c_uint = 1024;
pub const _BITS_WCHAR_H: ::ctypes::c_uint = 1;
pub const INT8_MIN: ::ctypes::c_int = -128;
pub const INT16_MIN: ::ctypes::c_int = -32768;
pub const INT32_MIN: ::ctypes::c_int = -2147483648;
pub const INT8_MAX: ::ctypes::c_uint = 127;
pub const INT16_MAX: ::ctypes::c_uint = 32767;
pub const INT32_MAX: ::ctypes::c_uint = 2147483647;
pub const UINT8_MAX: ::ctypes::c_uint = 255;
pub const UINT16_MAX: ::ctypes::c_uint = 65535;
pub const UINT32_MAX: ::ctypes::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::ctypes::c_int = -128;
pub const INT_LEAST16_MIN: ::ctypes::c_int = -32768;
pub const INT_LEAST32_MIN: ::ctypes::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::ctypes::c_uint = 127;
pub const INT_LEAST16_MAX: ::ctypes::c_uint = 32767;
pub const INT_LEAST32_MAX: ::ctypes::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::ctypes::c_uint = 255;
pub const UINT_LEAST16_MAX: ::ctypes::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::ctypes::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::ctypes::c_int = -128;
pub const INT_FAST16_MIN: ::ctypes::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::ctypes::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::ctypes::c_uint = 127;
pub const INT_FAST16_MAX: ::ctypes::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::ctypes::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::ctypes::c_uint = 255;
pub const UINT_FAST16_MAX: ::ctypes::c_int = -1;
pub const UINT_FAST32_MAX: ::ctypes::c_int = -1;
pub const INTPTR_MIN: ::ctypes::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::ctypes::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::ctypes::c_int = -1;
pub const PTRDIFF_MIN: ::ctypes::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::ctypes::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::ctypes::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::ctypes::c_uint = 2147483647;
pub const SIZE_MAX: ::ctypes::c_int = -1;
pub const WINT_MIN: ::ctypes::c_uint = 0;
pub const WINT_MAX: ::ctypes::c_uint = 4294967295;
pub const EFI_ERROR_MASK: ::ctypes::c_longlong = -9223372036854775808;
pub const BAD_POINTER: ::ctypes::c_longlong = -289360691352306693;
pub const MAX_ADDRESS: ::ctypes::c_int = -1;
pub const MIN_ALIGNMENT_SIZE: ::ctypes::c_uint = 4;
pub const EFI_TIME_ADJUST_DAYLIGHT: ::ctypes::c_uint = 1;
pub const EFI_TIME_IN_DAYLIGHT: ::ctypes::c_uint = 2;
pub const EFI_UNSPECIFIED_TIMEZONE: ::ctypes::c_uint = 2047;
pub const EFI_MEMORY_UC: ::ctypes::c_uint = 1;
pub const EFI_MEMORY_WC: ::ctypes::c_uint = 2;
pub const EFI_MEMORY_WT: ::ctypes::c_uint = 4;
pub const EFI_MEMORY_WB: ::ctypes::c_uint = 8;
pub const EFI_MEMORY_UCE: ::ctypes::c_uint = 16;
pub const EFI_MEMORY_WP: ::ctypes::c_uint = 4096;
pub const EFI_MEMORY_RP: ::ctypes::c_uint = 8192;
pub const EFI_MEMORY_XP: ::ctypes::c_uint = 16384;
pub const EFI_MEMORY_RUNTIME: ::ctypes::c_longlong = -9223372036854775808;
pub const EFI_MEMORY_DESCRIPTOR_VERSION: ::ctypes::c_uint = 1;
pub const ISO_639_2_ENTRY_SIZE: ::ctypes::c_uint = 3;
pub const EFI_PAGE_SIZE: ::ctypes::c_uint = 4096;
pub const EFI_PAGE_MASK: ::ctypes::c_uint = 4095;
pub const EFI_PAGE_SHIFT: ::ctypes::c_uint = 12;
pub const EFI_OS_INDICATIONS_BOOT_TO_FW_UI: ::ctypes::c_uint = 1;
pub const EFI_OS_INDICATIONS_TIMESTAMP_REVOCATION: ::ctypes::c_uint = 2;
pub const EFI_OS_INDICATIONS_FILE_CAPSULE_DELIVERY_SUPPORTED: ::ctypes::c_uint
          =
    4;
pub const EFI_OS_INDICATIONS_FMP_CAPSULE_SUPPORTED: ::ctypes::c_uint = 8;
pub const EFI_OS_INDICATIONS_CAPSULE_RESULT_VAR_SUPPORTED: ::ctypes::c_uint =
    16;
pub const EFI_DP_TYPE_MASK: ::ctypes::c_uint = 127;
pub const EFI_DP_TYPE_UNPACKED: ::ctypes::c_uint = 128;
pub const END_DEVICE_PATH_TYPE: ::ctypes::c_uint = 127;
pub const END_ENTIRE_DEVICE_PATH_SUBTYPE: ::ctypes::c_uint = 255;
pub const END_INSTANCE_DEVICE_PATH_SUBTYPE: ::ctypes::c_uint = 1;
pub const HARDWARE_DEVICE_PATH: ::ctypes::c_uint = 1;
pub const HW_PCI_DP: ::ctypes::c_uint = 1;
pub const HW_PCCARD_DP: ::ctypes::c_uint = 2;
pub const HW_MEMMAP_DP: ::ctypes::c_uint = 3;
pub const HW_VENDOR_DP: ::ctypes::c_uint = 4;
pub const HW_CONTROLLER_DP: ::ctypes::c_uint = 5;
pub const ACPI_DEVICE_PATH: ::ctypes::c_uint = 2;
pub const ACPI_DP: ::ctypes::c_uint = 1;
pub const EXPANDED_ACPI_DP: ::ctypes::c_uint = 2;
pub const ACPI_ADR_DP: ::ctypes::c_uint = 3;
pub const PNP_EISA_ID_CONST: ::ctypes::c_uint = 16848;
pub const PNP_EISA_ID_MASK: ::ctypes::c_uint = 65535;
pub const MESSAGING_DEVICE_PATH: ::ctypes::c_uint = 3;
pub const MSG_ATAPI_DP: ::ctypes::c_uint = 1;
pub const MSG_SCSI_DP: ::ctypes::c_uint = 2;
pub const MSG_FIBRECHANNEL_DP: ::ctypes::c_uint = 3;
pub const MSG_FIBRECHANNELEX_DP: ::ctypes::c_uint = 21;
pub const MSG_1394_DP: ::ctypes::c_uint = 4;
pub const MSG_USB_DP: ::ctypes::c_uint = 5;
pub const MSG_SATA_DP: ::ctypes::c_uint = 18;
pub const MSG_USB_WWID_DP: ::ctypes::c_uint = 16;
pub const MSG_DEVICE_LOGICAL_UNIT_DP: ::ctypes::c_uint = 17;
pub const MSG_USB_CLASS_DP: ::ctypes::c_uint = 15;
pub const MSG_I2O_DP: ::ctypes::c_uint = 6;
pub const MSG_MAC_ADDR_DP: ::ctypes::c_uint = 11;
pub const MSG_IPv4_DP: ::ctypes::c_uint = 12;
pub const MSG_IPv6_DP: ::ctypes::c_uint = 13;
pub const MSG_URI_DP: ::ctypes::c_uint = 24;
pub const MSG_VLAN_DP: ::ctypes::c_uint = 20;
pub const MSG_INFINIBAND_DP: ::ctypes::c_uint = 9;
pub const MSG_UART_DP: ::ctypes::c_uint = 14;
pub const MSG_VENDOR_DP: ::ctypes::c_uint = 10;
pub const MEDIA_DEVICE_PATH: ::ctypes::c_uint = 4;
pub const MEDIA_HARDDRIVE_DP: ::ctypes::c_uint = 1;
pub const MBR_TYPE_PCAT: ::ctypes::c_uint = 1;
pub const MBR_TYPE_EFI_PARTITION_TABLE_HEADER: ::ctypes::c_uint = 2;
pub const SIGNATURE_TYPE_MBR: ::ctypes::c_uint = 1;
pub const SIGNATURE_TYPE_GUID: ::ctypes::c_uint = 2;
pub const MEDIA_CDROM_DP: ::ctypes::c_uint = 2;
pub const MEDIA_VENDOR_DP: ::ctypes::c_uint = 3;
pub const MEDIA_FILEPATH_DP: ::ctypes::c_uint = 4;
pub const MEDIA_PROTOCOL_DP: ::ctypes::c_uint = 5;
pub const MEDIA_PIWG_FW_FILE_DP: ::ctypes::c_uint = 6;
pub const MEDIA_PIWG_FW_VOL_DP: ::ctypes::c_uint = 7;
pub const MEDIA_RELATIVE_OFFSET_RANGE_DP: ::ctypes::c_uint = 8;
pub const BBS_DEVICE_PATH: ::ctypes::c_uint = 5;
pub const BBS_BBS_DP: ::ctypes::c_uint = 1;
pub const BBS_TYPE_FLOPPY: ::ctypes::c_uint = 1;
pub const BBS_TYPE_HARDDRIVE: ::ctypes::c_uint = 2;
pub const BBS_TYPE_CDROM: ::ctypes::c_uint = 3;
pub const BBS_TYPE_PCMCIA: ::ctypes::c_uint = 4;
pub const BBS_TYPE_USB: ::ctypes::c_uint = 5;
pub const BBS_TYPE_EMBEDDED_NETWORK: ::ctypes::c_uint = 6;
pub const BBS_TYPE_DEV: ::ctypes::c_uint = 128;
pub const BBS_TYPE_UNKNOWN: ::ctypes::c_uint = 255;
pub const EFI_PCI_IO_PASS_THROUGH_BAR: ::ctypes::c_uint = 255;
pub const EFI_PCI_IO_ATTRIBUTE_ISA_IO: ::ctypes::c_uint = 2;
pub const EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO: ::ctypes::c_uint = 4;
pub const EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY: ::ctypes::c_uint = 8;
pub const EFI_PCI_IO_ATTRIBUTE_VGA_IO: ::ctypes::c_uint = 16;
pub const EFI_PCI_IO_ATTRIBUTE_IDE_PRIMARY_IO: ::ctypes::c_uint = 32;
pub const EFI_PCI_IO_ATTRIBUTE_IDE_SECONDARY_IO: ::ctypes::c_uint = 64;
pub const EFI_PCI_IO_ATTRIBUTE_MEMORY_WRITE_COMBINE: ::ctypes::c_uint = 128;
pub const EFI_PCI_IO_ATTRIBUTE_IO: ::ctypes::c_uint = 256;
pub const EFI_PCI_IO_ATTRIBUTE_MEMORY: ::ctypes::c_uint = 512;
pub const EFI_PCI_IO_ATTRIBUTE_BUS_MASTER: ::ctypes::c_uint = 1024;
pub const EFI_PCI_IO_ATTRIBUTE_MEMORY_CACHED: ::ctypes::c_uint = 2048;
pub const EFI_PCI_IO_ATTRIBUTE_MEMORY_DISABLE: ::ctypes::c_uint = 4096;
pub const EFI_PCI_IO_ATTRIBUTE_EMBEDDED_DEVICE: ::ctypes::c_uint = 8192;
pub const EFI_PCI_IO_ATTRIBUTE_EMBEDDED_ROM: ::ctypes::c_uint = 16384;
pub const EFI_PCI_IO_ATTRIBUTE_DUAL_ADDRESS_CYCLE: ::ctypes::c_uint = 32768;
pub const EFI_PCI_IO_ATTRIBUTE_ISA_IO_16: ::ctypes::c_uint = 65536;
pub const EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16: ::ctypes::c_uint = 131072;
pub const EFI_PCI_IO_ATTRIBUTE_VGA_IO_16: ::ctypes::c_uint = 262144;
pub const EFI_BLOCK_IO_INTERFACE_REVISION: ::ctypes::c_uint = 65536;
pub const EFI_BLOCK_IO_INTERFACE_REVISION2: ::ctypes::c_uint = 131073;
pub const EFI_BLOCK_IO_INTERFACE_REVISION3: ::ctypes::c_uint = 131103;
pub const EFI_DISK_IO_INTERFACE_REVISION: ::ctypes::c_uint = 65536;
pub const EFI_FILE_IO_INTERFACE_REVISION: ::ctypes::c_uint = 65536;
pub const EFI_FILE_MODE_READ: ::ctypes::c_uint = 1;
pub const EFI_FILE_MODE_WRITE: ::ctypes::c_uint = 2;
pub const EFI_FILE_MODE_CREATE: ::ctypes::c_longlong = -9223372036854775808;
pub const EFI_FILE_READ_ONLY: ::ctypes::c_uint = 1;
pub const EFI_FILE_HIDDEN: ::ctypes::c_uint = 2;
pub const EFI_FILE_SYSTEM: ::ctypes::c_uint = 4;
pub const EFI_FILE_RESERVIED: ::ctypes::c_uint = 8;
pub const EFI_FILE_DIRECTORY: ::ctypes::c_uint = 16;
pub const EFI_FILE_ARCHIVE: ::ctypes::c_uint = 32;
pub const EFI_FILE_VALID_ATTR: ::ctypes::c_uint = 55;
pub const EFI_FILE_HANDLE_REVISION: ::ctypes::c_uint = 65536;
pub const EFI_BLACK: ::ctypes::c_uint = 0;
pub const EFI_BLUE: ::ctypes::c_uint = 1;
pub const EFI_GREEN: ::ctypes::c_uint = 2;
pub const EFI_CYAN: ::ctypes::c_uint = 3;
pub const EFI_RED: ::ctypes::c_uint = 4;
pub const EFI_MAGENTA: ::ctypes::c_uint = 5;
pub const EFI_BROWN: ::ctypes::c_uint = 6;
pub const EFI_LIGHTGRAY: ::ctypes::c_uint = 7;
pub const EFI_BRIGHT: ::ctypes::c_uint = 8;
pub const EFI_DARKGRAY: ::ctypes::c_uint = 8;
pub const EFI_LIGHTBLUE: ::ctypes::c_uint = 9;
pub const EFI_LIGHTGREEN: ::ctypes::c_uint = 10;
pub const EFI_LIGHTCYAN: ::ctypes::c_uint = 11;
pub const EFI_LIGHTRED: ::ctypes::c_uint = 12;
pub const EFI_LIGHTMAGENTA: ::ctypes::c_uint = 13;
pub const EFI_YELLOW: ::ctypes::c_uint = 14;
pub const EFI_WHITE: ::ctypes::c_uint = 15;
pub const EFI_BACKGROUND_BLACK: ::ctypes::c_uint = 0;
pub const EFI_BACKGROUND_BLUE: ::ctypes::c_uint = 16;
pub const EFI_BACKGROUND_GREEN: ::ctypes::c_uint = 32;
pub const EFI_BACKGROUND_CYAN: ::ctypes::c_uint = 48;
pub const EFI_BACKGROUND_RED: ::ctypes::c_uint = 64;
pub const EFI_BACKGROUND_MAGENTA: ::ctypes::c_uint = 80;
pub const EFI_BACKGROUND_BROWN: ::ctypes::c_uint = 96;
pub const EFI_BACKGROUND_LIGHTGRAY: ::ctypes::c_uint = 112;
pub const BOXDRAW_HORIZONTAL: ::ctypes::c_uint = 9472;
pub const BOXDRAW_VERTICAL: ::ctypes::c_uint = 9474;
pub const BOXDRAW_DOWN_RIGHT: ::ctypes::c_uint = 9484;
pub const BOXDRAW_DOWN_LEFT: ::ctypes::c_uint = 9488;
pub const BOXDRAW_UP_RIGHT: ::ctypes::c_uint = 9492;
pub const BOXDRAW_UP_LEFT: ::ctypes::c_uint = 9496;
pub const BOXDRAW_VERTICAL_RIGHT: ::ctypes::c_uint = 9500;
pub const BOXDRAW_VERTICAL_LEFT: ::ctypes::c_uint = 9508;
pub const BOXDRAW_DOWN_HORIZONTAL: ::ctypes::c_uint = 9516;
pub const BOXDRAW_UP_HORIZONTAL: ::ctypes::c_uint = 9524;
pub const BOXDRAW_VERTICAL_HORIZONTAL: ::ctypes::c_uint = 9532;
pub const BOXDRAW_DOUBLE_HORIZONTAL: ::ctypes::c_uint = 9552;
pub const BOXDRAW_DOUBLE_VERTICAL: ::ctypes::c_uint = 9553;
pub const BOXDRAW_DOWN_RIGHT_DOUBLE: ::ctypes::c_uint = 9554;
pub const BOXDRAW_DOWN_DOUBLE_RIGHT: ::ctypes::c_uint = 9555;
pub const BOXDRAW_DOUBLE_DOWN_RIGHT: ::ctypes::c_uint = 9556;
pub const BOXDRAW_DOWN_LEFT_DOUBLE: ::ctypes::c_uint = 9557;
pub const BOXDRAW_DOWN_DOUBLE_LEFT: ::ctypes::c_uint = 9558;
pub const BOXDRAW_DOUBLE_DOWN_LEFT: ::ctypes::c_uint = 9559;
pub const BOXDRAW_UP_RIGHT_DOUBLE: ::ctypes::c_uint = 9560;
pub const BOXDRAW_UP_DOUBLE_RIGHT: ::ctypes::c_uint = 9561;
pub const BOXDRAW_DOUBLE_UP_RIGHT: ::ctypes::c_uint = 9562;
pub const BOXDRAW_UP_LEFT_DOUBLE: ::ctypes::c_uint = 9563;
pub const BOXDRAW_UP_DOUBLE_LEFT: ::ctypes::c_uint = 9564;
pub const BOXDRAW_DOUBLE_UP_LEFT: ::ctypes::c_uint = 9565;
pub const BOXDRAW_VERTICAL_RIGHT_DOUBLE: ::ctypes::c_uint = 9566;
pub const BOXDRAW_VERTICAL_DOUBLE_RIGHT: ::ctypes::c_uint = 9567;
pub const BOXDRAW_DOUBLE_VERTICAL_RIGHT: ::ctypes::c_uint = 9568;
pub const BOXDRAW_VERTICAL_LEFT_DOUBLE: ::ctypes::c_uint = 9569;
pub const BOXDRAW_VERTICAL_DOUBLE_LEFT: ::ctypes::c_uint = 9570;
pub const BOXDRAW_DOUBLE_VERTICAL_LEFT: ::ctypes::c_uint = 9571;
pub const BOXDRAW_DOWN_HORIZONTAL_DOUBLE: ::ctypes::c_uint = 9572;
pub const BOXDRAW_DOWN_DOUBLE_HORIZONTAL: ::ctypes::c_uint = 9573;
pub const BOXDRAW_DOUBLE_DOWN_HORIZONTAL: ::ctypes::c_uint = 9574;
pub const BOXDRAW_UP_HORIZONTAL_DOUBLE: ::ctypes::c_uint = 9575;
pub const BOXDRAW_UP_DOUBLE_HORIZONTAL: ::ctypes::c_uint = 9576;
pub const BOXDRAW_DOUBLE_UP_HORIZONTAL: ::ctypes::c_uint = 9577;
pub const BOXDRAW_VERTICAL_HORIZONTAL_DOUBLE: ::ctypes::c_uint = 9578;
pub const BOXDRAW_VERTICAL_DOUBLE_HORIZONTAL: ::ctypes::c_uint = 9579;
pub const BOXDRAW_DOUBLE_VERTICAL_HORIZONTAL: ::ctypes::c_uint = 9580;
pub const BLOCKELEMENT_FULL_BLOCK: ::ctypes::c_uint = 9608;
pub const BLOCKELEMENT_LIGHT_SHADE: ::ctypes::c_uint = 9617;
pub const GEOMETRICSHAPE_UP_TRIANGLE: ::ctypes::c_uint = 9650;
pub const GEOMETRICSHAPE_RIGHT_TRIANGLE: ::ctypes::c_uint = 9658;
pub const GEOMETRICSHAPE_DOWN_TRIANGLE: ::ctypes::c_uint = 9660;
pub const GEOMETRICSHAPE_LEFT_TRIANGLE: ::ctypes::c_uint = 9668;
pub const ARROW_UP: ::ctypes::c_uint = 8593;
pub const ARROW_DOWN: ::ctypes::c_uint = 8595;
pub const CHAR_NULL: ::ctypes::c_uint = 0;
pub const CHAR_BACKSPACE: ::ctypes::c_uint = 8;
pub const CHAR_TAB: ::ctypes::c_uint = 9;
pub const CHAR_LINEFEED: ::ctypes::c_uint = 10;
pub const CHAR_CARRIAGE_RETURN: ::ctypes::c_uint = 13;
pub const SCAN_NULL: ::ctypes::c_uint = 0;
pub const SCAN_UP: ::ctypes::c_uint = 1;
pub const SCAN_DOWN: ::ctypes::c_uint = 2;
pub const SCAN_RIGHT: ::ctypes::c_uint = 3;
pub const SCAN_LEFT: ::ctypes::c_uint = 4;
pub const SCAN_HOME: ::ctypes::c_uint = 5;
pub const SCAN_END: ::ctypes::c_uint = 6;
pub const SCAN_INSERT: ::ctypes::c_uint = 7;
pub const SCAN_DELETE: ::ctypes::c_uint = 8;
pub const SCAN_PAGE_UP: ::ctypes::c_uint = 9;
pub const SCAN_PAGE_DOWN: ::ctypes::c_uint = 10;
pub const SCAN_F1: ::ctypes::c_uint = 11;
pub const SCAN_F2: ::ctypes::c_uint = 12;
pub const SCAN_F3: ::ctypes::c_uint = 13;
pub const SCAN_F4: ::ctypes::c_uint = 14;
pub const SCAN_F5: ::ctypes::c_uint = 15;
pub const SCAN_F6: ::ctypes::c_uint = 16;
pub const SCAN_F7: ::ctypes::c_uint = 17;
pub const SCAN_F8: ::ctypes::c_uint = 18;
pub const SCAN_F9: ::ctypes::c_uint = 19;
pub const SCAN_F10: ::ctypes::c_uint = 20;
pub const SCAN_ESC: ::ctypes::c_uint = 23;
pub const EFI_SERIAL_CLEAR_TO_SEND: ::ctypes::c_uint = 16;
pub const EFI_SERIAL_DATA_SET_READY: ::ctypes::c_uint = 32;
pub const EFI_SERIAL_RING_INDICATE: ::ctypes::c_uint = 64;
pub const EFI_SERIAL_CARRIER_DETECT: ::ctypes::c_uint = 128;
pub const EFI_SERIAL_REQUEST_TO_SEND: ::ctypes::c_uint = 2;
pub const EFI_SERIAL_DATA_TERMINAL_READY: ::ctypes::c_uint = 1;
pub const EFI_SERIAL_INPUT_BUFFER_EMPTY: ::ctypes::c_uint = 256;
pub const EFI_SERIAL_OUTPUT_BUFFER_EMPTY: ::ctypes::c_uint = 512;
pub const EFI_SERIAL_HARDWARE_LOOPBACK_ENABLE: ::ctypes::c_uint = 4096;
pub const EFI_SERIAL_SOFTWARE_LOOPBACK_ENABLE: ::ctypes::c_uint = 8192;
pub const EFI_SERIAL_HARDWARE_FLOW_CONTROL_ENABLE: ::ctypes::c_uint = 16384;
pub const SERIAL_IO_INTERFACE_REVISION: ::ctypes::c_uint = 65536;
pub const EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE_REVISION:
          ::ctypes::c_uint =
    65536;
pub const DEFAULT_TTL: ::ctypes::c_uint = 4;
pub const DEFAULT_ToS: ::ctypes::c_uint = 0;
pub const EFI_PXE_BASE_CODE_MAX_IPCNT: ::ctypes::c_uint = 8;
pub const EFI_PXE_BASE_CODE_IP_FILTER_STATION_IP: ::ctypes::c_uint = 1;
pub const EFI_PXE_BASE_CODE_IP_FILTER_BROADCAST: ::ctypes::c_uint = 2;
pub const EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS: ::ctypes::c_uint = 4;
pub const EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS_MULTICAST: ::ctypes::c_uint
          =
    8;
pub const EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_IP: ::ctypes::c_uint = 1;
pub const EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_PORT: ::ctypes::c_uint = 2;
pub const EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_IP: ::ctypes::c_uint = 4;
pub const EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_PORT: ::ctypes::c_uint = 8;
pub const EFI_PXE_BASE_CODE_UDP_OPFLAGS_USE_FILTER: ::ctypes::c_uint = 16;
pub const EFI_PXE_BASE_CODE_UDP_OPFLAGS_MAY_FRAGMENT: ::ctypes::c_uint = 32;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_BOOTSTRAP: ::ctypes::c_uint = 0;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_MS_WINNT_RIS: ::ctypes::c_uint = 1;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_INTEL_LCM: ::ctypes::c_uint = 2;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_DOSUNDI: ::ctypes::c_uint = 3;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_NEC_ESMPRO: ::ctypes::c_uint = 4;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_WSoD: ::ctypes::c_uint = 5;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_LCCM: ::ctypes::c_uint = 6;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_CA_UNICENTER_TNG: ::ctypes::c_uint = 7;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_HP_OPENVIEW: ::ctypes::c_uint = 8;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_9: ::ctypes::c_uint = 9;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_10: ::ctypes::c_uint = 10;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_11: ::ctypes::c_uint = 11;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_NOT_USED_12: ::ctypes::c_uint = 12;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_INSTALL: ::ctypes::c_uint = 13;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_BOOT: ::ctypes::c_uint = 14;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_REMBO: ::ctypes::c_uint = 15;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_BEOBOOT: ::ctypes::c_uint = 16;
pub const EFI_PXE_BASE_CODE_BOOT_TYPE_PXETEST: ::ctypes::c_uint = 65535;
pub const EFI_PXE_BASE_CODE_BOOT_LAYER_MASK: ::ctypes::c_uint = 32767;
pub const EFI_PXE_BASE_CODE_BOOT_LAYER_INITIAL: ::ctypes::c_uint = 0;
pub const EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES: ::ctypes::c_uint = 8;
pub const EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES: ::ctypes::c_uint = 8;
pub const EFI_PXE_BASE_CODE_INTERFACE_REVISION: ::ctypes::c_uint = 65536;
pub const EFI_PXE_BASE_CODE_CALLBACK_INTERFACE_REVISION: ::ctypes::c_uint =
    65536;
pub const EFI_SIMPLE_NETWORK_RECEIVE_UNICAST: ::ctypes::c_uint = 1;
pub const EFI_SIMPLE_NETWORK_RECEIVE_MULTICAST: ::ctypes::c_uint = 2;
pub const EFI_SIMPLE_NETWORK_RECEIVE_BROADCAST: ::ctypes::c_uint = 4;
pub const EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS: ::ctypes::c_uint = 8;
pub const EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST: ::ctypes::c_uint =
    16;
pub const EFI_SIMPLE_NETWORK_RECEIVE_INTERRUPT: ::ctypes::c_uint = 1;
pub const EFI_SIMPLE_NETWORK_TRANSMIT_INTERRUPT: ::ctypes::c_uint = 2;
pub const EFI_SIMPLE_NETWORK_COMMAND_INTERRUPT: ::ctypes::c_uint = 4;
pub const EFI_SIMPLE_NETWORK_SOFTWARE_INTERRUPT: ::ctypes::c_uint = 8;
pub const MAX_MCAST_FILTER_CNT: ::ctypes::c_uint = 16;
pub const EFI_SIMPLE_NETWORK_INTERFACE_REVISION: ::ctypes::c_uint = 65536;
pub const EFI_SPECIFICATION_MAJOR_REVISION: ::ctypes::c_uint = 1;
pub const EFI_SPECIFICATION_MINOR_REVISION: ::ctypes::c_uint = 2;
pub const EFI_OPTIONAL_PTR: ::ctypes::c_uint = 1;
pub const EFI_INTERNAL_FNC: ::ctypes::c_uint = 2;
pub const EFI_INTERNAL_PTR: ::ctypes::c_uint = 4;
pub const EVT_TIMER: ::ctypes::c_uint = 2147483648;
pub const EVT_RUNTIME: ::ctypes::c_uint = 1073741824;
pub const EVT_RUNTIME_CONTEXT: ::ctypes::c_uint = 536870912;
pub const EVT_NOTIFY_WAIT: ::ctypes::c_uint = 256;
pub const EVT_NOTIFY_SIGNAL: ::ctypes::c_uint = 512;
pub const EVT_SIGNAL_EXIT_BOOT_SERVICES: ::ctypes::c_uint = 513;
pub const EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE: ::ctypes::c_uint = 1610613250;
pub const EVT_EFI_SIGNAL_MASK: ::ctypes::c_uint = 255;
pub const EVT_EFI_SIGNAL_MAX: ::ctypes::c_uint = 2;
pub const TPL_APPLICATION: ::ctypes::c_uint = 4;
pub const TPL_CALLBACK: ::ctypes::c_uint = 8;
pub const TPL_NOTIFY: ::ctypes::c_uint = 16;
pub const TPL_HIGH_LEVEL: ::ctypes::c_uint = 31;
pub const EFI_VARIABLE_NON_VOLATILE: ::ctypes::c_uint = 1;
pub const EFI_VARIABLE_BOOTSERVICE_ACCESS: ::ctypes::c_uint = 2;
pub const EFI_VARIABLE_RUNTIME_ACCESS: ::ctypes::c_uint = 4;
pub const EFI_VARIABLE_HARDWARE_ERROR_RECORD: ::ctypes::c_uint = 8;
pub const EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS: ::ctypes::c_uint = 16;
pub const EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS: ::ctypes::c_uint
          =
    32;
pub const EFI_VARIABLE_APPEND_WRITE: ::ctypes::c_uint = 64;
pub const EFI_MAXIMUM_VARIABLE_SIZE: ::ctypes::c_uint = 1024;
pub const IMAGE_SUBSYSTEM_EFI_APPLICATION: ::ctypes::c_uint = 10;
pub const IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER: ::ctypes::c_uint = 11;
pub const IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER: ::ctypes::c_uint = 12;
pub const EFI_IMAGE_MACHINE_IA32: ::ctypes::c_uint = 332;
pub const EFI_IMAGE_MACHINE_IA64: ::ctypes::c_uint = 512;
pub const EFI_IMAGE_INFORMATION_REVISION: ::ctypes::c_uint = 4096;
pub const EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL: ::ctypes::c_uint = 1;
pub const EFI_OPEN_PROTOCOL_GET_PROTOCOL: ::ctypes::c_uint = 2;
pub const EFI_OPEN_PROTOCOL_TEST_PROTOCOL: ::ctypes::c_uint = 4;
pub const EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER: ::ctypes::c_uint = 8;
pub const EFI_OPEN_PROTOCOL_BY_DRIVER: ::ctypes::c_uint = 16;
pub const EFI_OPEN_PROTOCOL_EXCLUSIVE: ::ctypes::c_uint = 32;
pub const CAPSULE_FLAGS_PERSIST_ACROSS_RESET: ::ctypes::c_uint = 65536;
pub const CAPSULE_FLAGS_POPULATE_SYSTEM_TABLE: ::ctypes::c_uint = 131072;
pub const CAPSULE_FLAGS_INITIATE_RESET: ::ctypes::c_uint = 262144;
pub const EFI_RUNTIME_SERVICES_SIGNATURE: ::ctypes::c_ulonglong =
    6220110259551098194;
pub const EFI_RUNTIME_SERVICES_REVISION: ::ctypes::c_uint = 65538;
pub const EFI_BOOT_SERVICES_SIGNATURE: ::ctypes::c_ulonglong =
    6220110259551162178;
pub const EFI_BOOT_SERVICES_REVISION: ::ctypes::c_uint = 65538;
pub const EFI_SYSTEM_TABLE_SIGNATURE: ::ctypes::c_ulonglong =
    6076298535811760713;
pub const EFI_SYSTEM_TABLE_REVISION: ::ctypes::c_uint = 65538;
pub const EFI_PARTITION_SIGNATURE: ::ctypes::c_ulonglong =
    5788068159660048969;
pub const EFI_PARTITION_REVISION: ::ctypes::c_uint = 65537;
pub const MIN_EFI_PARTITION_BLOCK_SIZE: ::ctypes::c_uint = 512;
pub const EFI_PARTITION_LBA: ::ctypes::c_uint = 1;
pub const EFI_FILE_HEADER_SIGNATURE: ::ctypes::c_ulonglong =
    4993446652385247817;
pub const EFI_FILE_HEADER_REVISION: ::ctypes::c_uint = 65536;
pub const EFI_FILE_STRING_SIZE: ::ctypes::c_uint = 260;
pub const EFI_FILE_CLASS_FREE_SPACE: ::ctypes::c_uint = 1;
pub const EFI_FILE_CLASS_EMPTY: ::ctypes::c_uint = 2;
pub const EFI_FILE_CLASS_NORMAL: ::ctypes::c_uint = 3;
pub const EFI_LBAL_SIGNATURE: ::ctypes::c_ulonglong = 5494745915095335497;
pub const EFI_LBAL_REVISION: ::ctypes::c_uint = 65536;
pub const EFI_SUCCESS: ::ctypes::c_uint = 0;
pub const EFI_UI_VERSION: ::ctypes::c_uint = 65536;
pub const ICMP_V6_DEST_UNREACHABLE: ::ctypes::c_uint = 1;
pub const ICMP_V6_PACKET_TOO_BIG: ::ctypes::c_uint = 2;
pub const ICMP_V6_TIME_EXCEEDED: ::ctypes::c_uint = 3;
pub const ICMP_V6_PARAMETER_PROBLEM: ::ctypes::c_uint = 4;
pub const ICMP_V6_ECHO_REQUEST: ::ctypes::c_uint = 128;
pub const ICMP_V6_ECHO_REPLY: ::ctypes::c_uint = 129;
pub const ICMP_V6_LISTENER_QUERY: ::ctypes::c_uint = 130;
pub const ICMP_V6_LISTENER_REPORT: ::ctypes::c_uint = 131;
pub const ICMP_V6_LISTENER_DONE: ::ctypes::c_uint = 132;
pub const ICMP_V6_ROUTER_SOLICIT: ::ctypes::c_uint = 133;
pub const ICMP_V6_ROUTER_ADVERTISE: ::ctypes::c_uint = 134;
pub const ICMP_V6_NEIGHBOR_SOLICIT: ::ctypes::c_uint = 135;
pub const ICMP_V6_NEIGHBOR_ADVERTISE: ::ctypes::c_uint = 136;
pub const ICMP_V6_REDIRECT: ::ctypes::c_uint = 137;
pub const ICMP_V6_LISTENER_REPORT_2: ::ctypes::c_uint = 143;
pub const ICMP_V6_NO_ROUTE_TO_DEST: ::ctypes::c_uint = 0;
pub const ICMP_V6_COMM_PROHIBITED: ::ctypes::c_uint = 1;
pub const ICMP_V6_BEYOND_SCOPE: ::ctypes::c_uint = 2;
pub const ICMP_V6_ADDR_UNREACHABLE: ::ctypes::c_uint = 3;
pub const ICMP_V6_PORT_UNREACHABLE: ::ctypes::c_uint = 4;
pub const ICMP_V6_SOURCE_ADDR_FAILED: ::ctypes::c_uint = 5;
pub const ICMP_V6_ROUTE_REJECTED: ::ctypes::c_uint = 6;
pub const ICMP_V6_TIMEOUT_HOP_LIMIT: ::ctypes::c_uint = 0;
pub const ICMP_V6_TIMEOUT_REASSEMBLE: ::ctypes::c_uint = 1;
pub const ICMP_V6_ERRONEOUS_HEADER: ::ctypes::c_uint = 0;
pub const ICMP_V6_UNRECOGNIZE_NEXT_HDR: ::ctypes::c_uint = 1;
pub const ICMP_V6_UNRECOGNIZE_OPTION: ::ctypes::c_uint = 2;
pub const EFI_ABSP_SupportsAltActive: ::ctypes::c_uint = 1;
pub const EFI_ABSP_SupportsPressureAsZ: ::ctypes::c_uint = 2;
pub const EFI_ABSP_TouchActive: ::ctypes::c_uint = 1;
pub const EFI_ABS_AltActive: ::ctypes::c_uint = 2;
pub type __u_char = ::ctypes::c_uchar;
pub type __u_short = ::ctypes::c_ushort;
pub type __u_int = ::ctypes::c_uint;
pub type __u_long = ::ctypes::c_ulong;
pub type __int8_t = ::ctypes::c_schar;
pub type __uint8_t = ::ctypes::c_uchar;
pub type __int16_t = ::ctypes::c_short;
pub type __uint16_t = ::ctypes::c_ushort;
pub type __int32_t = ::ctypes::c_int;
pub type __uint32_t = ::ctypes::c_uint;
pub type __int64_t = ::ctypes::c_long;
pub type __uint64_t = ::ctypes::c_ulong;
pub type __quad_t = ::ctypes::c_long;
pub type __u_quad_t = ::ctypes::c_ulong;
pub type __intmax_t = ::ctypes::c_long;
pub type __uintmax_t = ::ctypes::c_ulong;
pub type __dev_t = ::ctypes::c_ulong;
pub type __uid_t = ::ctypes::c_uint;
pub type __gid_t = ::ctypes::c_uint;
pub type __ino_t = ::ctypes::c_ulong;
pub type __ino64_t = ::ctypes::c_ulong;
pub type __mode_t = ::ctypes::c_uint;
pub type __nlink_t = ::ctypes::c_ulong;
pub type __off_t = ::ctypes::c_long;
pub type __off64_t = ::ctypes::c_long;
pub type __pid_t = ::ctypes::c_int;
#[repr(C)]

pub struct __fsid_t {
    pub __val: [::ctypes::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::core::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::core::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type __clock_t = ::ctypes::c_long;
pub type __rlim_t = ::ctypes::c_ulong;
pub type __rlim64_t = ::ctypes::c_ulong;
pub type __id_t = ::ctypes::c_uint;
pub type __time_t = ::ctypes::c_long;
pub type __useconds_t = ::ctypes::c_uint;
pub type __suseconds_t = ::ctypes::c_long;
pub type __daddr_t = ::ctypes::c_int;
pub type __key_t = ::ctypes::c_int;
pub type __clockid_t = ::ctypes::c_int;
pub type __timer_t = *mut ::ctypes::c_void;
pub type __blksize_t = ::ctypes::c_long;
pub type __blkcnt_t = ::ctypes::c_long;
pub type __blkcnt64_t = ::ctypes::c_long;
pub type __fsblkcnt_t = ::ctypes::c_ulong;
pub type __fsblkcnt64_t = ::ctypes::c_ulong;
pub type __fsfilcnt_t = ::ctypes::c_ulong;
pub type __fsfilcnt64_t = ::ctypes::c_ulong;
pub type __fsword_t = ::ctypes::c_long;
pub type __ssize_t = ::ctypes::c_long;
pub type __syscall_slong_t = ::ctypes::c_long;
pub type __syscall_ulong_t = ::ctypes::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::ctypes::c_char;
pub type __intptr_t = ::ctypes::c_long;
pub type __socklen_t = ::ctypes::c_uint;
pub type int_least8_t = ::ctypes::c_schar;
pub type int_least16_t = ::ctypes::c_short;
pub type int_least32_t = ::ctypes::c_int;
pub type int_least64_t = ::ctypes::c_long;
pub type uint_least8_t = ::ctypes::c_uchar;
pub type uint_least16_t = ::ctypes::c_ushort;
pub type uint_least32_t = ::ctypes::c_uint;
pub type uint_least64_t = ::ctypes::c_ulong;
pub type int_fast8_t = ::ctypes::c_schar;
pub type int_fast16_t = ::ctypes::c_long;
pub type int_fast32_t = ::ctypes::c_long;
pub type int_fast64_t = ::ctypes::c_long;
pub type uint_fast8_t = ::ctypes::c_uchar;
pub type uint_fast16_t = ::ctypes::c_ulong;
pub type uint_fast32_t = ::ctypes::c_ulong;
pub type uint_fast64_t = ::ctypes::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type UINT64 = u64;
pub type INT64 = i64;
pub type UINT32 = u32;
pub type INT32 = i32;
pub type UINT16 = u16;
pub type INT16 = i16;
pub type UINT8 = u8;
pub type INT8 = i8;
pub type WCHAR = ::ctypes::c_int;
pub type INTN = i64;
pub type UINTN = u64;
pub type CHAR16 = UINT16;
pub type CHAR8 = UINT8;
pub type BOOLEAN = UINT8;
pub type EFI_STATUS = UINTN;
pub type EFI_LBA = UINT64;
pub type EFI_TPL = UINTN;
pub type EFI_HANDLE = *mut ::ctypes::c_void;
pub type EFI_EVENT = *mut ::ctypes::c_void;
#[repr(C)]

pub struct EFI_GUID {
    pub Data1: UINT32,
    pub Data2: UINT16,
    pub Data3: UINT16,
    pub Data4: [UINT8; 8usize],
}
#[test]
fn bindgen_test_layout_EFI_GUID() {
    assert_eq!(::core::mem::size_of::<EFI_GUID>() , 16usize , concat ! (
               "Size of: " , stringify ! ( EFI_GUID ) ));
    assert_eq! (::core::mem::align_of::<EFI_GUID>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( EFI_GUID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GUID ) ) . Data1 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_GUID ) , "::" ,
                stringify ! ( Data1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GUID ) ) . Data2 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_GUID ) , "::" ,
                stringify ! ( Data2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GUID ) ) . Data3 as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_GUID ) , "::" ,
                stringify ! ( Data3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GUID ) ) . Data4 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_GUID ) , "::" ,
                stringify ! ( Data4 ) ));
}
impl Clone for EFI_GUID {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_TIME {
    pub Year: UINT16,
    pub Month: UINT8,
    pub Day: UINT8,
    pub Hour: UINT8,
    pub Minute: UINT8,
    pub Second: UINT8,
    pub Pad1: UINT8,
    pub Nanosecond: UINT32,
    pub TimeZone: INT16,
    pub Daylight: UINT8,
    pub Pad2: UINT8,
}
#[test]
fn bindgen_test_layout_EFI_TIME() {
    assert_eq!(::core::mem::size_of::<EFI_TIME>() , 16usize , concat ! (
               "Size of: " , stringify ! ( EFI_TIME ) ));
    assert_eq! (::core::mem::align_of::<EFI_TIME>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( EFI_TIME ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TIME ) ) . Year as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TIME ) , "::" ,
                stringify ! ( Year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TIME ) ) . Month as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TIME ) , "::" ,
                stringify ! ( Month ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TIME ) ) . Day as * const _ as usize
                } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TIME ) , "::" ,
                stringify ! ( Day ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TIME ) ) . Hour as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TIME ) , "::" ,
                stringify ! ( Hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TIME ) ) . Minute as * const _ as
                usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TIME ) , "::" ,
                stringify ! ( Minute ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TIME ) ) . Second as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TIME ) , "::" ,
                stringify ! ( Second ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TIME ) ) . Pad1 as * const _ as usize
                } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TIME ) , "::" ,
                stringify ! ( Pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TIME ) ) . Nanosecond as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TIME ) , "::" ,
                stringify ! ( Nanosecond ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TIME ) ) . TimeZone as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TIME ) , "::" ,
                stringify ! ( TimeZone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TIME ) ) . Daylight as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TIME ) , "::" ,
                stringify ! ( Daylight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TIME ) ) . Pad2 as * const _ as usize
                } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TIME ) , "::" ,
                stringify ! ( Pad2 ) ));
}
impl Clone for EFI_TIME {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IPv4_ADDRESS {
    pub Addr: [UINT8; 4usize],
}
#[test]
fn bindgen_test_layout_EFI_IPv4_ADDRESS() {
    assert_eq!(::core::mem::size_of::<EFI_IPv4_ADDRESS>() , 4usize , concat !
               ( "Size of: " , stringify ! ( EFI_IPv4_ADDRESS ) ));
    assert_eq! (::core::mem::align_of::<EFI_IPv4_ADDRESS>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( EFI_IPv4_ADDRESS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IPv4_ADDRESS ) ) . Addr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IPv4_ADDRESS ) ,
                "::" , stringify ! ( Addr ) ));
}
impl Clone for EFI_IPv4_ADDRESS {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IPv6_ADDRESS {
    pub Addr: [UINT8; 16usize],
}
#[test]
fn bindgen_test_layout_EFI_IPv6_ADDRESS() {
    assert_eq!(::core::mem::size_of::<EFI_IPv6_ADDRESS>() , 16usize , concat !
               ( "Size of: " , stringify ! ( EFI_IPv6_ADDRESS ) ));
    assert_eq! (::core::mem::align_of::<EFI_IPv6_ADDRESS>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( EFI_IPv6_ADDRESS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IPv6_ADDRESS ) ) . Addr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IPv6_ADDRESS ) ,
                "::" , stringify ! ( Addr ) ));
}
impl Clone for EFI_IPv6_ADDRESS {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_MAC_ADDRESS {
    pub Addr: [UINT8; 32usize],
}
#[test]
fn bindgen_test_layout_EFI_MAC_ADDRESS() {
    assert_eq!(::core::mem::size_of::<EFI_MAC_ADDRESS>() , 32usize , concat !
               ( "Size of: " , stringify ! ( EFI_MAC_ADDRESS ) ));
    assert_eq! (::core::mem::align_of::<EFI_MAC_ADDRESS>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( EFI_MAC_ADDRESS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MAC_ADDRESS ) ) . Addr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_MAC_ADDRESS ) ,
                "::" , stringify ! ( Addr ) ));
}
impl Clone for EFI_MAC_ADDRESS {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_MANAGED_NETWORK_CONFIG_DATA {
    pub ReceivedQueueTimeoutValue: UINT32,
    pub TransmitQueueTimeoutValue: UINT32,
    pub ProtocolTypeFilter: UINT16,
    pub EnableUnicastReceive: BOOLEAN,
    pub EnableMulticastReceive: BOOLEAN,
    pub EnableBroadcastReceive: BOOLEAN,
    pub EnablePromiscuousReceive: BOOLEAN,
    pub FlushQueuesOnReset: BOOLEAN,
    pub EnableReceiveTimestamps: BOOLEAN,
    pub DisableBackgroundPolling: BOOLEAN,
}
#[test]
fn bindgen_test_layout_EFI_MANAGED_NETWORK_CONFIG_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_MANAGED_NETWORK_CONFIG_DATA>() ,
               20usize , concat ! (
               "Size of: " , stringify ! ( EFI_MANAGED_NETWORK_CONFIG_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_MANAGED_NETWORK_CONFIG_DATA>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_MANAGED_NETWORK_CONFIG_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MANAGED_NETWORK_CONFIG_DATA ) ) .
                ReceivedQueueTimeoutValue as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                EFI_MANAGED_NETWORK_CONFIG_DATA ) , "::" , stringify ! (
                ReceivedQueueTimeoutValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MANAGED_NETWORK_CONFIG_DATA ) ) .
                TransmitQueueTimeoutValue as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                EFI_MANAGED_NETWORK_CONFIG_DATA ) , "::" , stringify ! (
                TransmitQueueTimeoutValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MANAGED_NETWORK_CONFIG_DATA ) ) .
                ProtocolTypeFilter as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                EFI_MANAGED_NETWORK_CONFIG_DATA ) , "::" , stringify ! (
                ProtocolTypeFilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MANAGED_NETWORK_CONFIG_DATA ) ) .
                EnableUnicastReceive as * const _ as usize } , 10usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                EFI_MANAGED_NETWORK_CONFIG_DATA ) , "::" , stringify ! (
                EnableUnicastReceive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MANAGED_NETWORK_CONFIG_DATA ) ) .
                EnableMulticastReceive as * const _ as usize } , 11usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                EFI_MANAGED_NETWORK_CONFIG_DATA ) , "::" , stringify ! (
                EnableMulticastReceive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MANAGED_NETWORK_CONFIG_DATA ) ) .
                EnableBroadcastReceive as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                EFI_MANAGED_NETWORK_CONFIG_DATA ) , "::" , stringify ! (
                EnableBroadcastReceive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MANAGED_NETWORK_CONFIG_DATA ) ) .
                EnablePromiscuousReceive as * const _ as usize } , 13usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                EFI_MANAGED_NETWORK_CONFIG_DATA ) , "::" , stringify ! (
                EnablePromiscuousReceive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MANAGED_NETWORK_CONFIG_DATA ) ) .
                FlushQueuesOnReset as * const _ as usize } , 14usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                EFI_MANAGED_NETWORK_CONFIG_DATA ) , "::" , stringify ! (
                FlushQueuesOnReset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MANAGED_NETWORK_CONFIG_DATA ) ) .
                EnableReceiveTimestamps as * const _ as usize } , 15usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                EFI_MANAGED_NETWORK_CONFIG_DATA ) , "::" , stringify ! (
                EnableReceiveTimestamps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MANAGED_NETWORK_CONFIG_DATA ) ) .
                DisableBackgroundPolling as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                EFI_MANAGED_NETWORK_CONFIG_DATA ) , "::" , stringify ! (
                DisableBackgroundPolling ) ));
}
impl Clone for EFI_MANAGED_NETWORK_CONFIG_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_PHYSICAL_ADDRESS = UINT64;
pub type EFI_VIRTUAL_ADDRESS = UINT64;
pub const EFI_ALLOCATE_TYPE_AllocateAnyPages: EFI_ALLOCATE_TYPE = 0;
pub const EFI_ALLOCATE_TYPE_AllocateMaxAddress: EFI_ALLOCATE_TYPE = 1;
pub const EFI_ALLOCATE_TYPE_AllocateAddress: EFI_ALLOCATE_TYPE = 2;
pub const EFI_ALLOCATE_TYPE_MaxAllocateType: EFI_ALLOCATE_TYPE = 3;
pub type EFI_ALLOCATE_TYPE = ::ctypes::c_uint;
pub const EFI_MEMORY_TYPE_EfiReservedMemoryType: EFI_MEMORY_TYPE = 0;
pub const EFI_MEMORY_TYPE_EfiLoaderCode: EFI_MEMORY_TYPE = 1;
pub const EFI_MEMORY_TYPE_EfiLoaderData: EFI_MEMORY_TYPE = 2;
pub const EFI_MEMORY_TYPE_EfiBootServicesCode: EFI_MEMORY_TYPE = 3;
pub const EFI_MEMORY_TYPE_EfiBootServicesData: EFI_MEMORY_TYPE = 4;
pub const EFI_MEMORY_TYPE_EfiRuntimeServicesCode: EFI_MEMORY_TYPE = 5;
pub const EFI_MEMORY_TYPE_EfiRuntimeServicesData: EFI_MEMORY_TYPE = 6;
pub const EFI_MEMORY_TYPE_EfiConventionalMemory: EFI_MEMORY_TYPE = 7;
pub const EFI_MEMORY_TYPE_EfiUnusableMemory: EFI_MEMORY_TYPE = 8;
pub const EFI_MEMORY_TYPE_EfiACPIReclaimMemory: EFI_MEMORY_TYPE = 9;
pub const EFI_MEMORY_TYPE_EfiACPIMemoryNVS: EFI_MEMORY_TYPE = 10;
pub const EFI_MEMORY_TYPE_EfiMemoryMappedIO: EFI_MEMORY_TYPE = 11;
pub const EFI_MEMORY_TYPE_EfiMemoryMappedIOPortSpace: EFI_MEMORY_TYPE = 12;
pub const EFI_MEMORY_TYPE_EfiPalCode: EFI_MEMORY_TYPE = 13;
pub const EFI_MEMORY_TYPE_EfiMaxMemoryType: EFI_MEMORY_TYPE = 14;
pub type EFI_MEMORY_TYPE = ::ctypes::c_uint;
#[repr(C)]

pub struct EFI_MEMORY_DESCRIPTOR {
    pub Type: UINT32,
    pub Pad: UINT32,
    pub PhysicalStart: EFI_PHYSICAL_ADDRESS,
    pub VirtualStart: EFI_VIRTUAL_ADDRESS,
    pub NumberOfPages: UINT64,
    pub Attribute: UINT64,
}
#[test]
fn bindgen_test_layout_EFI_MEMORY_DESCRIPTOR() {
    assert_eq!(::core::mem::size_of::<EFI_MEMORY_DESCRIPTOR>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_MEMORY_DESCRIPTOR )
               ));
    assert_eq! (::core::mem::align_of::<EFI_MEMORY_DESCRIPTOR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_MEMORY_DESCRIPTOR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MEMORY_DESCRIPTOR ) ) . Type as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_MEMORY_DESCRIPTOR )
                , "::" , stringify ! ( Type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MEMORY_DESCRIPTOR ) ) . Pad as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_MEMORY_DESCRIPTOR )
                , "::" , stringify ! ( Pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MEMORY_DESCRIPTOR ) ) . PhysicalStart
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_MEMORY_DESCRIPTOR )
                , "::" , stringify ! ( PhysicalStart ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MEMORY_DESCRIPTOR ) ) . VirtualStart
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_MEMORY_DESCRIPTOR )
                , "::" , stringify ! ( VirtualStart ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MEMORY_DESCRIPTOR ) ) . NumberOfPages
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_MEMORY_DESCRIPTOR )
                , "::" , stringify ! ( NumberOfPages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_MEMORY_DESCRIPTOR ) ) . Attribute as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_MEMORY_DESCRIPTOR )
                , "::" , stringify ! ( Attribute ) ));
}
impl Clone for EFI_MEMORY_DESCRIPTOR {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type ISO_639_2 = UINT8;
#[repr(C)]

pub struct _EFI_DEVICE_PATH {
    pub Type: UINT8,
    pub SubType: UINT8,
    pub Length: [UINT8; 2usize],
}
#[test]
fn bindgen_test_layout__EFI_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_EFI_DEVICE_PATH>() , 4usize , concat !
               ( "Size of: " , stringify ! ( _EFI_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_EFI_DEVICE_PATH>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( _EFI_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DEVICE_PATH ) ) . Type as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_DEVICE_PATH ) ,
                "::" , stringify ! ( Type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DEVICE_PATH ) ) . SubType as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_DEVICE_PATH ) ,
                "::" , stringify ! ( SubType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DEVICE_PATH ) ) . Length as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_DEVICE_PATH ) ,
                "::" , stringify ! ( Length ) ));
}
impl Clone for _EFI_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_DEVICE_PATH = _EFI_DEVICE_PATH;
#[repr(C)]

pub struct _PCI_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub Function: UINT8,
    pub Device: UINT8,
}
#[test]
fn bindgen_test_layout__PCI_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_PCI_DEVICE_PATH>() , 6usize , concat !
               ( "Size of: " , stringify ! ( _PCI_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_PCI_DEVICE_PATH>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( _PCI_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _PCI_DEVICE_PATH ) ) . Header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _PCI_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _PCI_DEVICE_PATH ) ) . Function as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _PCI_DEVICE_PATH ) ,
                "::" , stringify ! ( Function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _PCI_DEVICE_PATH ) ) . Device as * const
                _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( _PCI_DEVICE_PATH ) ,
                "::" , stringify ! ( Device ) ));
}
impl Clone for _PCI_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type PCI_DEVICE_PATH = _PCI_DEVICE_PATH;
#[repr(C)]

pub struct _PCCARD_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub FunctionNumber: UINT8,
}
#[test]
fn bindgen_test_layout__PCCARD_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_PCCARD_DEVICE_PATH>() , 5usize , concat
               ! ( "Size of: " , stringify ! ( _PCCARD_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_PCCARD_DEVICE_PATH>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( _PCCARD_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _PCCARD_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _PCCARD_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _PCCARD_DEVICE_PATH ) ) . FunctionNumber
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _PCCARD_DEVICE_PATH ) ,
                "::" , stringify ! ( FunctionNumber ) ));
}
impl Clone for _PCCARD_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type PCCARD_DEVICE_PATH = _PCCARD_DEVICE_PATH;
#[repr(C)]

pub struct _MEMMAP_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub MemoryType: UINT32,
    pub StartingAddress: EFI_PHYSICAL_ADDRESS,
    pub EndingAddress: EFI_PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__MEMMAP_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_MEMMAP_DEVICE_PATH>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( _MEMMAP_DEVICE_PATH )
               ));
    assert_eq! (::core::mem::align_of::<_MEMMAP_DEVICE_PATH>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _MEMMAP_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _MEMMAP_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _MEMMAP_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _MEMMAP_DEVICE_PATH ) ) . MemoryType as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _MEMMAP_DEVICE_PATH ) ,
                "::" , stringify ! ( MemoryType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _MEMMAP_DEVICE_PATH ) ) . StartingAddress
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _MEMMAP_DEVICE_PATH ) ,
                "::" , stringify ! ( StartingAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _MEMMAP_DEVICE_PATH ) ) . EndingAddress
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _MEMMAP_DEVICE_PATH ) ,
                "::" , stringify ! ( EndingAddress ) ));
}
impl Clone for _MEMMAP_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type MEMMAP_DEVICE_PATH = _MEMMAP_DEVICE_PATH;
#[repr(C)]

pub struct _VENDOR_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub Guid: EFI_GUID,
}
#[test]
fn bindgen_test_layout__VENDOR_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_VENDOR_DEVICE_PATH>() , 20usize ,
               concat ! ( "Size of: " , stringify ! ( _VENDOR_DEVICE_PATH )
               ));
    assert_eq! (::core::mem::align_of::<_VENDOR_DEVICE_PATH>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( _VENDOR_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VENDOR_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VENDOR_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VENDOR_DEVICE_PATH ) ) . Guid as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _VENDOR_DEVICE_PATH ) ,
                "::" , stringify ! ( Guid ) ));
}
impl Clone for _VENDOR_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type VENDOR_DEVICE_PATH = _VENDOR_DEVICE_PATH;
#[repr(C)]

pub struct _UKNOWN_DEVICE_VENDOR_DP {
    pub DevicePath: VENDOR_DEVICE_PATH,
    pub LegacyDriveLetter: UINT8,
}
#[test]
fn bindgen_test_layout__UKNOWN_DEVICE_VENDOR_DP() {
    assert_eq!(::core::mem::size_of::<_UKNOWN_DEVICE_VENDOR_DP>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( _UKNOWN_DEVICE_VENDOR_DP ) ));
    assert_eq! (::core::mem::align_of::<_UKNOWN_DEVICE_VENDOR_DP>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( _UKNOWN_DEVICE_VENDOR_DP ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _UKNOWN_DEVICE_VENDOR_DP ) ) . DevicePath
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _UKNOWN_DEVICE_VENDOR_DP ) , "::" , stringify ! ( DevicePath )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _UKNOWN_DEVICE_VENDOR_DP ) ) .
                LegacyDriveLetter as * const _ as usize } , 20usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _UKNOWN_DEVICE_VENDOR_DP ) , "::" , stringify ! (
                LegacyDriveLetter ) ));
}
impl Clone for _UKNOWN_DEVICE_VENDOR_DP {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type UNKNOWN_DEVICE_VENDOR_DEVICE_PATH = _UKNOWN_DEVICE_VENDOR_DP;
#[repr(C)]

pub struct _CONTROLLER_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub Controller: UINT32,
}
#[test]
fn bindgen_test_layout__CONTROLLER_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_CONTROLLER_DEVICE_PATH>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( _CONTROLLER_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_CONTROLLER_DEVICE_PATH>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( _CONTROLLER_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _CONTROLLER_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _CONTROLLER_DEVICE_PATH
                ) , "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _CONTROLLER_DEVICE_PATH ) ) . Controller
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _CONTROLLER_DEVICE_PATH
                ) , "::" , stringify ! ( Controller ) ));
}
impl Clone for _CONTROLLER_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type CONTROLLER_DEVICE_PATH = _CONTROLLER_DEVICE_PATH;
#[repr(C)]

pub struct _ACPI_HID_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub HID: UINT32,
    pub UID: UINT32,
}
#[test]
fn bindgen_test_layout__ACPI_HID_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_ACPI_HID_DEVICE_PATH>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( _ACPI_HID_DEVICE_PATH )
               ));
    assert_eq! (::core::mem::align_of::<_ACPI_HID_DEVICE_PATH>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( _ACPI_HID_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ACPI_HID_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _ACPI_HID_DEVICE_PATH )
                , "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ACPI_HID_DEVICE_PATH ) ) . HID as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _ACPI_HID_DEVICE_PATH )
                , "::" , stringify ! ( HID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ACPI_HID_DEVICE_PATH ) ) . UID as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _ACPI_HID_DEVICE_PATH )
                , "::" , stringify ! ( UID ) ));
}
impl Clone for _ACPI_HID_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type ACPI_HID_DEVICE_PATH = _ACPI_HID_DEVICE_PATH;
#[repr(C)]

pub struct _EXPANDED_ACPI_HID_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub HID: UINT32,
    pub UID: UINT32,
    pub CID: UINT32,
    pub HidStr: [UINT8; 1usize],
}
#[test]
fn bindgen_test_layout__EXPANDED_ACPI_HID_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_EXPANDED_ACPI_HID_DEVICE_PATH>() ,
               20usize , concat ! (
               "Size of: " , stringify ! ( _EXPANDED_ACPI_HID_DEVICE_PATH )
               ));
    assert_eq! (::core::mem::align_of::<_EXPANDED_ACPI_HID_DEVICE_PATH>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( _EXPANDED_ACPI_HID_DEVICE_PATH
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EXPANDED_ACPI_HID_DEVICE_PATH ) ) .
                Header as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EXPANDED_ACPI_HID_DEVICE_PATH ) , "::" , stringify ! ( Header
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EXPANDED_ACPI_HID_DEVICE_PATH ) ) . HID
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EXPANDED_ACPI_HID_DEVICE_PATH ) , "::" , stringify ! ( HID )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EXPANDED_ACPI_HID_DEVICE_PATH ) ) . UID
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EXPANDED_ACPI_HID_DEVICE_PATH ) , "::" , stringify ! ( UID )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EXPANDED_ACPI_HID_DEVICE_PATH ) ) . CID
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EXPANDED_ACPI_HID_DEVICE_PATH ) , "::" , stringify ! ( CID )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EXPANDED_ACPI_HID_DEVICE_PATH ) ) .
                HidStr as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EXPANDED_ACPI_HID_DEVICE_PATH ) , "::" , stringify ! ( HidStr
                ) ));
}
impl Clone for _EXPANDED_ACPI_HID_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EXPANDED_ACPI_HID_DEVICE_PATH = _EXPANDED_ACPI_HID_DEVICE_PATH;
#[repr(C)]

pub struct _ACPI_ADR_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub ADR: UINT32,
}
#[test]
fn bindgen_test_layout__ACPI_ADR_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_ACPI_ADR_DEVICE_PATH>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( _ACPI_ADR_DEVICE_PATH )
               ));
    assert_eq! (::core::mem::align_of::<_ACPI_ADR_DEVICE_PATH>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( _ACPI_ADR_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ACPI_ADR_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _ACPI_ADR_DEVICE_PATH )
                , "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ACPI_ADR_DEVICE_PATH ) ) . ADR as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _ACPI_ADR_DEVICE_PATH )
                , "::" , stringify ! ( ADR ) ));
}
impl Clone for _ACPI_ADR_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type ACPI_ADR_DEVICE_PATH = _ACPI_ADR_DEVICE_PATH;
#[repr(C)]

pub struct _ATAPI_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub PrimarySecondary: UINT8,
    pub SlaveMaster: UINT8,
    pub Lun: UINT16,
}
#[test]
fn bindgen_test_layout__ATAPI_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_ATAPI_DEVICE_PATH>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( _ATAPI_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_ATAPI_DEVICE_PATH>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( _ATAPI_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ATAPI_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _ATAPI_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ATAPI_DEVICE_PATH ) ) . PrimarySecondary
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _ATAPI_DEVICE_PATH ) ,
                "::" , stringify ! ( PrimarySecondary ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ATAPI_DEVICE_PATH ) ) . SlaveMaster as *
                const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( _ATAPI_DEVICE_PATH ) ,
                "::" , stringify ! ( SlaveMaster ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ATAPI_DEVICE_PATH ) ) . Lun as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _ATAPI_DEVICE_PATH ) ,
                "::" , stringify ! ( Lun ) ));
}
impl Clone for _ATAPI_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type ATAPI_DEVICE_PATH = _ATAPI_DEVICE_PATH;
#[repr(C)]

pub struct _SCSI_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub Pun: UINT16,
    pub Lun: UINT16,
}
#[test]
fn bindgen_test_layout__SCSI_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_SCSI_DEVICE_PATH>() , 8usize , concat !
               ( "Size of: " , stringify ! ( _SCSI_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_SCSI_DEVICE_PATH>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( _SCSI_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SCSI_DEVICE_PATH ) ) . Header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _SCSI_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SCSI_DEVICE_PATH ) ) . Pun as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _SCSI_DEVICE_PATH ) ,
                "::" , stringify ! ( Pun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SCSI_DEVICE_PATH ) ) . Lun as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _SCSI_DEVICE_PATH ) ,
                "::" , stringify ! ( Lun ) ));
}
impl Clone for _SCSI_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type SCSI_DEVICE_PATH = _SCSI_DEVICE_PATH;
#[repr(C)]

pub struct _FIBRECHANNEL_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub Reserved: UINT32,
    pub WWN: UINT64,
    pub Lun: UINT64,
}
#[test]
fn bindgen_test_layout__FIBRECHANNEL_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_FIBRECHANNEL_DEVICE_PATH>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( _FIBRECHANNEL_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_FIBRECHANNEL_DEVICE_PATH>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _FIBRECHANNEL_DEVICE_PATH )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _FIBRECHANNEL_DEVICE_PATH ) ) . Header as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _FIBRECHANNEL_DEVICE_PATH ) , "::" , stringify ! ( Header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _FIBRECHANNEL_DEVICE_PATH ) ) . Reserved
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                _FIBRECHANNEL_DEVICE_PATH ) , "::" , stringify ! ( Reserved )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _FIBRECHANNEL_DEVICE_PATH ) ) . WWN as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _FIBRECHANNEL_DEVICE_PATH ) , "::" , stringify ! ( WWN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _FIBRECHANNEL_DEVICE_PATH ) ) . Lun as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _FIBRECHANNEL_DEVICE_PATH ) , "::" , stringify ! ( Lun ) ));
}
impl Clone for _FIBRECHANNEL_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type FIBRECHANNEL_DEVICE_PATH = _FIBRECHANNEL_DEVICE_PATH;
#[repr(C)]

pub struct _FIBRECHANNELEX_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub Reserved: UINT32,
    pub WWN: [UINT8; 8usize],
    pub Lun: [UINT8; 8usize],
}
#[test]
fn bindgen_test_layout__FIBRECHANNELEX_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_FIBRECHANNELEX_DEVICE_PATH>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _FIBRECHANNELEX_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_FIBRECHANNELEX_DEVICE_PATH>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( _FIBRECHANNELEX_DEVICE_PATH )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _FIBRECHANNELEX_DEVICE_PATH ) ) . Header
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _FIBRECHANNELEX_DEVICE_PATH ) , "::" , stringify ! ( Header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _FIBRECHANNELEX_DEVICE_PATH ) ) .
                Reserved as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                _FIBRECHANNELEX_DEVICE_PATH ) , "::" , stringify ! ( Reserved
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _FIBRECHANNELEX_DEVICE_PATH ) ) . WWN as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _FIBRECHANNELEX_DEVICE_PATH ) , "::" , stringify ! ( WWN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _FIBRECHANNELEX_DEVICE_PATH ) ) . Lun as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _FIBRECHANNELEX_DEVICE_PATH ) , "::" , stringify ! ( Lun ) ));
}
impl Clone for _FIBRECHANNELEX_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type FIBRECHANNELEX_DEVICE_PATH = _FIBRECHANNELEX_DEVICE_PATH;
#[repr(C)]

pub struct _F1394_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub Reserved: UINT32,
    pub Guid: UINT64,
}
#[test]
fn bindgen_test_layout__F1394_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_F1394_DEVICE_PATH>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( _F1394_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_F1394_DEVICE_PATH>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _F1394_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _F1394_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _F1394_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _F1394_DEVICE_PATH ) ) . Reserved as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _F1394_DEVICE_PATH ) ,
                "::" , stringify ! ( Reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _F1394_DEVICE_PATH ) ) . Guid as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _F1394_DEVICE_PATH ) ,
                "::" , stringify ! ( Guid ) ));
}
impl Clone for _F1394_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type F1394_DEVICE_PATH = _F1394_DEVICE_PATH;
#[repr(C)]

pub struct _USB_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub Port: UINT8,
    pub Endpoint: UINT8,
}
#[test]
fn bindgen_test_layout__USB_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_USB_DEVICE_PATH>() , 6usize , concat !
               ( "Size of: " , stringify ! ( _USB_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_USB_DEVICE_PATH>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( _USB_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _USB_DEVICE_PATH ) ) . Header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _USB_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _USB_DEVICE_PATH ) ) . Port as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _USB_DEVICE_PATH ) ,
                "::" , stringify ! ( Port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _USB_DEVICE_PATH ) ) . Endpoint as *
                const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( _USB_DEVICE_PATH ) ,
                "::" , stringify ! ( Endpoint ) ));
}
impl Clone for _USB_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type USB_DEVICE_PATH = _USB_DEVICE_PATH;
#[repr(C)]

pub struct _SATA_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub HBAPortNumber: UINT16,
    pub PortMultiplierPortNumber: UINT16,
    pub Lun: UINT16,
}
#[test]
fn bindgen_test_layout__SATA_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_SATA_DEVICE_PATH>() , 10usize , concat
               ! ( "Size of: " , stringify ! ( _SATA_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_SATA_DEVICE_PATH>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( _SATA_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SATA_DEVICE_PATH ) ) . Header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _SATA_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SATA_DEVICE_PATH ) ) . HBAPortNumber as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _SATA_DEVICE_PATH ) ,
                "::" , stringify ! ( HBAPortNumber ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SATA_DEVICE_PATH ) ) .
                PortMultiplierPortNumber as * const _ as usize } , 6usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _SATA_DEVICE_PATH ) ,
                "::" , stringify ! ( PortMultiplierPortNumber ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SATA_DEVICE_PATH ) ) . Lun as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _SATA_DEVICE_PATH ) ,
                "::" , stringify ! ( Lun ) ));
}
impl Clone for _SATA_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type SATA_DEVICE_PATH = _SATA_DEVICE_PATH;
#[repr(C)]

pub struct _USB_WWID_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub InterfaceNumber: UINT16,
    pub VendorId: UINT16,
    pub ProductId: UINT16,
    pub SerialNumber: [CHAR16; 1usize],
}
#[test]
fn bindgen_test_layout__USB_WWID_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_USB_WWID_DEVICE_PATH>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( _USB_WWID_DEVICE_PATH )
               ));
    assert_eq! (::core::mem::align_of::<_USB_WWID_DEVICE_PATH>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( _USB_WWID_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _USB_WWID_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _USB_WWID_DEVICE_PATH )
                , "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _USB_WWID_DEVICE_PATH ) ) .
                InterfaceNumber as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _USB_WWID_DEVICE_PATH )
                , "::" , stringify ! ( InterfaceNumber ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _USB_WWID_DEVICE_PATH ) ) . VendorId as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _USB_WWID_DEVICE_PATH )
                , "::" , stringify ! ( VendorId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _USB_WWID_DEVICE_PATH ) ) . ProductId as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _USB_WWID_DEVICE_PATH )
                , "::" , stringify ! ( ProductId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _USB_WWID_DEVICE_PATH ) ) . SerialNumber
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _USB_WWID_DEVICE_PATH )
                , "::" , stringify ! ( SerialNumber ) ));
}
impl Clone for _USB_WWID_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type USB_WWID_DEVICE_PATH = _USB_WWID_DEVICE_PATH;
#[repr(C)]

pub struct _DEVICE_LOGICAL_UNIT_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub Lun: UINT8,
}
#[test]
fn bindgen_test_layout__DEVICE_LOGICAL_UNIT_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_DEVICE_LOGICAL_UNIT_DEVICE_PATH>() ,
               5usize , concat ! (
               "Size of: " , stringify ! ( _DEVICE_LOGICAL_UNIT_DEVICE_PATH )
               ));
    assert_eq! (::core::mem::align_of::<_DEVICE_LOGICAL_UNIT_DEVICE_PATH>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                _DEVICE_LOGICAL_UNIT_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _DEVICE_LOGICAL_UNIT_DEVICE_PATH ) ) .
                Header as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _DEVICE_LOGICAL_UNIT_DEVICE_PATH ) , "::" , stringify ! (
                Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _DEVICE_LOGICAL_UNIT_DEVICE_PATH ) ) .
                Lun as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                _DEVICE_LOGICAL_UNIT_DEVICE_PATH ) , "::" , stringify ! ( Lun
                ) ));
}
impl Clone for _DEVICE_LOGICAL_UNIT_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type DEVICE_LOGICAL_UNIT_DEVICE_PATH = _DEVICE_LOGICAL_UNIT_DEVICE_PATH;
#[repr(C)]

pub struct _USB_CLASS_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub VendorId: UINT16,
    pub ProductId: UINT16,
    pub DeviceClass: UINT8,
    pub DeviceSubclass: UINT8,
    pub DeviceProtocol: UINT8,
}
#[test]
fn bindgen_test_layout__USB_CLASS_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_USB_CLASS_DEVICE_PATH>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( _USB_CLASS_DEVICE_PATH )
               ));
    assert_eq! (::core::mem::align_of::<_USB_CLASS_DEVICE_PATH>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( _USB_CLASS_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _USB_CLASS_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _USB_CLASS_DEVICE_PATH
                ) , "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _USB_CLASS_DEVICE_PATH ) ) . VendorId as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _USB_CLASS_DEVICE_PATH
                ) , "::" , stringify ! ( VendorId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _USB_CLASS_DEVICE_PATH ) ) . ProductId as
                * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _USB_CLASS_DEVICE_PATH
                ) , "::" , stringify ! ( ProductId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _USB_CLASS_DEVICE_PATH ) ) . DeviceClass
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _USB_CLASS_DEVICE_PATH
                ) , "::" , stringify ! ( DeviceClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _USB_CLASS_DEVICE_PATH ) ) .
                DeviceSubclass as * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( _USB_CLASS_DEVICE_PATH
                ) , "::" , stringify ! ( DeviceSubclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _USB_CLASS_DEVICE_PATH ) ) .
                DeviceProtocol as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _USB_CLASS_DEVICE_PATH
                ) , "::" , stringify ! ( DeviceProtocol ) ));
}
impl Clone for _USB_CLASS_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type USB_CLASS_DEVICE_PATH = _USB_CLASS_DEVICE_PATH;
#[repr(C)]

pub struct _I2O_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub Tid: UINT32,
}
#[test]
fn bindgen_test_layout__I2O_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_I2O_DEVICE_PATH>() , 8usize , concat !
               ( "Size of: " , stringify ! ( _I2O_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_I2O_DEVICE_PATH>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( _I2O_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _I2O_DEVICE_PATH ) ) . Header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _I2O_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _I2O_DEVICE_PATH ) ) . Tid as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _I2O_DEVICE_PATH ) ,
                "::" , stringify ! ( Tid ) ));
}
impl Clone for _I2O_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type I2O_DEVICE_PATH = _I2O_DEVICE_PATH;
#[repr(C)]

pub struct _MAC_ADDR_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub MacAddress: EFI_MAC_ADDRESS,
    pub IfType: UINT8,
}
#[test]
fn bindgen_test_layout__MAC_ADDR_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_MAC_ADDR_DEVICE_PATH>() , 37usize ,
               concat ! ( "Size of: " , stringify ! ( _MAC_ADDR_DEVICE_PATH )
               ));
    assert_eq! (::core::mem::align_of::<_MAC_ADDR_DEVICE_PATH>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( _MAC_ADDR_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _MAC_ADDR_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _MAC_ADDR_DEVICE_PATH )
                , "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _MAC_ADDR_DEVICE_PATH ) ) . MacAddress as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _MAC_ADDR_DEVICE_PATH )
                , "::" , stringify ! ( MacAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _MAC_ADDR_DEVICE_PATH ) ) . IfType as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _MAC_ADDR_DEVICE_PATH )
                , "::" , stringify ! ( IfType ) ));
}
impl Clone for _MAC_ADDR_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type MAC_ADDR_DEVICE_PATH = _MAC_ADDR_DEVICE_PATH;
#[repr(C)]

pub struct _IPv4_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub LocalIpAddress: EFI_IPv4_ADDRESS,
    pub RemoteIpAddress: EFI_IPv4_ADDRESS,
    pub LocalPort: UINT16,
    pub RemotePort: UINT16,
    pub Protocol: UINT16,
    pub StaticIpAddress: BOOLEAN,
    pub GatewayIpAddress: EFI_IPv4_ADDRESS,
    pub SubnetMask: EFI_IPv4_ADDRESS,
}
#[test]
fn bindgen_test_layout__IPv4_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_IPv4_DEVICE_PATH>() , 28usize , concat
               ! ( "Size of: " , stringify ! ( _IPv4_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_IPv4_DEVICE_PATH>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( _IPv4_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv4_DEVICE_PATH ) ) . Header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv4_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv4_DEVICE_PATH ) ) . LocalIpAddress as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv4_DEVICE_PATH ) ,
                "::" , stringify ! ( LocalIpAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv4_DEVICE_PATH ) ) . RemoteIpAddress
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv4_DEVICE_PATH ) ,
                "::" , stringify ! ( RemoteIpAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv4_DEVICE_PATH ) ) . LocalPort as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv4_DEVICE_PATH ) ,
                "::" , stringify ! ( LocalPort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv4_DEVICE_PATH ) ) . RemotePort as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv4_DEVICE_PATH ) ,
                "::" , stringify ! ( RemotePort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv4_DEVICE_PATH ) ) . Protocol as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv4_DEVICE_PATH ) ,
                "::" , stringify ! ( Protocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv4_DEVICE_PATH ) ) . StaticIpAddress
                as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv4_DEVICE_PATH ) ,
                "::" , stringify ! ( StaticIpAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv4_DEVICE_PATH ) ) . GatewayIpAddress
                as * const _ as usize } , 19usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv4_DEVICE_PATH ) ,
                "::" , stringify ! ( GatewayIpAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv4_DEVICE_PATH ) ) . SubnetMask as *
                const _ as usize } , 23usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv4_DEVICE_PATH ) ,
                "::" , stringify ! ( SubnetMask ) ));
}
impl Clone for _IPv4_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type IPv4_DEVICE_PATH = _IPv4_DEVICE_PATH;
#[repr(C)]

pub struct _IPv6_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub LocalIpAddress: EFI_IPv6_ADDRESS,
    pub RemoteIpAddress: EFI_IPv6_ADDRESS,
    pub LocalPort: UINT16,
    pub RemotePort: UINT16,
    pub Protocol: UINT16,
    pub IPAddressOrigin: BOOLEAN,
    pub PrefixLength: UINT8,
    pub GatewayIpAddress: EFI_IPv6_ADDRESS,
}
#[test]
fn bindgen_test_layout__IPv6_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_IPv6_DEVICE_PATH>() , 60usize , concat
               ! ( "Size of: " , stringify ! ( _IPv6_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_IPv6_DEVICE_PATH>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( _IPv6_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv6_DEVICE_PATH ) ) . Header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv6_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv6_DEVICE_PATH ) ) . LocalIpAddress as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv6_DEVICE_PATH ) ,
                "::" , stringify ! ( LocalIpAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv6_DEVICE_PATH ) ) . RemoteIpAddress
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv6_DEVICE_PATH ) ,
                "::" , stringify ! ( RemoteIpAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv6_DEVICE_PATH ) ) . LocalPort as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv6_DEVICE_PATH ) ,
                "::" , stringify ! ( LocalPort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv6_DEVICE_PATH ) ) . RemotePort as *
                const _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv6_DEVICE_PATH ) ,
                "::" , stringify ! ( RemotePort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv6_DEVICE_PATH ) ) . Protocol as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv6_DEVICE_PATH ) ,
                "::" , stringify ! ( Protocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv6_DEVICE_PATH ) ) . IPAddressOrigin
                as * const _ as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv6_DEVICE_PATH ) ,
                "::" , stringify ! ( IPAddressOrigin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv6_DEVICE_PATH ) ) . PrefixLength as *
                const _ as usize } , 43usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv6_DEVICE_PATH ) ,
                "::" , stringify ! ( PrefixLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IPv6_DEVICE_PATH ) ) . GatewayIpAddress
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( _IPv6_DEVICE_PATH ) ,
                "::" , stringify ! ( GatewayIpAddress ) ));
}
impl Clone for _IPv6_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type IPv6_DEVICE_PATH = _IPv6_DEVICE_PATH;
#[repr(C)]

pub struct _URI_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub Uri: [CHAR8; 1usize],
}
#[test]
fn bindgen_test_layout__URI_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_URI_DEVICE_PATH>() , 5usize , concat !
               ( "Size of: " , stringify ! ( _URI_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_URI_DEVICE_PATH>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( _URI_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _URI_DEVICE_PATH ) ) . Header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _URI_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _URI_DEVICE_PATH ) ) . Uri as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _URI_DEVICE_PATH ) ,
                "::" , stringify ! ( Uri ) ));
}
impl Clone for _URI_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type URI_DEVICE_PATH = _URI_DEVICE_PATH;
#[repr(C)]

pub struct _VLAN_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub VlanId: UINT16,
}
#[test]
fn bindgen_test_layout__VLAN_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_VLAN_DEVICE_PATH>() , 6usize , concat !
               ( "Size of: " , stringify ! ( _VLAN_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_VLAN_DEVICE_PATH>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( _VLAN_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VLAN_DEVICE_PATH ) ) . Header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VLAN_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VLAN_DEVICE_PATH ) ) . VlanId as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _VLAN_DEVICE_PATH ) ,
                "::" , stringify ! ( VlanId ) ));
}
impl Clone for _VLAN_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type VLAN_DEVICE_PATH = _VLAN_DEVICE_PATH;
#[repr(C)]

pub struct _INFINIBAND_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub ResourceFlags: UINT32,
    pub PortGid: UINT64,
    pub ServiceId: UINT64,
    pub TargetPortId: UINT64,
    pub DeviceId: UINT64,
}
#[test]
fn bindgen_test_layout__INFINIBAND_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_INFINIBAND_DEVICE_PATH>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( _INFINIBAND_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_INFINIBAND_DEVICE_PATH>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _INFINIBAND_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _INFINIBAND_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _INFINIBAND_DEVICE_PATH
                ) , "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _INFINIBAND_DEVICE_PATH ) ) .
                ResourceFlags as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _INFINIBAND_DEVICE_PATH
                ) , "::" , stringify ! ( ResourceFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _INFINIBAND_DEVICE_PATH ) ) . PortGid as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _INFINIBAND_DEVICE_PATH
                ) , "::" , stringify ! ( PortGid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _INFINIBAND_DEVICE_PATH ) ) . ServiceId
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _INFINIBAND_DEVICE_PATH
                ) , "::" , stringify ! ( ServiceId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _INFINIBAND_DEVICE_PATH ) ) .
                TargetPortId as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _INFINIBAND_DEVICE_PATH
                ) , "::" , stringify ! ( TargetPortId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _INFINIBAND_DEVICE_PATH ) ) . DeviceId as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _INFINIBAND_DEVICE_PATH
                ) , "::" , stringify ! ( DeviceId ) ));
}
impl Clone for _INFINIBAND_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type INFINIBAND_DEVICE_PATH = _INFINIBAND_DEVICE_PATH;
#[repr(C)]

pub struct _UART_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub Reserved: UINT32,
    pub BaudRate: UINT64,
    pub DataBits: UINT8,
    pub Parity: UINT8,
    pub StopBits: UINT8,
}
#[test]
fn bindgen_test_layout__UART_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_UART_DEVICE_PATH>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( _UART_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_UART_DEVICE_PATH>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _UART_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _UART_DEVICE_PATH ) ) . Header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _UART_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _UART_DEVICE_PATH ) ) . Reserved as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _UART_DEVICE_PATH ) ,
                "::" , stringify ! ( Reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _UART_DEVICE_PATH ) ) . BaudRate as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _UART_DEVICE_PATH ) ,
                "::" , stringify ! ( BaudRate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _UART_DEVICE_PATH ) ) . DataBits as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _UART_DEVICE_PATH ) ,
                "::" , stringify ! ( DataBits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _UART_DEVICE_PATH ) ) . Parity as * const
                _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( _UART_DEVICE_PATH ) ,
                "::" , stringify ! ( Parity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _UART_DEVICE_PATH ) ) . StopBits as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( _UART_DEVICE_PATH ) ,
                "::" , stringify ! ( StopBits ) ));
}
impl Clone for _UART_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type UART_DEVICE_PATH = _UART_DEVICE_PATH;
#[repr(C)]

pub struct _HARDDRIVE_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub PartitionNumber: UINT32,
    pub PartitionStart: UINT64,
    pub PartitionSize: UINT64,
    pub Signature: [UINT8; 16usize],
    pub MBRType: UINT8,
    pub SignatureType: UINT8,
}
#[test]
fn bindgen_test_layout__HARDDRIVE_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_HARDDRIVE_DEVICE_PATH>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _HARDDRIVE_DEVICE_PATH )
               ));
    assert_eq! (::core::mem::align_of::<_HARDDRIVE_DEVICE_PATH>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _HARDDRIVE_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _HARDDRIVE_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _HARDDRIVE_DEVICE_PATH
                ) , "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _HARDDRIVE_DEVICE_PATH ) ) .
                PartitionNumber as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _HARDDRIVE_DEVICE_PATH
                ) , "::" , stringify ! ( PartitionNumber ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _HARDDRIVE_DEVICE_PATH ) ) .
                PartitionStart as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _HARDDRIVE_DEVICE_PATH
                ) , "::" , stringify ! ( PartitionStart ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _HARDDRIVE_DEVICE_PATH ) ) .
                PartitionSize as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _HARDDRIVE_DEVICE_PATH
                ) , "::" , stringify ! ( PartitionSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _HARDDRIVE_DEVICE_PATH ) ) . Signature as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _HARDDRIVE_DEVICE_PATH
                ) , "::" , stringify ! ( Signature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _HARDDRIVE_DEVICE_PATH ) ) . MBRType as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _HARDDRIVE_DEVICE_PATH
                ) , "::" , stringify ! ( MBRType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _HARDDRIVE_DEVICE_PATH ) ) .
                SignatureType as * const _ as usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( _HARDDRIVE_DEVICE_PATH
                ) , "::" , stringify ! ( SignatureType ) ));
}
impl Clone for _HARDDRIVE_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type HARDDRIVE_DEVICE_PATH = _HARDDRIVE_DEVICE_PATH;
#[repr(C)]

pub struct _CDROM_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub BootEntry: UINT32,
    pub PartitionStart: UINT64,
    pub PartitionSize: UINT64,
}
#[test]
fn bindgen_test_layout__CDROM_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_CDROM_DEVICE_PATH>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( _CDROM_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_CDROM_DEVICE_PATH>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _CDROM_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _CDROM_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _CDROM_DEVICE_PATH ) ,
                "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _CDROM_DEVICE_PATH ) ) . BootEntry as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _CDROM_DEVICE_PATH ) ,
                "::" , stringify ! ( BootEntry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _CDROM_DEVICE_PATH ) ) . PartitionStart
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _CDROM_DEVICE_PATH ) ,
                "::" , stringify ! ( PartitionStart ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _CDROM_DEVICE_PATH ) ) . PartitionSize as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _CDROM_DEVICE_PATH ) ,
                "::" , stringify ! ( PartitionSize ) ));
}
impl Clone for _CDROM_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type CDROM_DEVICE_PATH = _CDROM_DEVICE_PATH;
#[repr(C)]

pub struct _FILEPATH_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub PathName: [CHAR16; 1usize],
}
#[test]
fn bindgen_test_layout__FILEPATH_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_FILEPATH_DEVICE_PATH>() , 6usize ,
               concat ! ( "Size of: " , stringify ! ( _FILEPATH_DEVICE_PATH )
               ));
    assert_eq! (::core::mem::align_of::<_FILEPATH_DEVICE_PATH>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( _FILEPATH_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _FILEPATH_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _FILEPATH_DEVICE_PATH )
                , "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _FILEPATH_DEVICE_PATH ) ) . PathName as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _FILEPATH_DEVICE_PATH )
                , "::" , stringify ! ( PathName ) ));
}
impl Clone for _FILEPATH_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type FILEPATH_DEVICE_PATH = _FILEPATH_DEVICE_PATH;
#[repr(C)]

pub struct _MEDIA_PROTOCOL_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub Protocol: EFI_GUID,
}
#[test]
fn bindgen_test_layout__MEDIA_PROTOCOL_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_MEDIA_PROTOCOL_DEVICE_PATH>() , 20usize
               , concat ! (
               "Size of: " , stringify ! ( _MEDIA_PROTOCOL_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_MEDIA_PROTOCOL_DEVICE_PATH>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( _MEDIA_PROTOCOL_DEVICE_PATH )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _MEDIA_PROTOCOL_DEVICE_PATH ) ) . Header
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _MEDIA_PROTOCOL_DEVICE_PATH ) , "::" , stringify ! ( Header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _MEDIA_PROTOCOL_DEVICE_PATH ) ) .
                Protocol as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                _MEDIA_PROTOCOL_DEVICE_PATH ) , "::" , stringify ! ( Protocol
                ) ));
}
impl Clone for _MEDIA_PROTOCOL_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type MEDIA_PROTOCOL_DEVICE_PATH = _MEDIA_PROTOCOL_DEVICE_PATH;
#[repr(C)]

pub struct _MEDIA_FW_VOL_FILEPATH_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub FvFileName: EFI_GUID,
}
#[test]
fn bindgen_test_layout__MEDIA_FW_VOL_FILEPATH_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_MEDIA_FW_VOL_FILEPATH_DEVICE_PATH>() ,
               20usize , concat ! (
               "Size of: " , stringify ! ( _MEDIA_FW_VOL_FILEPATH_DEVICE_PATH
               ) ));
    assert_eq! (::core::mem::align_of::<_MEDIA_FW_VOL_FILEPATH_DEVICE_PATH>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                _MEDIA_FW_VOL_FILEPATH_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _MEDIA_FW_VOL_FILEPATH_DEVICE_PATH ) ) .
                Header as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _MEDIA_FW_VOL_FILEPATH_DEVICE_PATH ) , "::" , stringify ! (
                Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _MEDIA_FW_VOL_FILEPATH_DEVICE_PATH ) ) .
                FvFileName as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                _MEDIA_FW_VOL_FILEPATH_DEVICE_PATH ) , "::" , stringify ! (
                FvFileName ) ));
}
impl Clone for _MEDIA_FW_VOL_FILEPATH_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type MEDIA_FW_VOL_FILEPATH_DEVICE_PATH =
    _MEDIA_FW_VOL_FILEPATH_DEVICE_PATH;
#[repr(C)]

pub struct _MEDIA_FW_VOL_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub FvName: EFI_GUID,
}
#[test]
fn bindgen_test_layout__MEDIA_FW_VOL_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_MEDIA_FW_VOL_DEVICE_PATH>() , 20usize ,
               concat ! (
               "Size of: " , stringify ! ( _MEDIA_FW_VOL_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_MEDIA_FW_VOL_DEVICE_PATH>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( _MEDIA_FW_VOL_DEVICE_PATH )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _MEDIA_FW_VOL_DEVICE_PATH ) ) . Header as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _MEDIA_FW_VOL_DEVICE_PATH ) , "::" , stringify ! ( Header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _MEDIA_FW_VOL_DEVICE_PATH ) ) . FvName as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                _MEDIA_FW_VOL_DEVICE_PATH ) , "::" , stringify ! ( FvName )
                ));
}
impl Clone for _MEDIA_FW_VOL_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type MEDIA_FW_VOL_DEVICE_PATH = _MEDIA_FW_VOL_DEVICE_PATH;
#[repr(C)]

pub struct _MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub Reserved: UINT32,
    pub StartingOffset: UINT64,
    pub EndingOffset: UINT64,
}
#[test]
fn bindgen_test_layout__MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               _MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH ) ));
    assert_eq! (::core::mem::align_of::<_MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH ) )
                . Header as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH ) , "::" , stringify
                ! ( Header ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH ) )
                . Reserved as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                _MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH ) , "::" , stringify
                ! ( Reserved ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH ) )
                . StartingOffset as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH ) , "::" , stringify
                ! ( StartingOffset ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH ) )
                . EndingOffset as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH ) , "::" , stringify
                ! ( EndingOffset ) ));
}
impl Clone for _MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH =
    _MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH;
#[repr(C)]

pub struct _BBS_BBS_DEVICE_PATH {
    pub Header: EFI_DEVICE_PATH,
    pub DeviceType: UINT16,
    pub StatusFlag: UINT16,
    pub String: [CHAR8; 1usize],
}
#[test]
fn bindgen_test_layout__BBS_BBS_DEVICE_PATH() {
    assert_eq!(::core::mem::size_of::<_BBS_BBS_DEVICE_PATH>() , 10usize ,
               concat ! ( "Size of: " , stringify ! ( _BBS_BBS_DEVICE_PATH )
               ));
    assert_eq! (::core::mem::align_of::<_BBS_BBS_DEVICE_PATH>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( _BBS_BBS_DEVICE_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _BBS_BBS_DEVICE_PATH ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _BBS_BBS_DEVICE_PATH )
                , "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _BBS_BBS_DEVICE_PATH ) ) . DeviceType as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _BBS_BBS_DEVICE_PATH )
                , "::" , stringify ! ( DeviceType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _BBS_BBS_DEVICE_PATH ) ) . StatusFlag as
                * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _BBS_BBS_DEVICE_PATH )
                , "::" , stringify ! ( StatusFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _BBS_BBS_DEVICE_PATH ) ) . String as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _BBS_BBS_DEVICE_PATH )
                , "::" , stringify ! ( String ) ));
}
impl Clone for _BBS_BBS_DEVICE_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type BBS_BBS_DEVICE_PATH = _BBS_BBS_DEVICE_PATH;
#[repr(C)]

pub union EFI_DEV_PATH {
    pub DevPath: EFI_DEVICE_PATH,
    pub Pci: PCI_DEVICE_PATH,
    pub PcCard: PCCARD_DEVICE_PATH,
    pub MemMap: MEMMAP_DEVICE_PATH,
    pub Vendor: VENDOR_DEVICE_PATH,
    pub UnknownVendor: UNKNOWN_DEVICE_VENDOR_DEVICE_PATH,
    pub Controller: CONTROLLER_DEVICE_PATH,
    pub Acpi: ACPI_HID_DEVICE_PATH,
    pub Atapi: ATAPI_DEVICE_PATH,
    pub Scsi: SCSI_DEVICE_PATH,
    pub FibreChannel: FIBRECHANNEL_DEVICE_PATH,
    pub F1394: F1394_DEVICE_PATH,
    pub Usb: USB_DEVICE_PATH,
    pub UsbClass: USB_CLASS_DEVICE_PATH,
    pub I2O: I2O_DEVICE_PATH,
    pub MacAddr: MAC_ADDR_DEVICE_PATH,
    pub Ipv4: IPv4_DEVICE_PATH,
    pub Ipv6: IPv6_DEVICE_PATH,
    pub InfiniBand: INFINIBAND_DEVICE_PATH,
    pub Uart: UART_DEVICE_PATH,
    pub HardDrive: HARDDRIVE_DEVICE_PATH,
    pub CD: CDROM_DEVICE_PATH,
    pub FilePath: FILEPATH_DEVICE_PATH,
    pub MediaProtocol: MEDIA_PROTOCOL_DEVICE_PATH,
    pub Bbs: BBS_BBS_DEVICE_PATH,
}
#[test]
fn bindgen_test_layout_EFI_DEV_PATH() {
    assert_eq!(::core::mem::size_of::<EFI_DEV_PATH>() , 64usize , concat ! (
               "Size of: " , stringify ! ( EFI_DEV_PATH ) ));
    assert_eq! (::core::mem::align_of::<EFI_DEV_PATH>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( EFI_DEV_PATH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . DevPath as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( DevPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . Pci as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( Pci ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . PcCard as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( PcCard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . MemMap as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( MemMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . Vendor as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( Vendor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . UnknownVendor as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( UnknownVendor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . Controller as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( Controller ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . Acpi as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( Acpi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . Atapi as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( Atapi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . Scsi as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( Scsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . FibreChannel as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( FibreChannel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . F1394 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( F1394 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . Usb as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( Usb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . UsbClass as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( UsbClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . I2O as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( I2O ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . MacAddr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( MacAddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . Ipv4 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( Ipv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . Ipv6 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( Ipv6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . InfiniBand as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( InfiniBand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . Uart as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( Uart ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . HardDrive as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( HardDrive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . CD as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( CD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . FilePath as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( FilePath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . MediaProtocol as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( MediaProtocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH ) ) . Bbs as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH ) , "::" ,
                stringify ! ( Bbs ) ));
}
impl Clone for EFI_DEV_PATH {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub union EFI_DEV_PATH_PTR {
    pub DevPath: *mut EFI_DEVICE_PATH,
    pub Pci: *mut PCI_DEVICE_PATH,
    pub PcCard: *mut PCCARD_DEVICE_PATH,
    pub MemMap: *mut MEMMAP_DEVICE_PATH,
    pub Vendor: *mut VENDOR_DEVICE_PATH,
    pub UnknownVendor: *mut UNKNOWN_DEVICE_VENDOR_DEVICE_PATH,
    pub Controller: *mut CONTROLLER_DEVICE_PATH,
    pub Acpi: *mut ACPI_HID_DEVICE_PATH,
    pub Atapi: *mut ATAPI_DEVICE_PATH,
    pub Scsi: *mut SCSI_DEVICE_PATH,
    pub FibreChannel: *mut FIBRECHANNEL_DEVICE_PATH,
    pub F1394: *mut F1394_DEVICE_PATH,
    pub Usb: *mut USB_DEVICE_PATH,
    pub UsbClass: *mut USB_CLASS_DEVICE_PATH,
    pub I2O: *mut I2O_DEVICE_PATH,
    pub MacAddr: *mut MAC_ADDR_DEVICE_PATH,
    pub Ipv4: *mut IPv4_DEVICE_PATH,
    pub Ipv6: *mut IPv6_DEVICE_PATH,
    pub InfiniBand: *mut INFINIBAND_DEVICE_PATH,
    pub Uart: *mut UART_DEVICE_PATH,
    pub HardDrive: *mut HARDDRIVE_DEVICE_PATH,
    pub FilePath: *mut FILEPATH_DEVICE_PATH,
    pub MediaProtocol: *mut MEDIA_PROTOCOL_DEVICE_PATH,
    pub CD: *mut CDROM_DEVICE_PATH,
    pub Bbs: *mut BBS_BBS_DEVICE_PATH,
}
#[test]
fn bindgen_test_layout_EFI_DEV_PATH_PTR() {
    assert_eq!(::core::mem::size_of::<EFI_DEV_PATH_PTR>() , 8usize , concat !
               ( "Size of: " , stringify ! ( EFI_DEV_PATH_PTR ) ));
    assert_eq! (::core::mem::align_of::<EFI_DEV_PATH_PTR>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( EFI_DEV_PATH_PTR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . DevPath as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( DevPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . Pci as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( Pci ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . PcCard as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( PcCard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . MemMap as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( MemMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . Vendor as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( Vendor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . UnknownVendor as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( UnknownVendor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . Controller as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( Controller ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . Acpi as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( Acpi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . Atapi as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( Atapi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . Scsi as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( Scsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . FibreChannel as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( FibreChannel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . F1394 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( F1394 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . Usb as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( Usb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . UsbClass as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( UsbClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . I2O as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( I2O ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . MacAddr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( MacAddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . Ipv4 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( Ipv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . Ipv6 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( Ipv6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . InfiniBand as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( InfiniBand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . Uart as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( Uart ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . HardDrive as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( HardDrive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . FilePath as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( FilePath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . MediaProtocol as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( MediaProtocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . CD as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( CD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_DEV_PATH_PTR ) ) . Bbs as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_DEV_PATH_PTR ) ,
                "::" , stringify ! ( Bbs ) ));
}
impl Clone for EFI_DEV_PATH_PTR {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct _EFI_PCI_IO {
    pub PollMem: EFI_PCI_IO_PROTOCOL_POLL_IO_MEM,
    pub PollIo: EFI_PCI_IO_PROTOCOL_POLL_IO_MEM,
    pub Mem: EFI_PCI_IO_PROTOCOL_ACCESS,
    pub Io: EFI_PCI_IO_PROTOCOL_ACCESS,
    pub Pci: EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS,
    pub CopyMem: EFI_PCI_IO_PROTOCOL_COPY_MEM,
    pub Map: EFI_PCI_IO_PROTOCOL_MAP,
    pub Unmap: EFI_PCI_IO_PROTOCOL_UNMAP,
    pub AllocateBuffer: EFI_PCI_IO_PROTOCOL_ALLOCATE_BUFFER,
    pub FreeBuffer: EFI_PCI_IO_PROTOCOL_FREE_BUFFER,
    pub Flush: EFI_PCI_IO_PROTOCOL_FLUSH,
    pub GetLocation: EFI_PCI_IO_PROTOCOL_GET_LOCATION,
    pub Attributes: EFI_PCI_IO_PROTOCOL_ATTRIBUTES,
    pub GetBarAttributes: EFI_PCI_IO_PROTOCOL_GET_BAR_ATTRIBUTES,
    pub SetBarAttributes: EFI_PCI_IO_PROTOCOL_SET_BAR_ATTRIBUTES,
    pub RomSize: UINT64,
    pub RomImage: *mut ::ctypes::c_void,
}
#[test]
fn bindgen_test_layout__EFI_PCI_IO() {
    assert_eq!(::core::mem::size_of::<_EFI_PCI_IO>() , 160usize , concat ! (
               "Size of: " , stringify ! ( _EFI_PCI_IO ) ));
    assert_eq! (::core::mem::align_of::<_EFI_PCI_IO>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _EFI_PCI_IO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . PollMem as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( PollMem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . PollIo as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( PollIo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . Mem as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( Mem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . Io as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( Io ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . Pci as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( Pci ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . CopyMem as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( CopyMem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . Map as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( Map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . Unmap as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( Unmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . AllocateBuffer as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( AllocateBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . FreeBuffer as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( FreeBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . Flush as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( Flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . GetLocation as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( GetLocation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . Attributes as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( Attributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . GetBarAttributes as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( GetBarAttributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . SetBarAttributes as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( SetBarAttributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . RomSize as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( RomSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PCI_IO ) ) . RomImage as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PCI_IO ) , "::" ,
                stringify ! ( RomImage ) ));
}
impl Clone for _EFI_PCI_IO {
    fn clone(&self) -> Self { unimplemented!() }
}
pub const EFI_PCI_IO_PROTOCOL_WIDTH_EfiPciIoWidthUint8:
          EFI_PCI_IO_PROTOCOL_WIDTH =
    0;
pub const EFI_PCI_IO_PROTOCOL_WIDTH_EfiPciIoWidthUint16:
          EFI_PCI_IO_PROTOCOL_WIDTH =
    1;
pub const EFI_PCI_IO_PROTOCOL_WIDTH_EfiPciIoWidthUint32:
          EFI_PCI_IO_PROTOCOL_WIDTH =
    2;
pub const EFI_PCI_IO_PROTOCOL_WIDTH_EfiPciIoWidthUint64:
          EFI_PCI_IO_PROTOCOL_WIDTH =
    3;
pub const EFI_PCI_IO_PROTOCOL_WIDTH_EfiPciIoWidthFifoUint8:
          EFI_PCI_IO_PROTOCOL_WIDTH =
    4;
pub const EFI_PCI_IO_PROTOCOL_WIDTH_EfiPciIoWidthFifoUint16:
          EFI_PCI_IO_PROTOCOL_WIDTH =
    5;
pub const EFI_PCI_IO_PROTOCOL_WIDTH_EfiPciIoWidthFifoUint32:
          EFI_PCI_IO_PROTOCOL_WIDTH =
    6;
pub const EFI_PCI_IO_PROTOCOL_WIDTH_EfiPciIoWidthFifoUint64:
          EFI_PCI_IO_PROTOCOL_WIDTH =
    7;
pub const EFI_PCI_IO_PROTOCOL_WIDTH_EfiPciIoWidthFillUint8:
          EFI_PCI_IO_PROTOCOL_WIDTH =
    8;
pub const EFI_PCI_IO_PROTOCOL_WIDTH_EfiPciIoWidthFillUint16:
          EFI_PCI_IO_PROTOCOL_WIDTH =
    9;
pub const EFI_PCI_IO_PROTOCOL_WIDTH_EfiPciIoWidthFillUint32:
          EFI_PCI_IO_PROTOCOL_WIDTH =
    10;
pub const EFI_PCI_IO_PROTOCOL_WIDTH_EfiPciIoWidthFillUint64:
          EFI_PCI_IO_PROTOCOL_WIDTH =
    11;
pub const EFI_PCI_IO_PROTOCOL_WIDTH_EfiPciIoWidthMaximum:
          EFI_PCI_IO_PROTOCOL_WIDTH =
    12;
pub type EFI_PCI_IO_PROTOCOL_WIDTH = ::ctypes::c_uint;
pub type EFI_PCI_IO_PROTOCOL_POLL_IO_MEM =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PCI_IO,
                                                Width:
                                                    EFI_PCI_IO_PROTOCOL_WIDTH,
                                                BarIndex: UINT8,
                                                Offset: UINT64, Mask: UINT64,
                                                Value: UINT64, Delay: UINT64,
                                                Result: *mut UINT64)
                               -> EFI_STATUS>;
pub type EFI_PCI_IO_PROTOCOL_IO_MEM =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PCI_IO,
                                                Width:
                                                    EFI_PCI_IO_PROTOCOL_WIDTH,
                                                BarIndex: UINT8,
                                                Offset: UINT64, Count: UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_PCI_IO_PROTOCOL_ACCESS {
    pub Read: EFI_PCI_IO_PROTOCOL_IO_MEM,
    pub Write: EFI_PCI_IO_PROTOCOL_IO_MEM,
}
#[test]
fn bindgen_test_layout_EFI_PCI_IO_PROTOCOL_ACCESS() {
    assert_eq!(::core::mem::size_of::<EFI_PCI_IO_PROTOCOL_ACCESS>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( EFI_PCI_IO_PROTOCOL_ACCESS ) ));
    assert_eq! (::core::mem::align_of::<EFI_PCI_IO_PROTOCOL_ACCESS>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( EFI_PCI_IO_PROTOCOL_ACCESS )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PCI_IO_PROTOCOL_ACCESS ) ) . Read as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PCI_IO_PROTOCOL_ACCESS ) , "::" , stringify ! ( Read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PCI_IO_PROTOCOL_ACCESS ) ) . Write as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PCI_IO_PROTOCOL_ACCESS ) , "::" , stringify ! ( Write )
                ));
}
impl Clone for EFI_PCI_IO_PROTOCOL_ACCESS {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_PCI_IO_PROTOCOL_CONFIG =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PCI_IO,
                                                Width:
                                                    EFI_PCI_IO_PROTOCOL_WIDTH,
                                                Offset: UINT32, Count: UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS {
    pub Read: EFI_PCI_IO_PROTOCOL_CONFIG,
    pub Write: EFI_PCI_IO_PROTOCOL_CONFIG,
}
#[test]
fn bindgen_test_layout_EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS() {
    assert_eq!(::core::mem::size_of::<EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS )
               ));
    assert_eq! (::core::mem::align_of::<EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS ) ) .
                Read as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS ) , "::" , stringify ! (
                Read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS ) ) .
                Write as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS ) , "::" , stringify ! (
                Write ) ));
}
impl Clone for EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_PCI_IO_PROTOCOL_COPY_MEM =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PCI_IO,
                                                Width:
                                                    EFI_PCI_IO_PROTOCOL_WIDTH,
                                                DestBarIndex: UINT8,
                                                DestOffset: UINT64,
                                                SrcBarIndex: UINT8,
                                                SrcOffset: UINT64,
                                                Count: UINTN) -> EFI_STATUS>;
pub const EFI_PCI_IO_PROTOCOL_OPERATION_EfiPciIoOperationBusMasterRead:
          EFI_PCI_IO_PROTOCOL_OPERATION =
    0;
pub const EFI_PCI_IO_PROTOCOL_OPERATION_EfiPciIoOperationBusMasterWrite:
          EFI_PCI_IO_PROTOCOL_OPERATION =
    1;
pub const EFI_PCI_IO_PROTOCOL_OPERATION_EfiPciIoOperationBusMasterCommonBuffer:
          EFI_PCI_IO_PROTOCOL_OPERATION =
    2;
pub const EFI_PCI_IO_PROTOCOL_OPERATION_EfiPciIoOperationMaximum:
          EFI_PCI_IO_PROTOCOL_OPERATION =
    3;
pub type EFI_PCI_IO_PROTOCOL_OPERATION = ::ctypes::c_uint;
pub type EFI_PCI_IO_PROTOCOL_MAP =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PCI_IO,
                                                Operation:
                                                    EFI_PCI_IO_PROTOCOL_OPERATION,
                                                HostAddress:
                                                    *mut ::ctypes::c_void,
                                                NumberOfBytes: *mut UINTN,
                                                DeviceAddress:
                                                    *mut EFI_PHYSICAL_ADDRESS,
                                                Mapping:
                                                    *mut *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_PCI_IO_PROTOCOL_UNMAP =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PCI_IO,
                                                Mapping:
                                                    *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_PCI_IO_PROTOCOL_ALLOCATE_BUFFER =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PCI_IO,
                                                Type: EFI_ALLOCATE_TYPE,
                                                MemoryType: EFI_MEMORY_TYPE,
                                                Pages: UINTN,
                                                HostAddress:
                                                    *mut *mut ::ctypes::c_void,
                                                Attributes: UINT64)
                               -> EFI_STATUS>;
pub type EFI_PCI_IO_PROTOCOL_FREE_BUFFER =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PCI_IO,
                                                Pages: UINTN,
                                                HostAddress:
                                                    *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_PCI_IO_PROTOCOL_FLUSH =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PCI_IO)
                               -> EFI_STATUS>;
pub type EFI_PCI_IO_PROTOCOL_GET_LOCATION =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PCI_IO,
                                                SegmentNumber: *mut UINTN,
                                                BusNumber: *mut UINTN,
                                                DeviceNumber: *mut UINTN,
                                                FunctionNumber: *mut UINTN)
                               -> EFI_STATUS>;
pub const EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION_EfiPciIoAttributeOperationGet:
          EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION =
    0;
pub const EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION_EfiPciIoAttributeOperationSet:
          EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION =
    1;
pub const EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION_EfiPciIoAttributeOperationEnable:
          EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION =
    2;
pub const EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION_EfiPciIoAttributeOperationDisable:
          EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION =
    3;
pub const EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION_EfiPciIoAttributeOperationSupported:
          EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION =
    4;
pub const EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION_EfiPciIoAttributeOperationMaximum:
          EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION =
    5;
pub type EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION = ::ctypes::c_uint;
pub type EFI_PCI_IO_PROTOCOL_ATTRIBUTES =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PCI_IO,
                                                Operation:
                                                    EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION,
                                                Attributes: UINT64,
                                                Result: *mut UINT64)
                               -> EFI_STATUS>;
pub type EFI_PCI_IO_PROTOCOL_GET_BAR_ATTRIBUTES =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PCI_IO,
                                                BarIndex: UINT8,
                                                Supports: *mut UINT64,
                                                Resources:
                                                    *mut *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_PCI_IO_PROTOCOL_SET_BAR_ATTRIBUTES =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PCI_IO,
                                                Attributes: UINT64,
                                                BarIndex: UINT8,
                                                Offset: *mut UINT64,
                                                Length: *mut UINT64)
                               -> EFI_STATUS>;
pub type EFI_PCI_IO = _EFI_PCI_IO;
#[repr(C)]

pub struct _EFI_BLOCK_IO {
    pub Revision: UINT64,
    pub Media: *mut EFI_BLOCK_IO_MEDIA,
    pub Reset: EFI_BLOCK_RESET,
    pub ReadBlocks: EFI_BLOCK_READ,
    pub WriteBlocks: EFI_BLOCK_WRITE,
    pub FlushBlocks: EFI_BLOCK_FLUSH,
}
#[test]
fn bindgen_test_layout__EFI_BLOCK_IO() {
    assert_eq!(::core::mem::size_of::<_EFI_BLOCK_IO>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _EFI_BLOCK_IO ) ));
    assert_eq! (::core::mem::align_of::<_EFI_BLOCK_IO>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _EFI_BLOCK_IO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BLOCK_IO ) ) . Revision as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BLOCK_IO ) , "::"
                , stringify ! ( Revision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BLOCK_IO ) ) . Media as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BLOCK_IO ) , "::"
                , stringify ! ( Media ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BLOCK_IO ) ) . Reset as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BLOCK_IO ) , "::"
                , stringify ! ( Reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BLOCK_IO ) ) . ReadBlocks as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BLOCK_IO ) , "::"
                , stringify ! ( ReadBlocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BLOCK_IO ) ) . WriteBlocks as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BLOCK_IO ) , "::"
                , stringify ! ( WriteBlocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BLOCK_IO ) ) . FlushBlocks as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BLOCK_IO ) , "::"
                , stringify ! ( FlushBlocks ) ));
}
impl Clone for _EFI_BLOCK_IO {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_BLOCK_RESET =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_BLOCK_IO,
                                                ExtendedVerification: BOOLEAN)
                               -> EFI_STATUS>;
pub type EFI_BLOCK_READ =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_BLOCK_IO,
                                                MediaId: UINT32, LBA: EFI_LBA,
                                                BufferSize: UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_BLOCK_WRITE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_BLOCK_IO,
                                                MediaId: UINT32, LBA: EFI_LBA,
                                                BufferSize: UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_BLOCK_FLUSH =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_BLOCK_IO)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_BLOCK_IO_MEDIA {
    pub MediaId: UINT32,
    pub RemovableMedia: BOOLEAN,
    pub MediaPresent: BOOLEAN,
    pub LogicalPartition: BOOLEAN,
    pub ReadOnly: BOOLEAN,
    pub WriteCaching: BOOLEAN,
    pub BlockSize: UINT32,
    pub IoAlign: UINT32,
    pub LastBlock: EFI_LBA,
    pub LowestAlignedLba: EFI_LBA,
    pub LogicalBlocksPerPhysicalBlock: UINT32,
    pub OptimalTransferLengthGranularity: UINT32,
}
#[test]
fn bindgen_test_layout_EFI_BLOCK_IO_MEDIA() {
    assert_eq!(::core::mem::size_of::<EFI_BLOCK_IO_MEDIA>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( EFI_BLOCK_IO_MEDIA ) ));
    assert_eq! (::core::mem::align_of::<EFI_BLOCK_IO_MEDIA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_BLOCK_IO_MEDIA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_BLOCK_IO_MEDIA ) ) . MediaId as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_BLOCK_IO_MEDIA ) ,
                "::" , stringify ! ( MediaId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_BLOCK_IO_MEDIA ) ) . RemovableMedia
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_BLOCK_IO_MEDIA ) ,
                "::" , stringify ! ( RemovableMedia ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_BLOCK_IO_MEDIA ) ) . MediaPresent as
                * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_BLOCK_IO_MEDIA ) ,
                "::" , stringify ! ( MediaPresent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_BLOCK_IO_MEDIA ) ) . LogicalPartition
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_BLOCK_IO_MEDIA ) ,
                "::" , stringify ! ( LogicalPartition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_BLOCK_IO_MEDIA ) ) . ReadOnly as *
                const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_BLOCK_IO_MEDIA ) ,
                "::" , stringify ! ( ReadOnly ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_BLOCK_IO_MEDIA ) ) . WriteCaching as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_BLOCK_IO_MEDIA ) ,
                "::" , stringify ! ( WriteCaching ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_BLOCK_IO_MEDIA ) ) . BlockSize as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_BLOCK_IO_MEDIA ) ,
                "::" , stringify ! ( BlockSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_BLOCK_IO_MEDIA ) ) . IoAlign as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_BLOCK_IO_MEDIA ) ,
                "::" , stringify ! ( IoAlign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_BLOCK_IO_MEDIA ) ) . LastBlock as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_BLOCK_IO_MEDIA ) ,
                "::" , stringify ! ( LastBlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_BLOCK_IO_MEDIA ) ) . LowestAlignedLba
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_BLOCK_IO_MEDIA ) ,
                "::" , stringify ! ( LowestAlignedLba ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_BLOCK_IO_MEDIA ) ) .
                LogicalBlocksPerPhysicalBlock as * const _ as usize } ,
                40usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_BLOCK_IO_MEDIA ) ,
                "::" , stringify ! ( LogicalBlocksPerPhysicalBlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_BLOCK_IO_MEDIA ) ) .
                OptimalTransferLengthGranularity as * const _ as usize } ,
                44usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_BLOCK_IO_MEDIA ) ,
                "::" , stringify ! ( OptimalTransferLengthGranularity ) ));
}
impl Clone for EFI_BLOCK_IO_MEDIA {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_BLOCK_IO = _EFI_BLOCK_IO;
#[repr(C)]

pub struct _EFI_DISK_IO {
    pub Revision: UINT64,
    pub ReadDisk: EFI_DISK_READ,
    pub WriteDisk: EFI_DISK_WRITE,
}
#[test]
fn bindgen_test_layout__EFI_DISK_IO() {
    assert_eq!(::core::mem::size_of::<_EFI_DISK_IO>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _EFI_DISK_IO ) ));
    assert_eq! (::core::mem::align_of::<_EFI_DISK_IO>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _EFI_DISK_IO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DISK_IO ) ) . Revision as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_DISK_IO ) , "::" ,
                stringify ! ( Revision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DISK_IO ) ) . ReadDisk as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_DISK_IO ) , "::" ,
                stringify ! ( ReadDisk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DISK_IO ) ) . WriteDisk as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_DISK_IO ) , "::" ,
                stringify ! ( WriteDisk ) ));
}
impl Clone for _EFI_DISK_IO {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_DISK_READ =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_DISK_IO,
                                                MediaId: UINT32,
                                                Offset: UINT64,
                                                BufferSize: UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_DISK_WRITE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_DISK_IO,
                                                MediaId: UINT32,
                                                Offset: UINT64,
                                                BufferSize: UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_DISK_IO = _EFI_DISK_IO;
#[repr(C)]

pub struct _EFI_FILE_IO_INTERFACE {
    pub Revision: UINT64,
    pub OpenVolume: EFI_VOLUME_OPEN,
}
#[test]
fn bindgen_test_layout__EFI_FILE_IO_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_EFI_FILE_IO_INTERFACE>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _EFI_FILE_IO_INTERFACE )
               ));
    assert_eq! (::core::mem::align_of::<_EFI_FILE_IO_INTERFACE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _EFI_FILE_IO_INTERFACE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_IO_INTERFACE ) ) . Revision as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_IO_INTERFACE
                ) , "::" , stringify ! ( Revision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_IO_INTERFACE ) ) . OpenVolume
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_IO_INTERFACE
                ) , "::" , stringify ! ( OpenVolume ) ));
}
impl Clone for _EFI_FILE_IO_INTERFACE {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct _EFI_FILE_HANDLE {
    pub Revision: UINT64,
    pub Open: EFI_FILE_OPEN,
    pub Close: EFI_FILE_CLOSE,
    pub Delete: EFI_FILE_DELETE,
    pub Read: EFI_FILE_READ,
    pub Write: EFI_FILE_WRITE,
    pub GetPosition: EFI_FILE_GET_POSITION,
    pub SetPosition: EFI_FILE_SET_POSITION,
    pub GetInfo: EFI_FILE_GET_INFO,
    pub SetInfo: EFI_FILE_SET_INFO,
    pub Flush: EFI_FILE_FLUSH,
}
#[test]
fn bindgen_test_layout__EFI_FILE_HANDLE() {
    assert_eq!(::core::mem::size_of::<_EFI_FILE_HANDLE>() , 88usize , concat !
               ( "Size of: " , stringify ! ( _EFI_FILE_HANDLE ) ));
    assert_eq! (::core::mem::align_of::<_EFI_FILE_HANDLE>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _EFI_FILE_HANDLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HANDLE ) ) . Revision as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HANDLE ) ,
                "::" , stringify ! ( Revision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HANDLE ) ) . Open as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HANDLE ) ,
                "::" , stringify ! ( Open ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HANDLE ) ) . Close as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HANDLE ) ,
                "::" , stringify ! ( Close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HANDLE ) ) . Delete as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HANDLE ) ,
                "::" , stringify ! ( Delete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HANDLE ) ) . Read as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HANDLE ) ,
                "::" , stringify ! ( Read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HANDLE ) ) . Write as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HANDLE ) ,
                "::" , stringify ! ( Write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HANDLE ) ) . GetPosition as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HANDLE ) ,
                "::" , stringify ! ( GetPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HANDLE ) ) . SetPosition as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HANDLE ) ,
                "::" , stringify ! ( SetPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HANDLE ) ) . GetInfo as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HANDLE ) ,
                "::" , stringify ! ( GetInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HANDLE ) ) . SetInfo as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HANDLE ) ,
                "::" , stringify ! ( SetInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HANDLE ) ) . Flush as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HANDLE ) ,
                "::" , stringify ! ( Flush ) ));
}
impl Clone for _EFI_FILE_HANDLE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_VOLUME_OPEN =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_FILE_IO_INTERFACE,
                                                Root:
                                                    *mut *mut _EFI_FILE_HANDLE)
                               -> EFI_STATUS>;
pub type EFI_FILE_IO_INTERFACE = _EFI_FILE_IO_INTERFACE;
pub type EFI_FILE_OPEN =
    ::core::option::Option<unsafe extern "win64" fn(File: *mut _EFI_FILE_HANDLE,
                                                NewHandle:
                                                    *mut *mut _EFI_FILE_HANDLE,
                                                FileName: *mut CHAR16,
                                                OpenMode: UINT64,
                                                Attributes: UINT64)
                               -> EFI_STATUS>;
pub type EFI_FILE_CLOSE =
    ::core::option::Option<unsafe extern "win64" fn(File: *mut _EFI_FILE_HANDLE)
                               -> EFI_STATUS>;
pub type EFI_FILE_DELETE =
    ::core::option::Option<unsafe extern "win64" fn(File: *mut _EFI_FILE_HANDLE)
                               -> EFI_STATUS>;
pub type EFI_FILE_READ =
    ::core::option::Option<unsafe extern "win64" fn(File: *mut _EFI_FILE_HANDLE,
                                                BufferSize: *mut UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_FILE_WRITE =
    ::core::option::Option<unsafe extern "win64" fn(File: *mut _EFI_FILE_HANDLE,
                                                BufferSize: *mut UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_FILE_SET_POSITION =
    ::core::option::Option<unsafe extern "win64" fn(File: *mut _EFI_FILE_HANDLE,
                                                Position: UINT64)
                               -> EFI_STATUS>;
pub type EFI_FILE_GET_POSITION =
    ::core::option::Option<unsafe extern "win64" fn(File: *mut _EFI_FILE_HANDLE,
                                                Position: *mut UINT64)
                               -> EFI_STATUS>;
pub type EFI_FILE_GET_INFO =
    ::core::option::Option<unsafe extern "win64" fn(File: *mut _EFI_FILE_HANDLE,
                                                InformationType:
                                                    *mut EFI_GUID,
                                                BufferSize: *mut UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_FILE_SET_INFO =
    ::core::option::Option<unsafe extern "win64" fn(File: *mut _EFI_FILE_HANDLE,
                                                InformationType:
                                                    *mut EFI_GUID,
                                                BufferSize: UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_FILE_FLUSH =
    ::core::option::Option<unsafe extern "win64" fn(File: *mut _EFI_FILE_HANDLE)
                               -> EFI_STATUS>;
pub type EFI_FILE = _EFI_FILE_HANDLE;
pub type EFI_FILE_HANDLE = *mut _EFI_FILE_HANDLE;
#[repr(C)]

pub struct EFI_FILE_INFO {
    pub Size: UINT64,
    pub FileSize: UINT64,
    pub PhysicalSize: UINT64,
    pub CreateTime: EFI_TIME,
    pub LastAccessTime: EFI_TIME,
    pub ModificationTime: EFI_TIME,
    pub Attribute: UINT64,
    pub FileName: [CHAR16; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_FILE_INFO() {
    assert_eq!(::core::mem::size_of::<EFI_FILE_INFO>() , 88usize , concat ! (
               "Size of: " , stringify ! ( EFI_FILE_INFO ) ));
    assert_eq! (::core::mem::align_of::<EFI_FILE_INFO>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( EFI_FILE_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_INFO ) ) . Size as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_FILE_INFO ) , "::"
                , stringify ! ( Size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_INFO ) ) . FileSize as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_FILE_INFO ) , "::"
                , stringify ! ( FileSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_INFO ) ) . PhysicalSize as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_FILE_INFO ) , "::"
                , stringify ! ( PhysicalSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_INFO ) ) . CreateTime as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_FILE_INFO ) , "::"
                , stringify ! ( CreateTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_INFO ) ) . LastAccessTime as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_FILE_INFO ) , "::"
                , stringify ! ( LastAccessTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_INFO ) ) . ModificationTime as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_FILE_INFO ) , "::"
                , stringify ! ( ModificationTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_INFO ) ) . Attribute as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_FILE_INFO ) , "::"
                , stringify ! ( Attribute ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_INFO ) ) . FileName as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_FILE_INFO ) , "::"
                , stringify ! ( FileName ) ));
}
impl Clone for EFI_FILE_INFO {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_FILE_SYSTEM_INFO {
    pub Size: UINT64,
    pub ReadOnly: BOOLEAN,
    pub VolumeSize: UINT64,
    pub FreeSpace: UINT64,
    pub BlockSize: UINT32,
    pub VolumeLabel: [CHAR16; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_FILE_SYSTEM_INFO() {
    assert_eq!(::core::mem::size_of::<EFI_FILE_SYSTEM_INFO>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_FILE_SYSTEM_INFO )
               ));
    assert_eq! (::core::mem::align_of::<EFI_FILE_SYSTEM_INFO>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_FILE_SYSTEM_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_SYSTEM_INFO ) ) . Size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_FILE_SYSTEM_INFO )
                , "::" , stringify ! ( Size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_SYSTEM_INFO ) ) . ReadOnly as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_FILE_SYSTEM_INFO )
                , "::" , stringify ! ( ReadOnly ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_SYSTEM_INFO ) ) . VolumeSize as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_FILE_SYSTEM_INFO )
                , "::" , stringify ! ( VolumeSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_SYSTEM_INFO ) ) . FreeSpace as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_FILE_SYSTEM_INFO )
                , "::" , stringify ! ( FreeSpace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_SYSTEM_INFO ) ) . BlockSize as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_FILE_SYSTEM_INFO )
                , "::" , stringify ! ( BlockSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_SYSTEM_INFO ) ) . VolumeLabel as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_FILE_SYSTEM_INFO )
                , "::" , stringify ! ( VolumeLabel ) ));
}
impl Clone for EFI_FILE_SYSTEM_INFO {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_FILE_SYSTEM_VOLUME_LABEL_INFO {
    pub VolumeLabel: [CHAR16; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_FILE_SYSTEM_VOLUME_LABEL_INFO() {
    assert_eq!(::core::mem::size_of::<EFI_FILE_SYSTEM_VOLUME_LABEL_INFO>() ,
               2usize , concat ! (
               "Size of: " , stringify ! ( EFI_FILE_SYSTEM_VOLUME_LABEL_INFO )
               ));
    assert_eq! (::core::mem::align_of::<EFI_FILE_SYSTEM_VOLUME_LABEL_INFO>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_FILE_SYSTEM_VOLUME_LABEL_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_FILE_SYSTEM_VOLUME_LABEL_INFO ) ) .
                VolumeLabel as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_FILE_SYSTEM_VOLUME_LABEL_INFO ) , "::" , stringify ! (
                VolumeLabel ) ));
}
impl Clone for EFI_FILE_SYSTEM_VOLUME_LABEL_INFO {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct _EFI_LOAD_FILE_INTERFACE {
    pub LoadFile: EFI_LOAD_FILE,
}
#[test]
fn bindgen_test_layout__EFI_LOAD_FILE_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_EFI_LOAD_FILE_INTERFACE>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( _EFI_LOAD_FILE_INTERFACE ) ));
    assert_eq! (::core::mem::align_of::<_EFI_LOAD_FILE_INTERFACE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _EFI_LOAD_FILE_INTERFACE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_LOAD_FILE_INTERFACE ) ) . LoadFile
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_LOAD_FILE_INTERFACE ) , "::" , stringify ! ( LoadFile )
                ));
}
impl Clone for _EFI_LOAD_FILE_INTERFACE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_LOAD_FILE =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_LOAD_FILE_INTERFACE,
                                                FilePath:
                                                    *mut EFI_DEVICE_PATH,
                                                BootPolicy: BOOLEAN,
                                                BufferSize: *mut UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_LOAD_FILE_INTERFACE = _EFI_LOAD_FILE_INTERFACE;
#[repr(C)]

pub struct _EFI_DEVICE_IO_INTERFACE {
    pub Mem: EFI_IO_ACCESS,
    pub Io: EFI_IO_ACCESS,
    pub Pci: EFI_IO_ACCESS,
    pub Map: EFI_IO_MAP,
    pub PciDevicePath: EFI_PCI_DEVICE_PATH,
    pub Unmap: EFI_IO_UNMAP,
    pub AllocateBuffer: EFI_IO_ALLOCATE_BUFFER,
    pub Flush: EFI_IO_FLUSH,
    pub FreeBuffer: EFI_IO_FREE_BUFFER,
}
#[test]
fn bindgen_test_layout__EFI_DEVICE_IO_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_EFI_DEVICE_IO_INTERFACE>() , 96usize ,
               concat ! (
               "Size of: " , stringify ! ( _EFI_DEVICE_IO_INTERFACE ) ));
    assert_eq! (::core::mem::align_of::<_EFI_DEVICE_IO_INTERFACE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _EFI_DEVICE_IO_INTERFACE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DEVICE_IO_INTERFACE ) ) . Mem as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_DEVICE_IO_INTERFACE ) , "::" , stringify ! ( Mem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DEVICE_IO_INTERFACE ) ) . Io as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_DEVICE_IO_INTERFACE ) , "::" , stringify ! ( Io ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DEVICE_IO_INTERFACE ) ) . Pci as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_DEVICE_IO_INTERFACE ) , "::" , stringify ! ( Pci ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DEVICE_IO_INTERFACE ) ) . Map as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_DEVICE_IO_INTERFACE ) , "::" , stringify ! ( Map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DEVICE_IO_INTERFACE ) ) .
                PciDevicePath as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_DEVICE_IO_INTERFACE ) , "::" , stringify ! (
                PciDevicePath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DEVICE_IO_INTERFACE ) ) . Unmap as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_DEVICE_IO_INTERFACE ) , "::" , stringify ! ( Unmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DEVICE_IO_INTERFACE ) ) .
                AllocateBuffer as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_DEVICE_IO_INTERFACE ) , "::" , stringify ! (
                AllocateBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DEVICE_IO_INTERFACE ) ) . Flush as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_DEVICE_IO_INTERFACE ) , "::" , stringify ! ( Flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_DEVICE_IO_INTERFACE ) ) . FreeBuffer
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_DEVICE_IO_INTERFACE ) , "::" , stringify ! ( FreeBuffer )
                ));
}
impl Clone for _EFI_DEVICE_IO_INTERFACE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub const EFI_IO_WIDTH_IO_UINT8: EFI_IO_WIDTH = 0;
pub const EFI_IO_WIDTH_IO_UINT16: EFI_IO_WIDTH = 1;
pub const EFI_IO_WIDTH_IO_UINT32: EFI_IO_WIDTH = 2;
pub const EFI_IO_WIDTH_IO_UINT64: EFI_IO_WIDTH = 3;
pub const EFI_IO_WIDTH_MMIO_COPY_UINT8: EFI_IO_WIDTH = 4;
pub const EFI_IO_WIDTH_MMIO_COPY_UINT16: EFI_IO_WIDTH = 5;
pub const EFI_IO_WIDTH_MMIO_COPY_UINT32: EFI_IO_WIDTH = 6;
pub const EFI_IO_WIDTH_MMIO_COPY_UINT64: EFI_IO_WIDTH = 7;
pub type EFI_IO_WIDTH = ::ctypes::c_uint;
pub type EFI_DEVICE_IO =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_DEVICE_IO_INTERFACE,
                                                Width: EFI_IO_WIDTH,
                                                Address: UINT64, Count: UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_IO_ACCESS {
    pub Read: EFI_DEVICE_IO,
    pub Write: EFI_DEVICE_IO,
}
#[test]
fn bindgen_test_layout_EFI_IO_ACCESS() {
    assert_eq!(::core::mem::size_of::<EFI_IO_ACCESS>() , 16usize , concat ! (
               "Size of: " , stringify ! ( EFI_IO_ACCESS ) ));
    assert_eq! (::core::mem::align_of::<EFI_IO_ACCESS>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( EFI_IO_ACCESS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IO_ACCESS ) ) . Read as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IO_ACCESS ) , "::"
                , stringify ! ( Read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IO_ACCESS ) ) . Write as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IO_ACCESS ) , "::"
                , stringify ! ( Write ) ));
}
impl Clone for EFI_IO_ACCESS {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_PCI_DEVICE_PATH =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_DEVICE_IO_INTERFACE,
                                                Address: UINT64,
                                                PciDevicePath:
                                                    *mut *mut EFI_DEVICE_PATH)
                               -> EFI_STATUS>;
pub const EFI_IO_OPERATION_TYPE_EfiBusMasterRead: EFI_IO_OPERATION_TYPE = 0;
pub const EFI_IO_OPERATION_TYPE_EfiBusMasterWrite: EFI_IO_OPERATION_TYPE = 1;
pub const EFI_IO_OPERATION_TYPE_EfiBusMasterCommonBuffer:
          EFI_IO_OPERATION_TYPE =
    2;
pub type EFI_IO_OPERATION_TYPE = ::ctypes::c_uint;
pub type EFI_IO_MAP =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_DEVICE_IO_INTERFACE,
                                                Operation:
                                                    EFI_IO_OPERATION_TYPE,
                                                HostAddress:
                                                    *mut EFI_PHYSICAL_ADDRESS,
                                                NumberOfBytes: *mut UINTN,
                                                DeviceAddress:
                                                    *mut EFI_PHYSICAL_ADDRESS,
                                                Mapping:
                                                    *mut *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_IO_UNMAP =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_DEVICE_IO_INTERFACE,
                                                Mapping:
                                                    *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_IO_ALLOCATE_BUFFER =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_DEVICE_IO_INTERFACE,
                                                Type: EFI_ALLOCATE_TYPE,
                                                MemoryType: EFI_MEMORY_TYPE,
                                                Pages: UINTN,
                                                HostAddress:
                                                    *mut EFI_PHYSICAL_ADDRESS)
                               -> EFI_STATUS>;
pub type EFI_IO_FLUSH =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_DEVICE_IO_INTERFACE)
                               -> EFI_STATUS>;
pub type EFI_IO_FREE_BUFFER =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_DEVICE_IO_INTERFACE,
                                                Pages: UINTN,
                                                HostAddress:
                                                    EFI_PHYSICAL_ADDRESS)
                               -> EFI_STATUS>;
pub type EFI_DEVICE_IO_INTERFACE = _EFI_DEVICE_IO_INTERFACE;
#[repr(C)]

pub struct _EFI_UNICODE_COLLATION_INTERFACE {
    pub StriColl: EFI_UNICODE_STRICOLL,
    pub MetaiMatch: EFI_UNICODE_METAIMATCH,
    pub StrLwr: EFI_UNICODE_STRLWR,
    pub StrUpr: EFI_UNICODE_STRUPR,
    pub FatToStr: EFI_UNICODE_FATTOSTR,
    pub StrToFat: EFI_UNICODE_STRTOFAT,
    pub SupportedLanguages: *mut CHAR8,
}
#[test]
fn bindgen_test_layout__EFI_UNICODE_COLLATION_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_EFI_UNICODE_COLLATION_INTERFACE>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( _EFI_UNICODE_COLLATION_INTERFACE )
               ));
    assert_eq! (::core::mem::align_of::<_EFI_UNICODE_COLLATION_INTERFACE>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _EFI_UNICODE_COLLATION_INTERFACE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UNICODE_COLLATION_INTERFACE ) ) .
                StriColl as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_UNICODE_COLLATION_INTERFACE ) , "::" , stringify ! (
                StriColl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UNICODE_COLLATION_INTERFACE ) ) .
                MetaiMatch as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_UNICODE_COLLATION_INTERFACE ) , "::" , stringify ! (
                MetaiMatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UNICODE_COLLATION_INTERFACE ) ) .
                StrLwr as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_UNICODE_COLLATION_INTERFACE ) , "::" , stringify ! (
                StrLwr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UNICODE_COLLATION_INTERFACE ) ) .
                StrUpr as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_UNICODE_COLLATION_INTERFACE ) , "::" , stringify ! (
                StrUpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UNICODE_COLLATION_INTERFACE ) ) .
                FatToStr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_UNICODE_COLLATION_INTERFACE ) , "::" , stringify ! (
                FatToStr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UNICODE_COLLATION_INTERFACE ) ) .
                StrToFat as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_UNICODE_COLLATION_INTERFACE ) , "::" , stringify ! (
                StrToFat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UNICODE_COLLATION_INTERFACE ) ) .
                SupportedLanguages as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                _EFI_UNICODE_COLLATION_INTERFACE ) , "::" , stringify ! (
                SupportedLanguages ) ));
}
impl Clone for _EFI_UNICODE_COLLATION_INTERFACE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_UNICODE_STRICOLL =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_UNICODE_COLLATION_INTERFACE,
                                                s1: *mut CHAR16,
                                                s2: *mut CHAR16) -> INTN>;
pub type EFI_UNICODE_METAIMATCH =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_UNICODE_COLLATION_INTERFACE,
                                                String: *mut CHAR16,
                                                Pattern: *mut CHAR16)
                               -> BOOLEAN>;
pub type EFI_UNICODE_STRLWR =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_UNICODE_COLLATION_INTERFACE,
                                                Str: *mut CHAR16)>;
pub type EFI_UNICODE_STRUPR =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_UNICODE_COLLATION_INTERFACE,
                                                Str: *mut CHAR16)>;
pub type EFI_UNICODE_FATTOSTR =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_UNICODE_COLLATION_INTERFACE,
                                                FatSize: UINTN,
                                                Fat: *mut CHAR8,
                                                String: *mut CHAR16)>;
pub type EFI_UNICODE_STRTOFAT =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_UNICODE_COLLATION_INTERFACE,
                                                String: *mut CHAR16,
                                                FatSize: UINTN,
                                                Fat: *mut CHAR8) -> BOOLEAN>;
pub type EFI_UNICODE_COLLATION_INTERFACE = _EFI_UNICODE_COLLATION_INTERFACE;
#[repr(C)]

pub struct _EFI_GRAPHICS_OUTPUT_PROTOCOL {
    pub QueryMode: EFI_GRAPHICS_OUTPUT_PROTOCOL_QUERY_MODE,
    pub SetMode: EFI_GRAPHICS_OUTPUT_PROTOCOL_SET_MODE,
    pub Blt: EFI_GRAPHICS_OUTPUT_PROTOCOL_BLT,
    pub Mode: *mut EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE,
}
#[test]
fn bindgen_test_layout__EFI_GRAPHICS_OUTPUT_PROTOCOL() {
    assert_eq!(::core::mem::size_of::<_EFI_GRAPHICS_OUTPUT_PROTOCOL>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( _EFI_GRAPHICS_OUTPUT_PROTOCOL ) ));
    assert_eq! (::core::mem::align_of::<_EFI_GRAPHICS_OUTPUT_PROTOCOL>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _EFI_GRAPHICS_OUTPUT_PROTOCOL
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_GRAPHICS_OUTPUT_PROTOCOL ) ) .
                QueryMode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_GRAPHICS_OUTPUT_PROTOCOL ) , "::" , stringify ! (
                QueryMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_GRAPHICS_OUTPUT_PROTOCOL ) ) .
                SetMode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_GRAPHICS_OUTPUT_PROTOCOL ) , "::" , stringify ! ( SetMode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_GRAPHICS_OUTPUT_PROTOCOL ) ) . Blt
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_GRAPHICS_OUTPUT_PROTOCOL ) , "::" , stringify ! ( Blt )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_GRAPHICS_OUTPUT_PROTOCOL ) ) . Mode
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_GRAPHICS_OUTPUT_PROTOCOL ) , "::" , stringify ! ( Mode )
                ));
}
impl Clone for _EFI_GRAPHICS_OUTPUT_PROTOCOL {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_GRAPHICS_OUTPUT_PROTOCOL = _EFI_GRAPHICS_OUTPUT_PROTOCOL;
#[repr(C)]

pub struct EFI_PIXEL_BITMASK {
    pub RedMask: UINT32,
    pub GreenMask: UINT32,
    pub BlueMask: UINT32,
    pub ReservedMask: UINT32,
}
#[test]
fn bindgen_test_layout_EFI_PIXEL_BITMASK() {
    assert_eq!(::core::mem::size_of::<EFI_PIXEL_BITMASK>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( EFI_PIXEL_BITMASK ) ));
    assert_eq! (::core::mem::align_of::<EFI_PIXEL_BITMASK>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( EFI_PIXEL_BITMASK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PIXEL_BITMASK ) ) . RedMask as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PIXEL_BITMASK ) ,
                "::" , stringify ! ( RedMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PIXEL_BITMASK ) ) . GreenMask as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PIXEL_BITMASK ) ,
                "::" , stringify ! ( GreenMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PIXEL_BITMASK ) ) . BlueMask as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PIXEL_BITMASK ) ,
                "::" , stringify ! ( BlueMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PIXEL_BITMASK ) ) . ReservedMask as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PIXEL_BITMASK ) ,
                "::" , stringify ! ( ReservedMask ) ));
}
impl Clone for EFI_PIXEL_BITMASK {
    fn clone(&self) -> Self { unimplemented!() }
}
pub const EFI_GRAPHICS_PIXEL_FORMAT_PixelRedGreenBlueReserved8BitPerColor:
          EFI_GRAPHICS_PIXEL_FORMAT =
    0;
pub const EFI_GRAPHICS_PIXEL_FORMAT_PixelBlueGreenRedReserved8BitPerColor:
          EFI_GRAPHICS_PIXEL_FORMAT =
    1;
pub const EFI_GRAPHICS_PIXEL_FORMAT_PixelBitMask: EFI_GRAPHICS_PIXEL_FORMAT =
    2;
pub const EFI_GRAPHICS_PIXEL_FORMAT_PixelBltOnly: EFI_GRAPHICS_PIXEL_FORMAT =
    3;
pub const EFI_GRAPHICS_PIXEL_FORMAT_PixelFormatMax: EFI_GRAPHICS_PIXEL_FORMAT
          =
    4;
pub type EFI_GRAPHICS_PIXEL_FORMAT = ::ctypes::c_uint;
#[repr(C)]

pub struct EFI_GRAPHICS_OUTPUT_MODE_INFORMATION {
    pub Version: UINT32,
    pub HorizontalResolution: UINT32,
    pub VerticalResolution: UINT32,
    pub PixelFormat: EFI_GRAPHICS_PIXEL_FORMAT,
    pub PixelInformation: EFI_PIXEL_BITMASK,
    pub PixelsPerScanLine: UINT32,
}
#[test]
fn bindgen_test_layout_EFI_GRAPHICS_OUTPUT_MODE_INFORMATION() {
    assert_eq!(::core::mem::size_of::<EFI_GRAPHICS_OUTPUT_MODE_INFORMATION>()
               , 36usize , concat ! (
               "Size of: " , stringify ! (
               EFI_GRAPHICS_OUTPUT_MODE_INFORMATION ) ));
    assert_eq! (::core::mem::align_of::<EFI_GRAPHICS_OUTPUT_MODE_INFORMATION>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_GRAPHICS_OUTPUT_MODE_INFORMATION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_MODE_INFORMATION ) )
                . Version as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_MODE_INFORMATION ) , "::" , stringify ! (
                Version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_MODE_INFORMATION ) )
                . HorizontalResolution as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_MODE_INFORMATION ) , "::" , stringify ! (
                HorizontalResolution ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_MODE_INFORMATION ) )
                . VerticalResolution as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_MODE_INFORMATION ) , "::" , stringify ! (
                VerticalResolution ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_MODE_INFORMATION ) )
                . PixelFormat as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_MODE_INFORMATION ) , "::" , stringify ! (
                PixelFormat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_MODE_INFORMATION ) )
                . PixelInformation as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_MODE_INFORMATION ) , "::" , stringify ! (
                PixelInformation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_MODE_INFORMATION ) )
                . PixelsPerScanLine as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_MODE_INFORMATION ) , "::" , stringify ! (
                PixelsPerScanLine ) ));
}
impl Clone for EFI_GRAPHICS_OUTPUT_MODE_INFORMATION {
    fn clone(&self) -> Self { unimplemented!() }
}
/**
  Return the current video mode information.

  @param  This       Protocol instance pointer.
  @param  ModeNumber The mode number to return information on.
  @param  SizeOfInfo A pointer to the size, in bytes, of the Info buffer.
  @param  Info       A pointer to callee allocated buffer that returns information about ModeNumber.

  @retval EFI_SUCCESS           Mode information returned.
  @retval EFI_BUFFER_TOO_SMALL  The Info buffer was too small.
  @retval EFI_DEVICE_ERROR      A hardware error occurred trying to retrieve the video mode.
  @retval EFI_NOT_STARTED       Video display is not initialized. Call SetMode ()
  @retval EFI_INVALID_PARAMETER One of the input args was NULL.

**/
pub type EFI_GRAPHICS_OUTPUT_PROTOCOL_QUERY_MODE =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut EFI_GRAPHICS_OUTPUT_PROTOCOL,
                                                ModeNumber: UINT32,
                                                SizeOfInfo: *mut UINTN,
                                                Info:
                                                    *mut *mut EFI_GRAPHICS_OUTPUT_MODE_INFORMATION)
                               -> EFI_STATUS>;
/**
  Return the current video mode information.

  @param  This              Protocol instance pointer.
  @param  ModeNumber        The mode number to be set.

  @retval EFI_SUCCESS       Graphics mode was changed.
  @retval EFI_DEVICE_ERROR  The device had an error and could not complete the request.
  @retval EFI_UNSUPPORTED   ModeNumber is not supported by this device.

**/
pub type EFI_GRAPHICS_OUTPUT_PROTOCOL_SET_MODE =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut EFI_GRAPHICS_OUTPUT_PROTOCOL,
                                                ModeNumber: UINT32)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_GRAPHICS_OUTPUT_BLT_PIXEL {
    pub Blue: UINT8,
    pub Green: UINT8,
    pub Red: UINT8,
    pub Reserved: UINT8,
}
#[test]
fn bindgen_test_layout_EFI_GRAPHICS_OUTPUT_BLT_PIXEL() {
    assert_eq!(::core::mem::size_of::<EFI_GRAPHICS_OUTPUT_BLT_PIXEL>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( EFI_GRAPHICS_OUTPUT_BLT_PIXEL ) ));
    assert_eq! (::core::mem::align_of::<EFI_GRAPHICS_OUTPUT_BLT_PIXEL>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( EFI_GRAPHICS_OUTPUT_BLT_PIXEL
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_BLT_PIXEL ) ) . Blue
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_BLT_PIXEL ) , "::" , stringify ! ( Blue )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_BLT_PIXEL ) ) . Green
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_BLT_PIXEL ) , "::" , stringify ! ( Green )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_BLT_PIXEL ) ) . Red
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_BLT_PIXEL ) , "::" , stringify ! ( Red )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_BLT_PIXEL ) ) .
                Reserved as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_BLT_PIXEL ) , "::" , stringify ! (
                Reserved ) ));
}
impl Clone for EFI_GRAPHICS_OUTPUT_BLT_PIXEL {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub union EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION {
    pub Pixel: EFI_GRAPHICS_OUTPUT_BLT_PIXEL,
    pub Raw: UINT32,
}
#[test]
fn bindgen_test_layout_EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION() {
    assert_eq!(::core::mem::size_of::<EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION
               ) ));
    assert_eq! (::core::mem::align_of::<EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION ) ) .
                Pixel as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION ) , "::" , stringify ! (
                Pixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION ) ) .
                Raw as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION ) , "::" , stringify ! (
                Raw ) ));
}
impl Clone for EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION {
    fn clone(&self) -> Self { unimplemented!() }
}
pub const EFI_GRAPHICS_OUTPUT_BLT_OPERATION_EfiBltVideoFill:
          EFI_GRAPHICS_OUTPUT_BLT_OPERATION =
    0;
pub const EFI_GRAPHICS_OUTPUT_BLT_OPERATION_EfiBltVideoToBltBuffer:
          EFI_GRAPHICS_OUTPUT_BLT_OPERATION =
    1;
pub const EFI_GRAPHICS_OUTPUT_BLT_OPERATION_EfiBltBufferToVideo:
          EFI_GRAPHICS_OUTPUT_BLT_OPERATION =
    2;
pub const EFI_GRAPHICS_OUTPUT_BLT_OPERATION_EfiBltVideoToVideo:
          EFI_GRAPHICS_OUTPUT_BLT_OPERATION =
    3;
pub const EFI_GRAPHICS_OUTPUT_BLT_OPERATION_EfiGraphicsOutputBltOperationMax:
          EFI_GRAPHICS_OUTPUT_BLT_OPERATION =
    4;
pub type EFI_GRAPHICS_OUTPUT_BLT_OPERATION = ::ctypes::c_uint;
/**
  The following table defines actions for BltOperations:

  <B>EfiBltVideoFill</B> - Write data from the  BltBuffer pixel (SourceX, SourceY) 
  directly to every pixel of the video display rectangle 
  (DestinationX, DestinationY) (DestinationX + Width, DestinationY + Height). 
  Only one pixel will be used from the BltBuffer. Delta is NOT used.

  <B>EfiBltVideoToBltBuffer</B> - Read data from the video display rectangle 
  (SourceX, SourceY) (SourceX + Width, SourceY + Height) and place it in 
  the BltBuffer rectangle (DestinationX, DestinationY ) 
  (DestinationX + Width, DestinationY + Height). If DestinationX or 
  DestinationY is not zero then Delta must be set to the length in bytes 
  of a row in the BltBuffer.

  <B>EfiBltBufferToVideo</B> - Write data from the  BltBuffer rectangle 
  (SourceX, SourceY) (SourceX + Width, SourceY + Height) directly to the 
  video display rectangle (DestinationX, DestinationY) 
  (DestinationX + Width, DestinationY + Height). If SourceX or SourceY is 
  not zero then Delta must be set to the length in bytes of a row in the 
  BltBuffer.

  <B>EfiBltVideoToVideo</B> - Copy from the video display rectangle (SourceX, SourceY)
  (SourceX + Width, SourceY + Height) .to the video display rectangle 
  (DestinationX, DestinationY) (DestinationX + Width, DestinationY + Height). 
  The BltBuffer and Delta  are not used in this mode.

  @param  This         Protocol instance pointer.
  @param  BltBuffer    Buffer containing data to blit into video buffer. This
                       buffer has a size of Width*Height*sizeof(EFI_GRAPHICS_OUTPUT_BLT_PIXEL)
  @param  BltOperation Operation to perform on BlitBuffer and video memory
  @param  SourceX      X coordinate of source for the BltBuffer.
  @param  SourceY      Y coordinate of source for the BltBuffer.
  @param  DestinationX X coordinate of destination for the BltBuffer.
  @param  DestinationY Y coordinate of destination for the BltBuffer.
  @param  Width        Width of rectangle in BltBuffer in pixels.
  @param  Height       Hight of rectangle in BltBuffer in pixels.
  @param  Delta        OPTIONAL

  @retval EFI_SUCCESS           The Blt operation completed.
  @retval EFI_INVALID_PARAMETER BltOperation is not valid.
  @retval EFI_DEVICE_ERROR      A hardware error occured writting to the video buffer.

**/
pub type EFI_GRAPHICS_OUTPUT_PROTOCOL_BLT =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut EFI_GRAPHICS_OUTPUT_PROTOCOL,
                                                BltBuffer:
                                                    *mut EFI_GRAPHICS_OUTPUT_BLT_PIXEL,
                                                BltOperation:
                                                    EFI_GRAPHICS_OUTPUT_BLT_OPERATION,
                                                SourceX: UINTN,
                                                SourceY: UINTN,
                                                DestinationX: UINTN,
                                                DestinationY: UINTN,
                                                Width: UINTN, Height: UINTN,
                                                Delta: UINTN) -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE {
    pub MaxMode: UINT32,
    pub Mode: UINT32,
    pub Info: *mut EFI_GRAPHICS_OUTPUT_MODE_INFORMATION,
    pub SizeOfInfo: UINTN,
    pub FrameBufferBase: EFI_PHYSICAL_ADDRESS,
    pub FrameBufferSize: UINTN,
}
#[test]
fn bindgen_test_layout_EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE() {
    assert_eq!(::core::mem::size_of::<EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE )
               ));
    assert_eq! (::core::mem::align_of::<EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE ) ) .
                MaxMode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE ) , "::" , stringify ! (
                MaxMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE ) ) .
                Mode as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE ) , "::" , stringify ! (
                Mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE ) ) .
                Info as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE ) , "::" , stringify ! (
                Info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE ) ) .
                SizeOfInfo as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE ) , "::" , stringify ! (
                SizeOfInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE ) ) .
                FrameBufferBase as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE ) , "::" , stringify ! (
                FrameBufferBase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE ) ) .
                FrameBufferSize as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE ) , "::" , stringify ! (
                FrameBufferSize ) ));
}
impl Clone for EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct _EFI_SERVICE_BINDING {
    pub CreateChild: EFI_SERVICE_BINDING_CREATE_CHILD,
    pub DestroyChild: EFI_SERVICE_BINDING_DESTROY_CHILD,
}
#[test]
fn bindgen_test_layout__EFI_SERVICE_BINDING() {
    assert_eq!(::core::mem::size_of::<_EFI_SERVICE_BINDING>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _EFI_SERVICE_BINDING )
               ));
    assert_eq! (::core::mem::align_of::<_EFI_SERVICE_BINDING>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _EFI_SERVICE_BINDING ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SERVICE_BINDING ) ) . CreateChild as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SERVICE_BINDING )
                , "::" , stringify ! ( CreateChild ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SERVICE_BINDING ) ) . DestroyChild
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SERVICE_BINDING )
                , "::" , stringify ! ( DestroyChild ) ));
}
impl Clone for _EFI_SERVICE_BINDING {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_SERVICE_BINDING_CREATE_CHILD =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SERVICE_BINDING,
                                                ChildHandle: *mut EFI_HANDLE)
                               -> EFI_STATUS>;
pub type EFI_SERVICE_BINDING_DESTROY_CHILD =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SERVICE_BINDING,
                                                ChildHandle: EFI_HANDLE)
                               -> EFI_STATUS>;
pub type EFI_SERVICE_BINDING = _EFI_SERVICE_BINDING;
#[repr(C)]

pub struct _SIMPLE_TEXT_OUTPUT_INTERFACE {
    pub Reset: EFI_TEXT_RESET,
    pub OutputString: EFI_TEXT_OUTPUT_STRING,
    pub TestString: EFI_TEXT_TEST_STRING,
    pub QueryMode: EFI_TEXT_QUERY_MODE,
    pub SetMode: EFI_TEXT_SET_MODE,
    pub SetAttribute: EFI_TEXT_SET_ATTRIBUTE,
    pub ClearScreen: EFI_TEXT_CLEAR_SCREEN,
    pub SetCursorPosition: EFI_TEXT_SET_CURSOR_POSITION,
    pub EnableCursor: EFI_TEXT_ENABLE_CURSOR,
    pub Mode: *mut SIMPLE_TEXT_OUTPUT_MODE,
}
#[test]
fn bindgen_test_layout__SIMPLE_TEXT_OUTPUT_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_SIMPLE_TEXT_OUTPUT_INTERFACE>() ,
               80usize , concat ! (
               "Size of: " , stringify ! ( _SIMPLE_TEXT_OUTPUT_INTERFACE ) ));
    assert_eq! (::core::mem::align_of::<_SIMPLE_TEXT_OUTPUT_INTERFACE>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _SIMPLE_TEXT_OUTPUT_INTERFACE
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SIMPLE_TEXT_OUTPUT_INTERFACE ) ) . Reset
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _SIMPLE_TEXT_OUTPUT_INTERFACE ) , "::" , stringify ! ( Reset )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SIMPLE_TEXT_OUTPUT_INTERFACE ) ) .
                OutputString as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _SIMPLE_TEXT_OUTPUT_INTERFACE ) , "::" , stringify ! (
                OutputString ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SIMPLE_TEXT_OUTPUT_INTERFACE ) ) .
                TestString as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _SIMPLE_TEXT_OUTPUT_INTERFACE ) , "::" , stringify ! (
                TestString ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SIMPLE_TEXT_OUTPUT_INTERFACE ) ) .
                QueryMode as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _SIMPLE_TEXT_OUTPUT_INTERFACE ) , "::" , stringify ! (
                QueryMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SIMPLE_TEXT_OUTPUT_INTERFACE ) ) .
                SetMode as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                _SIMPLE_TEXT_OUTPUT_INTERFACE ) , "::" , stringify ! ( SetMode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SIMPLE_TEXT_OUTPUT_INTERFACE ) ) .
                SetAttribute as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                _SIMPLE_TEXT_OUTPUT_INTERFACE ) , "::" , stringify ! (
                SetAttribute ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SIMPLE_TEXT_OUTPUT_INTERFACE ) ) .
                ClearScreen as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _SIMPLE_TEXT_OUTPUT_INTERFACE ) , "::" , stringify ! (
                ClearScreen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SIMPLE_TEXT_OUTPUT_INTERFACE ) ) .
                SetCursorPosition as * const _ as usize } , 56usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _SIMPLE_TEXT_OUTPUT_INTERFACE ) , "::" , stringify ! (
                SetCursorPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SIMPLE_TEXT_OUTPUT_INTERFACE ) ) .
                EnableCursor as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                _SIMPLE_TEXT_OUTPUT_INTERFACE ) , "::" , stringify ! (
                EnableCursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SIMPLE_TEXT_OUTPUT_INTERFACE ) ) . Mode
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                _SIMPLE_TEXT_OUTPUT_INTERFACE ) , "::" , stringify ! ( Mode )
                ));
}
impl Clone for _SIMPLE_TEXT_OUTPUT_INTERFACE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_TEXT_RESET =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SIMPLE_TEXT_OUTPUT_INTERFACE,
                                                ExtendedVerification: BOOLEAN)
                               -> EFI_STATUS>;
pub type EFI_TEXT_OUTPUT_STRING =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SIMPLE_TEXT_OUTPUT_INTERFACE,
                                                String: *mut CHAR16)
                               -> EFI_STATUS>;
pub type EFI_TEXT_TEST_STRING =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SIMPLE_TEXT_OUTPUT_INTERFACE,
                                                String: *mut CHAR16)
                               -> EFI_STATUS>;
pub type EFI_TEXT_QUERY_MODE =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SIMPLE_TEXT_OUTPUT_INTERFACE,
                                                ModeNumber: UINTN,
                                                Columns: *mut UINTN,
                                                Rows: *mut UINTN)
                               -> EFI_STATUS>;
pub type EFI_TEXT_SET_MODE =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SIMPLE_TEXT_OUTPUT_INTERFACE,
                                                ModeNumber: UINTN)
                               -> EFI_STATUS>;
pub type EFI_TEXT_SET_ATTRIBUTE =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SIMPLE_TEXT_OUTPUT_INTERFACE,
                                                Attribute: UINTN)
                               -> EFI_STATUS>;
pub type EFI_TEXT_CLEAR_SCREEN =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SIMPLE_TEXT_OUTPUT_INTERFACE)
                               -> EFI_STATUS>;
pub type EFI_TEXT_SET_CURSOR_POSITION =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SIMPLE_TEXT_OUTPUT_INTERFACE,
                                                Column: UINTN, Row: UINTN)
                               -> EFI_STATUS>;
pub type EFI_TEXT_ENABLE_CURSOR =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SIMPLE_TEXT_OUTPUT_INTERFACE,
                                                Enable: BOOLEAN)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct SIMPLE_TEXT_OUTPUT_MODE {
    pub MaxMode: INT32,
    pub Mode: INT32,
    pub Attribute: INT32,
    pub CursorColumn: INT32,
    pub CursorRow: INT32,
    pub CursorVisible: BOOLEAN,
}
#[test]
fn bindgen_test_layout_SIMPLE_TEXT_OUTPUT_MODE() {
    assert_eq!(::core::mem::size_of::<SIMPLE_TEXT_OUTPUT_MODE>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( SIMPLE_TEXT_OUTPUT_MODE ) ));
    assert_eq! (::core::mem::align_of::<SIMPLE_TEXT_OUTPUT_MODE>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SIMPLE_TEXT_OUTPUT_MODE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SIMPLE_TEXT_OUTPUT_MODE ) ) . MaxMode as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SIMPLE_TEXT_OUTPUT_MODE
                ) , "::" , stringify ! ( MaxMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SIMPLE_TEXT_OUTPUT_MODE ) ) . Mode as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SIMPLE_TEXT_OUTPUT_MODE
                ) , "::" , stringify ! ( Mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SIMPLE_TEXT_OUTPUT_MODE ) ) . Attribute
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SIMPLE_TEXT_OUTPUT_MODE
                ) , "::" , stringify ! ( Attribute ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SIMPLE_TEXT_OUTPUT_MODE ) ) .
                CursorColumn as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SIMPLE_TEXT_OUTPUT_MODE
                ) , "::" , stringify ! ( CursorColumn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SIMPLE_TEXT_OUTPUT_MODE ) ) . CursorRow
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SIMPLE_TEXT_OUTPUT_MODE
                ) , "::" , stringify ! ( CursorRow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SIMPLE_TEXT_OUTPUT_MODE ) ) .
                CursorVisible as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SIMPLE_TEXT_OUTPUT_MODE
                ) , "::" , stringify ! ( CursorVisible ) ));
}
impl Clone for SIMPLE_TEXT_OUTPUT_MODE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type SIMPLE_TEXT_OUTPUT_INTERFACE = _SIMPLE_TEXT_OUTPUT_INTERFACE;
#[repr(C)]

pub struct _SIMPLE_INPUT_INTERFACE {
    pub Reset: EFI_INPUT_RESET,
    pub ReadKeyStroke: EFI_INPUT_READ_KEY,
    pub WaitForKey: EFI_EVENT,
}
#[test]
fn bindgen_test_layout__SIMPLE_INPUT_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_SIMPLE_INPUT_INTERFACE>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( _SIMPLE_INPUT_INTERFACE ) ));
    assert_eq! (::core::mem::align_of::<_SIMPLE_INPUT_INTERFACE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _SIMPLE_INPUT_INTERFACE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SIMPLE_INPUT_INTERFACE ) ) . Reset as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _SIMPLE_INPUT_INTERFACE
                ) , "::" , stringify ! ( Reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SIMPLE_INPUT_INTERFACE ) ) .
                ReadKeyStroke as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _SIMPLE_INPUT_INTERFACE
                ) , "::" , stringify ! ( ReadKeyStroke ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SIMPLE_INPUT_INTERFACE ) ) . WaitForKey
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _SIMPLE_INPUT_INTERFACE
                ) , "::" , stringify ! ( WaitForKey ) ));
}
impl Clone for _SIMPLE_INPUT_INTERFACE {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_INPUT_KEY {
    pub ScanCode: UINT16,
    pub UnicodeChar: CHAR16,
}
#[test]
fn bindgen_test_layout_EFI_INPUT_KEY() {
    assert_eq!(::core::mem::size_of::<EFI_INPUT_KEY>() , 4usize , concat ! (
               "Size of: " , stringify ! ( EFI_INPUT_KEY ) ));
    assert_eq! (::core::mem::align_of::<EFI_INPUT_KEY>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( EFI_INPUT_KEY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_INPUT_KEY ) ) . ScanCode as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_INPUT_KEY ) , "::"
                , stringify ! ( ScanCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_INPUT_KEY ) ) . UnicodeChar as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_INPUT_KEY ) , "::"
                , stringify ! ( UnicodeChar ) ));
}
impl Clone for EFI_INPUT_KEY {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_INPUT_RESET =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SIMPLE_INPUT_INTERFACE,
                                                ExtendedVerification: BOOLEAN)
                               -> EFI_STATUS>;
pub type EFI_INPUT_READ_KEY =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SIMPLE_INPUT_INTERFACE,
                                                Key: *mut EFI_INPUT_KEY)
                               -> EFI_STATUS>;
pub type SIMPLE_INPUT_INTERFACE = _SIMPLE_INPUT_INTERFACE;
#[repr(C)]

pub struct _SERIAL_IO_INTERFACE {
    pub Revision: UINT32,
    pub Reset: EFI_SERIAL_RESET,
    pub SetAttributes: EFI_SERIAL_SET_ATTRIBUTES,
    pub SetControl: EFI_SERIAL_SET_CONTROL_BITS,
    pub GetControl: EFI_SERIAL_GET_CONTROL_BITS,
    pub Write: EFI_SERIAL_WRITE,
    pub Read: EFI_SERIAL_READ,
    pub Mode: *mut SERIAL_IO_MODE,
}
#[test]
fn bindgen_test_layout__SERIAL_IO_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_SERIAL_IO_INTERFACE>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _SERIAL_IO_INTERFACE )
               ));
    assert_eq! (::core::mem::align_of::<_SERIAL_IO_INTERFACE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _SERIAL_IO_INTERFACE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SERIAL_IO_INTERFACE ) ) . Revision as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _SERIAL_IO_INTERFACE )
                , "::" , stringify ! ( Revision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SERIAL_IO_INTERFACE ) ) . Reset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _SERIAL_IO_INTERFACE )
                , "::" , stringify ! ( Reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SERIAL_IO_INTERFACE ) ) . SetAttributes
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _SERIAL_IO_INTERFACE )
                , "::" , stringify ! ( SetAttributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SERIAL_IO_INTERFACE ) ) . SetControl as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _SERIAL_IO_INTERFACE )
                , "::" , stringify ! ( SetControl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SERIAL_IO_INTERFACE ) ) . GetControl as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _SERIAL_IO_INTERFACE )
                , "::" , stringify ! ( GetControl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SERIAL_IO_INTERFACE ) ) . Write as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _SERIAL_IO_INTERFACE )
                , "::" , stringify ! ( Write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SERIAL_IO_INTERFACE ) ) . Read as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _SERIAL_IO_INTERFACE )
                , "::" , stringify ! ( Read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SERIAL_IO_INTERFACE ) ) . Mode as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _SERIAL_IO_INTERFACE )
                , "::" , stringify ! ( Mode ) ));
}
impl Clone for _SERIAL_IO_INTERFACE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub const EFI_PARITY_TYPE_DefaultParity: EFI_PARITY_TYPE = 0;
pub const EFI_PARITY_TYPE_NoParity: EFI_PARITY_TYPE = 1;
pub const EFI_PARITY_TYPE_EvenParity: EFI_PARITY_TYPE = 2;
pub const EFI_PARITY_TYPE_OddParity: EFI_PARITY_TYPE = 3;
pub const EFI_PARITY_TYPE_MarkParity: EFI_PARITY_TYPE = 4;
pub const EFI_PARITY_TYPE_SpaceParity: EFI_PARITY_TYPE = 5;
pub type EFI_PARITY_TYPE = ::ctypes::c_uint;
pub const EFI_STOP_BITS_TYPE_DefaultStopBits: EFI_STOP_BITS_TYPE = 0;
pub const EFI_STOP_BITS_TYPE_OneStopBit: EFI_STOP_BITS_TYPE = 1;
pub const EFI_STOP_BITS_TYPE_OneFiveStopBits: EFI_STOP_BITS_TYPE = 2;
pub const EFI_STOP_BITS_TYPE_TwoStopBits: EFI_STOP_BITS_TYPE = 3;
pub type EFI_STOP_BITS_TYPE = ::ctypes::c_uint;
pub type EFI_SERIAL_RESET =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SERIAL_IO_INTERFACE)
                               -> EFI_STATUS>;
pub type EFI_SERIAL_SET_ATTRIBUTES =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SERIAL_IO_INTERFACE,
                                                BaudRate: UINT64,
                                                ReceiveFifoDepth: UINT32,
                                                Timeout: UINT32,
                                                Parity: EFI_PARITY_TYPE,
                                                DataBits: UINT8,
                                                StopBits: EFI_STOP_BITS_TYPE)
                               -> EFI_STATUS>;
pub type EFI_SERIAL_SET_CONTROL_BITS =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SERIAL_IO_INTERFACE,
                                                Control: UINT32)
                               -> EFI_STATUS>;
pub type EFI_SERIAL_GET_CONTROL_BITS =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SERIAL_IO_INTERFACE,
                                                Control: *mut UINT32)
                               -> EFI_STATUS>;
pub type EFI_SERIAL_WRITE =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SERIAL_IO_INTERFACE,
                                                BufferSize: *mut UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_SERIAL_READ =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _SERIAL_IO_INTERFACE,
                                                BufferSize: *mut UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct SERIAL_IO_MODE {
    pub ControlMask: UINT32,
    pub Timeout: UINT32,
    pub BaudRate: UINT64,
    pub ReceiveFifoDepth: UINT32,
    pub DataBits: UINT32,
    pub Parity: UINT32,
    pub StopBits: UINT32,
}
#[test]
fn bindgen_test_layout_SERIAL_IO_MODE() {
    assert_eq!(::core::mem::size_of::<SERIAL_IO_MODE>() , 32usize , concat ! (
               "Size of: " , stringify ! ( SERIAL_IO_MODE ) ));
    assert_eq! (::core::mem::align_of::<SERIAL_IO_MODE>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( SERIAL_IO_MODE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SERIAL_IO_MODE ) ) . ControlMask as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SERIAL_IO_MODE ) , "::"
                , stringify ! ( ControlMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SERIAL_IO_MODE ) ) . Timeout as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SERIAL_IO_MODE ) , "::"
                , stringify ! ( Timeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SERIAL_IO_MODE ) ) . BaudRate as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SERIAL_IO_MODE ) , "::"
                , stringify ! ( BaudRate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SERIAL_IO_MODE ) ) . ReceiveFifoDepth as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SERIAL_IO_MODE ) , "::"
                , stringify ! ( ReceiveFifoDepth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SERIAL_IO_MODE ) ) . DataBits as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SERIAL_IO_MODE ) , "::"
                , stringify ! ( DataBits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SERIAL_IO_MODE ) ) . Parity as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SERIAL_IO_MODE ) , "::"
                , stringify ! ( Parity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SERIAL_IO_MODE ) ) . StopBits as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( SERIAL_IO_MODE ) , "::"
                , stringify ! ( StopBits ) ));
}
impl Clone for SERIAL_IO_MODE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type SERIAL_IO_INTERFACE = _SERIAL_IO_INTERFACE;
pub const EFI_NETWORK_INTERFACE_TYPE_EfiNetworkInterfaceUndi:
          EFI_NETWORK_INTERFACE_TYPE =
    1;
pub type EFI_NETWORK_INTERFACE_TYPE = ::ctypes::c_uint;
#[repr(C)]

pub struct EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE {
    pub Revision: UINT64,
    pub ID: UINT64,
    pub ImageAddr: UINT64,
    pub ImageSize: UINT32,
    pub StringId: [CHAR8; 4usize],
    pub Type: UINT8,
    pub MajorVer: UINT8,
    pub MinorVer: UINT8,
    pub Ipv6Supported: BOOLEAN,
    pub IfNum: UINT8,
}
#[test]
fn bindgen_test_layout_EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE() {
    assert_eq!(::core::mem::size_of::<EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE ) ));
    assert_eq! (::core::mem::align_of::<EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE )
                ) . Revision as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE ) , "::" ,
                stringify ! ( Revision ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE )
                ) . ID as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE ) , "::" ,
                stringify ! ( ID ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE )
                ) . ImageAddr as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE ) , "::" ,
                stringify ! ( ImageAddr ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE )
                ) . ImageSize as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE ) , "::" ,
                stringify ! ( ImageSize ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE )
                ) . StringId as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE ) , "::" ,
                stringify ! ( StringId ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE )
                ) . Type as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE ) , "::" ,
                stringify ! ( Type ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE )
                ) . MajorVer as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE ) , "::" ,
                stringify ! ( MajorVer ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE )
                ) . MinorVer as * const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE ) , "::" ,
                stringify ! ( MinorVer ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE )
                ) . Ipv6Supported as * const _ as usize } , 35usize , concat !
                (
                "Alignment of field: " , stringify ! (
                EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE ) , "::" ,
                stringify ! ( Ipv6Supported ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE )
                ) . IfNum as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE ) , "::" ,
                stringify ! ( IfNum ) ));
}
impl Clone for EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE {
    fn clone(&self) -> Self { unimplemented!() }
}
extern "win64" {
    #[link_name = "NetworkInterfaceIdentifierProtocol"]
    pub static mut NetworkInterfaceIdentifierProtocol: EFI_GUID;
}
#[repr(C)]

pub struct _EFI_PXE_BASE_CODE {
    pub Revision: UINT64,
    pub Start: EFI_PXE_BASE_CODE_START,
    pub Stop: EFI_PXE_BASE_CODE_STOP,
    pub Dhcp: EFI_PXE_BASE_CODE_DHCP,
    pub Discover: EFI_PXE_BASE_CODE_DISCOVER,
    pub Mtftp: EFI_PXE_BASE_CODE_MTFTP,
    pub UdpWrite: EFI_PXE_BASE_CODE_UDP_WRITE,
    pub UdpRead: EFI_PXE_BASE_CODE_UDP_READ,
    pub SetIpFilter: EFI_PXE_BASE_CODE_SET_IP_FILTER,
    pub Arp: EFI_PXE_BASE_CODE_ARP,
    pub SetParameters: EFI_PXE_BASE_CODE_SET_PARAMETERS,
    pub SetStationIp: EFI_PXE_BASE_CODE_SET_STATION_IP,
    pub SetPackets: EFI_PXE_BASE_CODE_SET_PACKETS,
    pub Mode: *mut EFI_PXE_BASE_CODE_MODE,
}
#[test]
fn bindgen_test_layout__EFI_PXE_BASE_CODE() {
    assert_eq!(::core::mem::size_of::<_EFI_PXE_BASE_CODE>() , 112usize ,
               concat ! ( "Size of: " , stringify ! ( _EFI_PXE_BASE_CODE ) ));
    assert_eq! (::core::mem::align_of::<_EFI_PXE_BASE_CODE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _EFI_PXE_BASE_CODE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE ) ) . Revision as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PXE_BASE_CODE ) ,
                "::" , stringify ! ( Revision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE ) ) . Start as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PXE_BASE_CODE ) ,
                "::" , stringify ! ( Start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE ) ) . Stop as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PXE_BASE_CODE ) ,
                "::" , stringify ! ( Stop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE ) ) . Dhcp as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PXE_BASE_CODE ) ,
                "::" , stringify ! ( Dhcp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE ) ) . Discover as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PXE_BASE_CODE ) ,
                "::" , stringify ! ( Discover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE ) ) . Mtftp as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PXE_BASE_CODE ) ,
                "::" , stringify ! ( Mtftp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE ) ) . UdpWrite as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PXE_BASE_CODE ) ,
                "::" , stringify ! ( UdpWrite ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE ) ) . UdpRead as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PXE_BASE_CODE ) ,
                "::" , stringify ! ( UdpRead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE ) ) . SetIpFilter as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PXE_BASE_CODE ) ,
                "::" , stringify ! ( SetIpFilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE ) ) . Arp as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PXE_BASE_CODE ) ,
                "::" , stringify ! ( Arp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE ) ) . SetParameters as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PXE_BASE_CODE ) ,
                "::" , stringify ! ( SetParameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE ) ) . SetStationIp as
                * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PXE_BASE_CODE ) ,
                "::" , stringify ! ( SetStationIp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE ) ) . SetPackets as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PXE_BASE_CODE ) ,
                "::" , stringify ! ( SetPackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE ) ) . Mode as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PXE_BASE_CODE ) ,
                "::" , stringify ! ( Mode ) ));
}
impl Clone for _EFI_PXE_BASE_CODE {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub union EFI_IP_ADDRESS {
    pub Addr: [UINT32; 4usize],
    pub v4: EFI_IPv4_ADDRESS,
    pub v6: EFI_IPv6_ADDRESS,
}
#[test]
fn bindgen_test_layout_EFI_IP_ADDRESS() {
    assert_eq!(::core::mem::size_of::<EFI_IP_ADDRESS>() , 16usize , concat ! (
               "Size of: " , stringify ! ( EFI_IP_ADDRESS ) ));
    assert_eq! (::core::mem::align_of::<EFI_IP_ADDRESS>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( EFI_IP_ADDRESS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP_ADDRESS ) ) . Addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP_ADDRESS ) , "::"
                , stringify ! ( Addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP_ADDRESS ) ) . v4 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP_ADDRESS ) , "::"
                , stringify ! ( v4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP_ADDRESS ) ) . v6 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP_ADDRESS ) , "::"
                , stringify ! ( v6 ) ));
}
impl Clone for EFI_IP_ADDRESS {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_PXE_BASE_CODE_UDP_PORT = UINT16;
#[repr(C)]
pub struct EFI_PXE_BASE_CODE_DHCPV4_PACKET {
    pub BootpOpcode: UINT8,
    pub BootpHwType: UINT8,
    pub BootpHwAddrLen: UINT8,
    pub BootpGateHops: UINT8,
    pub BootpIdent: UINT32,
    pub BootpSeconds: UINT16,
    pub BootpFlags: UINT16,
    pub BootpCiAddr: [UINT8; 4usize],
    pub BootpYiAddr: [UINT8; 4usize],
    pub BootpSiAddr: [UINT8; 4usize],
    pub BootpGiAddr: [UINT8; 4usize],
    pub BootpHwAddr: [UINT8; 16usize],
    pub BootpSrvName: [UINT8; 64usize],
    pub BootpBootFile: [UINT8; 128usize],
    pub DhcpMagik: UINT32,
    pub DhcpOptions: [UINT8; 56usize],
}
#[test]
fn bindgen_test_layout_EFI_PXE_BASE_CODE_DHCPV4_PACKET() {
    assert_eq!(::core::mem::size_of::<EFI_PXE_BASE_CODE_DHCPV4_PACKET>() ,
               296usize , concat ! (
               "Size of: " , stringify ! ( EFI_PXE_BASE_CODE_DHCPV4_PACKET )
               ));
    assert_eq! (::core::mem::align_of::<EFI_PXE_BASE_CODE_DHCPV4_PACKET>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                BootpOpcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                BootpOpcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                BootpHwType as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                BootpHwType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                BootpHwAddrLen as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                BootpHwAddrLen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                BootpGateHops as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                BootpGateHops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                BootpIdent as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                BootpIdent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                BootpSeconds as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                BootpSeconds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                BootpFlags as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                BootpFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                BootpCiAddr as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                BootpCiAddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                BootpYiAddr as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                BootpYiAddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                BootpSiAddr as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                BootpSiAddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                BootpGiAddr as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                BootpGiAddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                BootpHwAddr as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                BootpHwAddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                BootpSrvName as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                BootpSrvName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                BootpBootFile as * const _ as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                BootpBootFile ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                DhcpMagik as * const _ as usize } , 236usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                DhcpMagik ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV4_PACKET ) ) .
                DhcpOptions as * const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV4_PACKET ) , "::" , stringify ! (
                DhcpOptions ) ));
}
#[repr(C)]
pub struct EFI_PXE_BASE_CODE_DHCPV6_PACKET {
    pub _bitfield_1: u32,
    pub DhcpOptions: [UINT8; 1024usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_EFI_PXE_BASE_CODE_DHCPV6_PACKET() {
    assert_eq!(::core::mem::size_of::<EFI_PXE_BASE_CODE_DHCPV6_PACKET>() ,
               1028usize , concat ! (
               "Size of: " , stringify ! ( EFI_PXE_BASE_CODE_DHCPV6_PACKET )
               ));
    assert_eq! (::core::mem::align_of::<EFI_PXE_BASE_CODE_DHCPV6_PACKET>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV6_PACKET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DHCPV6_PACKET ) ) .
                DhcpOptions as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DHCPV6_PACKET ) , "::" , stringify ! (
                DhcpOptions ) ));
}
impl EFI_PXE_BASE_CODE_DHCPV6_PACKET {
    #[inline]
    pub fn MessageType(&self) -> UINT32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_MessageType(&mut self, val: UINT32) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn TransactionId(&self) -> UINT32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 4294967040u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TransactionId(&mut self, val: UINT32) {
        let mask = 4294967040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub const fn new_bitfield_1(MessageType: UINT32, TransactionId: UINT32)
     -> u32 {
        ({
             ({ 0 } |
                  ((MessageType as u32 as u32) << 0usize) & (255u64 as u32))
         } |
             ((TransactionId as u32 as u32) << 8usize) &
                 (4294967040u64 as u32))
    }
}
#[repr(C)]
pub union EFI_PXE_BASE_CODE_PACKET {
    pub Raw: [UINT8; 1472usize],
    pub Dhcpv4: EFI_PXE_BASE_CODE_DHCPV4_PACKET,
    pub Dhcpv6: EFI_PXE_BASE_CODE_DHCPV6_PACKET,
}
#[test]
fn bindgen_test_layout_EFI_PXE_BASE_CODE_PACKET() {
    assert_eq!(::core::mem::size_of::<EFI_PXE_BASE_CODE_PACKET>() , 1472usize
               , concat ! (
               "Size of: " , stringify ! ( EFI_PXE_BASE_CODE_PACKET ) ));
    assert_eq! (::core::mem::align_of::<EFI_PXE_BASE_CODE_PACKET>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_PXE_BASE_CODE_PACKET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_PACKET ) ) . Raw as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_PACKET ) , "::" , stringify ! ( Raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_PACKET ) ) . Dhcpv4 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_PACKET ) , "::" , stringify ! ( Dhcpv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_PACKET ) ) . Dhcpv6 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_PACKET ) , "::" , stringify ! ( Dhcpv6 ) ));
}
#[repr(C)]
pub struct EFI_PXE_BASE_CODE_ICMP_ERROR {
    pub Type: UINT8,
    pub Code: UINT8,
    pub Checksum: UINT16,
    pub u: EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1,
    pub Data: [UINT8; 494usize],
}
#[repr(C)]

pub union EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1 {
    pub reserved: UINT32,
    pub Mtu: UINT32,
    pub Pointer: UINT32,
    pub Echo: EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]

pub struct EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1__bindgen_ty_1 {
    pub Identifier: UINT16,
    pub Sequence: UINT16,
}
#[test]
fn bindgen_test_layout_EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1__bindgen_ty_1 ) ) .
                Identifier as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( Identifier ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1__bindgen_ty_1 ) ) .
                Sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( Sequence ) ));
}
impl Clone for EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[test]
fn bindgen_test_layout_EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1 )
                ) . reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1 ) , "::" ,
                stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1 )
                ) . Mtu as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1 ) , "::" ,
                stringify ! ( Mtu ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1 )
                ) . Pointer as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1 ) , "::" ,
                stringify ! ( Pointer ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1 )
                ) . Echo as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1 ) , "::" ,
                stringify ! ( Echo ) ));
}
impl Clone for EFI_PXE_BASE_CODE_ICMP_ERROR__bindgen_ty_1 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[test]
fn bindgen_test_layout_EFI_PXE_BASE_CODE_ICMP_ERROR() {
    assert_eq!(::core::mem::size_of::<EFI_PXE_BASE_CODE_ICMP_ERROR>() ,
               504usize , concat ! (
               "Size of: " , stringify ! ( EFI_PXE_BASE_CODE_ICMP_ERROR ) ));
    assert_eq! (::core::mem::align_of::<EFI_PXE_BASE_CODE_ICMP_ERROR>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( EFI_PXE_BASE_CODE_ICMP_ERROR )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_ICMP_ERROR ) ) . Type
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ICMP_ERROR ) , "::" , stringify ! ( Type )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_ICMP_ERROR ) ) . Code
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ICMP_ERROR ) , "::" , stringify ! ( Code )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_ICMP_ERROR ) ) .
                Checksum as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ICMP_ERROR ) , "::" , stringify ! ( Checksum
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_ICMP_ERROR ) ) . u as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ICMP_ERROR ) , "::" , stringify ! ( u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_ICMP_ERROR ) ) . Data
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ICMP_ERROR ) , "::" , stringify ! ( Data )
                ));
}
#[repr(C)]
pub struct EFI_PXE_BASE_CODE_TFTP_ERROR {
    pub ErrorCode: UINT8,
    pub ErrorString: [CHAR8; 127usize],
}
#[test]
fn bindgen_test_layout_EFI_PXE_BASE_CODE_TFTP_ERROR() {
    assert_eq!(::core::mem::size_of::<EFI_PXE_BASE_CODE_TFTP_ERROR>() ,
               128usize , concat ! (
               "Size of: " , stringify ! ( EFI_PXE_BASE_CODE_TFTP_ERROR ) ));
    assert_eq! (::core::mem::align_of::<EFI_PXE_BASE_CODE_TFTP_ERROR>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( EFI_PXE_BASE_CODE_TFTP_ERROR )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_TFTP_ERROR ) ) .
                ErrorCode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_TFTP_ERROR ) , "::" , stringify ! (
                ErrorCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_TFTP_ERROR ) ) .
                ErrorString as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_TFTP_ERROR ) , "::" , stringify ! (
                ErrorString ) ));
}
#[repr(C)]

pub struct EFI_PXE_BASE_CODE_IP_FILTER {
    pub Filters: UINT8,
    pub IpCnt: UINT8,
    pub reserved: UINT16,
    pub IpList: [EFI_IP_ADDRESS; 8usize],
}
#[test]
fn bindgen_test_layout_EFI_PXE_BASE_CODE_IP_FILTER() {
    assert_eq!(::core::mem::size_of::<EFI_PXE_BASE_CODE_IP_FILTER>() ,
               132usize , concat ! (
               "Size of: " , stringify ! ( EFI_PXE_BASE_CODE_IP_FILTER ) ));
    assert_eq! (::core::mem::align_of::<EFI_PXE_BASE_CODE_IP_FILTER>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( EFI_PXE_BASE_CODE_IP_FILTER )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_IP_FILTER ) ) . Filters
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_IP_FILTER ) , "::" , stringify ! ( Filters )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_IP_FILTER ) ) . IpCnt
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_IP_FILTER ) , "::" , stringify ! ( IpCnt )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_IP_FILTER ) ) .
                reserved as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_IP_FILTER ) , "::" , stringify ! ( reserved
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_IP_FILTER ) ) . IpList
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_IP_FILTER ) , "::" , stringify ! ( IpList )
                ));
}
impl Clone for EFI_PXE_BASE_CODE_IP_FILTER {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_PXE_BASE_CODE_ARP_ENTRY {
    pub IpAddr: EFI_IP_ADDRESS,
    pub MacAddr: EFI_MAC_ADDRESS,
}
#[test]
fn bindgen_test_layout_EFI_PXE_BASE_CODE_ARP_ENTRY() {
    assert_eq!(::core::mem::size_of::<EFI_PXE_BASE_CODE_ARP_ENTRY>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( EFI_PXE_BASE_CODE_ARP_ENTRY ) ));
    assert_eq! (::core::mem::align_of::<EFI_PXE_BASE_CODE_ARP_ENTRY>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( EFI_PXE_BASE_CODE_ARP_ENTRY )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_ARP_ENTRY ) ) . IpAddr
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ARP_ENTRY ) , "::" , stringify ! ( IpAddr )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_ARP_ENTRY ) ) . MacAddr
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ARP_ENTRY ) , "::" , stringify ! ( MacAddr )
                ));
}
impl Clone for EFI_PXE_BASE_CODE_ARP_ENTRY {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_PXE_BASE_CODE_ROUTE_ENTRY {
    pub IpAddr: EFI_IP_ADDRESS,
    pub SubnetMask: EFI_IP_ADDRESS,
    pub GwAddr: EFI_IP_ADDRESS,
}
#[test]
fn bindgen_test_layout_EFI_PXE_BASE_CODE_ROUTE_ENTRY() {
    assert_eq!(::core::mem::size_of::<EFI_PXE_BASE_CODE_ROUTE_ENTRY>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( EFI_PXE_BASE_CODE_ROUTE_ENTRY ) ));
    assert_eq! (::core::mem::align_of::<EFI_PXE_BASE_CODE_ROUTE_ENTRY>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( EFI_PXE_BASE_CODE_ROUTE_ENTRY
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_ROUTE_ENTRY ) ) .
                IpAddr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ROUTE_ENTRY ) , "::" , stringify ! ( IpAddr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_ROUTE_ENTRY ) ) .
                SubnetMask as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ROUTE_ENTRY ) , "::" , stringify ! (
                SubnetMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_ROUTE_ENTRY ) ) .
                GwAddr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_ROUTE_ENTRY ) , "::" , stringify ! ( GwAddr
                ) ));
}
impl Clone for EFI_PXE_BASE_CODE_ROUTE_ENTRY {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_PXE_BASE_CODE_SRVLIST {
    pub Type: UINT16,
    pub AcceptAnyResponse: BOOLEAN,
    pub Reserved: UINT8,
    pub IpAddr: EFI_IP_ADDRESS,
}
#[test]
fn bindgen_test_layout_EFI_PXE_BASE_CODE_SRVLIST() {
    assert_eq!(::core::mem::size_of::<EFI_PXE_BASE_CODE_SRVLIST>() , 20usize ,
               concat ! (
               "Size of: " , stringify ! ( EFI_PXE_BASE_CODE_SRVLIST ) ));
    assert_eq! (::core::mem::align_of::<EFI_PXE_BASE_CODE_SRVLIST>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( EFI_PXE_BASE_CODE_SRVLIST )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_SRVLIST ) ) . Type as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_SRVLIST ) , "::" , stringify ! ( Type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_SRVLIST ) ) .
                AcceptAnyResponse as * const _ as usize } , 2usize , concat !
                (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_SRVLIST ) , "::" , stringify ! (
                AcceptAnyResponse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_SRVLIST ) ) . Reserved
                as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_SRVLIST ) , "::" , stringify ! ( Reserved )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_SRVLIST ) ) . IpAddr as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_SRVLIST ) , "::" , stringify ! ( IpAddr )
                ));
}
impl Clone for EFI_PXE_BASE_CODE_SRVLIST {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_PXE_BASE_CODE_DISCOVER_INFO {
    pub UseMCast: BOOLEAN,
    pub UseBCast: BOOLEAN,
    pub UseUCast: BOOLEAN,
    pub MustUseList: BOOLEAN,
    pub ServerMCastIp: EFI_IP_ADDRESS,
    pub IpCnt: UINT16,
    pub SrvList: [EFI_PXE_BASE_CODE_SRVLIST; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_PXE_BASE_CODE_DISCOVER_INFO() {
    assert_eq!(::core::mem::size_of::<EFI_PXE_BASE_CODE_DISCOVER_INFO>() ,
               44usize , concat ! (
               "Size of: " , stringify ! ( EFI_PXE_BASE_CODE_DISCOVER_INFO )
               ));
    assert_eq! (::core::mem::align_of::<EFI_PXE_BASE_CODE_DISCOVER_INFO>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_PXE_BASE_CODE_DISCOVER_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DISCOVER_INFO ) ) .
                UseMCast as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DISCOVER_INFO ) , "::" , stringify ! (
                UseMCast ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DISCOVER_INFO ) ) .
                UseBCast as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DISCOVER_INFO ) , "::" , stringify ! (
                UseBCast ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DISCOVER_INFO ) ) .
                UseUCast as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DISCOVER_INFO ) , "::" , stringify ! (
                UseUCast ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DISCOVER_INFO ) ) .
                MustUseList as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DISCOVER_INFO ) , "::" , stringify ! (
                MustUseList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DISCOVER_INFO ) ) .
                ServerMCastIp as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DISCOVER_INFO ) , "::" , stringify ! (
                ServerMCastIp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DISCOVER_INFO ) ) .
                IpCnt as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DISCOVER_INFO ) , "::" , stringify ! ( IpCnt
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_DISCOVER_INFO ) ) .
                SrvList as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_DISCOVER_INFO ) , "::" , stringify ! (
                SrvList ) ));
}
impl Clone for EFI_PXE_BASE_CODE_DISCOVER_INFO {
    fn clone(&self) -> Self { unimplemented!() }
}
pub const EFI_PXE_BASE_CODE_TFTP_OPCODE_EFI_PXE_BASE_CODE_TFTP_FIRST:
          EFI_PXE_BASE_CODE_TFTP_OPCODE =
    0;
pub const EFI_PXE_BASE_CODE_TFTP_OPCODE_EFI_PXE_BASE_CODE_TFTP_GET_FILE_SIZE:
          EFI_PXE_BASE_CODE_TFTP_OPCODE =
    1;
pub const EFI_PXE_BASE_CODE_TFTP_OPCODE_EFI_PXE_BASE_CODE_TFTP_READ_FILE:
          EFI_PXE_BASE_CODE_TFTP_OPCODE =
    2;
pub const EFI_PXE_BASE_CODE_TFTP_OPCODE_EFI_PXE_BASE_CODE_TFTP_WRITE_FILE:
          EFI_PXE_BASE_CODE_TFTP_OPCODE =
    3;
pub const EFI_PXE_BASE_CODE_TFTP_OPCODE_EFI_PXE_BASE_CODE_TFTP_READ_DIRECTORY:
          EFI_PXE_BASE_CODE_TFTP_OPCODE =
    4;
pub const EFI_PXE_BASE_CODE_TFTP_OPCODE_EFI_PXE_BASE_CODE_MTFTP_GET_FILE_SIZE:
          EFI_PXE_BASE_CODE_TFTP_OPCODE =
    5;
pub const EFI_PXE_BASE_CODE_TFTP_OPCODE_EFI_PXE_BASE_CODE_MTFTP_READ_FILE:
          EFI_PXE_BASE_CODE_TFTP_OPCODE =
    6;
pub const EFI_PXE_BASE_CODE_TFTP_OPCODE_EFI_PXE_BASE_CODE_MTFTP_READ_DIRECTORY:
          EFI_PXE_BASE_CODE_TFTP_OPCODE =
    7;
pub const EFI_PXE_BASE_CODE_TFTP_OPCODE_EFI_PXE_BASE_CODE_MTFTP_LAST:
          EFI_PXE_BASE_CODE_TFTP_OPCODE =
    8;
pub type EFI_PXE_BASE_CODE_TFTP_OPCODE = ::ctypes::c_uint;
#[repr(C)]

pub struct EFI_PXE_BASE_CODE_MTFTP_INFO {
    pub MCastIp: EFI_IP_ADDRESS,
    pub CPort: EFI_PXE_BASE_CODE_UDP_PORT,
    pub SPort: EFI_PXE_BASE_CODE_UDP_PORT,
    pub ListenTimeout: UINT16,
    pub TransmitTimeout: UINT16,
}
#[test]
fn bindgen_test_layout_EFI_PXE_BASE_CODE_MTFTP_INFO() {
    assert_eq!(::core::mem::size_of::<EFI_PXE_BASE_CODE_MTFTP_INFO>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( EFI_PXE_BASE_CODE_MTFTP_INFO ) ));
    assert_eq! (::core::mem::align_of::<EFI_PXE_BASE_CODE_MTFTP_INFO>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( EFI_PXE_BASE_CODE_MTFTP_INFO )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MTFTP_INFO ) ) .
                MCastIp as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_MTFTP_INFO ) , "::" , stringify ! ( MCastIp
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MTFTP_INFO ) ) . CPort
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_MTFTP_INFO ) , "::" , stringify ! ( CPort )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MTFTP_INFO ) ) . SPort
                as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_MTFTP_INFO ) , "::" , stringify ! ( SPort )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MTFTP_INFO ) ) .
                ListenTimeout as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_MTFTP_INFO ) , "::" , stringify ! (
                ListenTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MTFTP_INFO ) ) .
                TransmitTimeout as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_PXE_BASE_CODE_MTFTP_INFO ) , "::" , stringify ! (
                TransmitTimeout ) ));
}
impl Clone for EFI_PXE_BASE_CODE_MTFTP_INFO {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]
pub struct EFI_PXE_BASE_CODE_MODE {
    pub Started: BOOLEAN,
    pub Ipv6Available: BOOLEAN,
    pub Ipv6Supported: BOOLEAN,
    pub UsingIpv6: BOOLEAN,
    pub BisSupported: BOOLEAN,
    pub BisDetected: BOOLEAN,
    pub AutoArp: BOOLEAN,
    pub SendGUID: BOOLEAN,
    pub DhcpDiscoverValid: BOOLEAN,
    pub DhcpAckReceived: BOOLEAN,
    pub ProxyOfferReceived: BOOLEAN,
    pub PxeDiscoverValid: BOOLEAN,
    pub PxeReplyReceived: BOOLEAN,
    pub PxeBisReplyReceived: BOOLEAN,
    pub IcmpErrorReceived: BOOLEAN,
    pub TftpErrorReceived: BOOLEAN,
    pub MakeCallbacks: BOOLEAN,
    pub TTL: UINT8,
    pub ToS: UINT8,
    pub StationIp: EFI_IP_ADDRESS,
    pub SubnetMask: EFI_IP_ADDRESS,
    pub DhcpDiscover: EFI_PXE_BASE_CODE_PACKET,
    pub DhcpAck: EFI_PXE_BASE_CODE_PACKET,
    pub ProxyOffer: EFI_PXE_BASE_CODE_PACKET,
    pub PxeDiscover: EFI_PXE_BASE_CODE_PACKET,
    pub PxeReply: EFI_PXE_BASE_CODE_PACKET,
    pub PxeBisReply: EFI_PXE_BASE_CODE_PACKET,
    pub IpFilter: EFI_PXE_BASE_CODE_IP_FILTER,
    pub ArpCacheEntries: UINT32,
    pub ArpCache: [EFI_PXE_BASE_CODE_ARP_ENTRY; 8usize],
    pub RouteTableEntries: UINT32,
    pub RouteTable: [EFI_PXE_BASE_CODE_ROUTE_ENTRY; 8usize],
    pub IcmpError: EFI_PXE_BASE_CODE_ICMP_ERROR,
    pub TftpError: EFI_PXE_BASE_CODE_TFTP_ERROR,
}
#[test]
fn bindgen_test_layout_EFI_PXE_BASE_CODE_MODE() {
    assert_eq!(::core::mem::size_of::<EFI_PXE_BASE_CODE_MODE>() , 10424usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_PXE_BASE_CODE_MODE )
               ));
    assert_eq! (::core::mem::align_of::<EFI_PXE_BASE_CODE_MODE>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_PXE_BASE_CODE_MODE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . Started as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( Started ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) .
                Ipv6Available as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( Ipv6Available ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) .
                Ipv6Supported as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( Ipv6Supported ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . UsingIpv6 as
                * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( UsingIpv6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . BisSupported
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( BisSupported ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . BisDetected
                as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( BisDetected ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . AutoArp as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( AutoArp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . SendGUID as
                * const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( SendGUID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) .
                DhcpDiscoverValid as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( DhcpDiscoverValid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) .
                DhcpAckReceived as * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( DhcpAckReceived ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) .
                ProxyOfferReceived as * const _ as usize } , 10usize , concat
                ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( ProxyOfferReceived ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) .
                PxeDiscoverValid as * const _ as usize } , 11usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( PxeDiscoverValid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) .
                PxeReplyReceived as * const _ as usize } , 12usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( PxeReplyReceived ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) .
                PxeBisReplyReceived as * const _ as usize } , 13usize , concat
                ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( PxeBisReplyReceived ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) .
                IcmpErrorReceived as * const _ as usize } , 14usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( IcmpErrorReceived ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) .
                TftpErrorReceived as * const _ as usize } , 15usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( TftpErrorReceived ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) .
                MakeCallbacks as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( MakeCallbacks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . TTL as *
                const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( TTL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . ToS as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( ToS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . StationIp as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( StationIp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . SubnetMask
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( SubnetMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . DhcpDiscover
                as * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( DhcpDiscover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . DhcpAck as *
                const _ as usize } , 1524usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( DhcpAck ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . ProxyOffer
                as * const _ as usize } , 2996usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( ProxyOffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . PxeDiscover
                as * const _ as usize } , 4468usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( PxeDiscover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . PxeReply as
                * const _ as usize } , 5940usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( PxeReply ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . PxeBisReply
                as * const _ as usize } , 7412usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( PxeBisReply ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . IpFilter as
                * const _ as usize } , 8884usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( IpFilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) .
                ArpCacheEntries as * const _ as usize } , 9016usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( ArpCacheEntries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . ArpCache as
                * const _ as usize } , 9020usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( ArpCache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) .
                RouteTableEntries as * const _ as usize } , 9404usize , concat
                ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( RouteTableEntries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . RouteTable
                as * const _ as usize } , 9408usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( RouteTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . IcmpError as
                * const _ as usize } , 9792usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( IcmpError ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_PXE_BASE_CODE_MODE ) ) . TftpError as
                * const _ as usize } , 10296usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_PXE_BASE_CODE_MODE
                ) , "::" , stringify ! ( TftpError ) ));
}
pub type EFI_PXE_BASE_CODE_START =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PXE_BASE_CODE,
                                                UseIpv6: BOOLEAN)
                               -> EFI_STATUS>;
pub type EFI_PXE_BASE_CODE_STOP =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PXE_BASE_CODE)
                               -> EFI_STATUS>;
pub type EFI_PXE_BASE_CODE_DHCP =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PXE_BASE_CODE,
                                                SortOffers: BOOLEAN)
                               -> EFI_STATUS>;
pub type EFI_PXE_BASE_CODE_DISCOVER =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PXE_BASE_CODE,
                                                Type: UINT16,
                                                Layer: *mut UINT16,
                                                UseBis: BOOLEAN,
                                                Info:
                                                    *mut EFI_PXE_BASE_CODE_DISCOVER_INFO)
                               -> EFI_STATUS>;
pub type EFI_PXE_BASE_CODE_MTFTP =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PXE_BASE_CODE,
                                                Operation:
                                                    EFI_PXE_BASE_CODE_TFTP_OPCODE,
                                                BufferPtr:
                                                    *mut ::ctypes::c_void,
                                                Overwrite: BOOLEAN,
                                                BufferSize: *mut UINT64,
                                                BlockSize: *mut UINTN,
                                                ServerIp: *mut EFI_IP_ADDRESS,
                                                Filename: *mut UINT8,
                                                Info:
                                                    *mut EFI_PXE_BASE_CODE_MTFTP_INFO,
                                                DontUseBuffer: BOOLEAN)
                               -> EFI_STATUS>;
pub type EFI_PXE_BASE_CODE_UDP_WRITE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PXE_BASE_CODE,
                                                OpFlags: UINT16,
                                                DestIp: *mut EFI_IP_ADDRESS,
                                                DestPort:
                                                    *mut EFI_PXE_BASE_CODE_UDP_PORT,
                                                GatewayIp:
                                                    *mut EFI_IP_ADDRESS,
                                                SrcIp: *mut EFI_IP_ADDRESS,
                                                SrcPort:
                                                    *mut EFI_PXE_BASE_CODE_UDP_PORT,
                                                HeaderSize: *mut UINTN,
                                                HeaderPtr:
                                                    *mut ::ctypes::c_void,
                                                BufferSize: *mut UINTN,
                                                BufferPtr:
                                                    *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_PXE_BASE_CODE_UDP_READ =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PXE_BASE_CODE,
                                                OpFlags: UINT16,
                                                DestIp: *mut EFI_IP_ADDRESS,
                                                DestPort:
                                                    *mut EFI_PXE_BASE_CODE_UDP_PORT,
                                                SrcIp: *mut EFI_IP_ADDRESS,
                                                SrcPort:
                                                    *mut EFI_PXE_BASE_CODE_UDP_PORT,
                                                HeaderSize: *mut UINTN,
                                                HeaderPtr:
                                                    *mut ::ctypes::c_void,
                                                BufferSize: *mut UINTN,
                                                BufferPtr:
                                                    *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_PXE_BASE_CODE_SET_IP_FILTER =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PXE_BASE_CODE,
                                                NewFilter:
                                                    *mut EFI_PXE_BASE_CODE_IP_FILTER)
                               -> EFI_STATUS>;
pub type EFI_PXE_BASE_CODE_ARP =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PXE_BASE_CODE,
                                                IpAddr: *mut EFI_IP_ADDRESS,
                                                MacAddr: *mut EFI_MAC_ADDRESS)
                               -> EFI_STATUS>;
pub type EFI_PXE_BASE_CODE_SET_PARAMETERS =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PXE_BASE_CODE,
                                                NewAutoArp: *mut BOOLEAN,
                                                NewSendGUID: *mut BOOLEAN,
                                                NewTTL: *mut UINT8,
                                                NewToS: *mut UINT8,
                                                NewMakeCallback: *mut BOOLEAN)
                               -> EFI_STATUS>;
pub type EFI_PXE_BASE_CODE_SET_STATION_IP =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PXE_BASE_CODE,
                                                NewStationIp:
                                                    *mut EFI_IP_ADDRESS,
                                                NewSubnetMask:
                                                    *mut EFI_IP_ADDRESS)
                               -> EFI_STATUS>;
pub type EFI_PXE_BASE_CODE_SET_PACKETS =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_PXE_BASE_CODE,
                                                NewDhcpDiscoverValid:
                                                    *mut BOOLEAN,
                                                NewDhcpAckReceived:
                                                    *mut BOOLEAN,
                                                NewProxyOfferReceived:
                                                    *mut BOOLEAN,
                                                NewPxeDiscoverValid:
                                                    *mut BOOLEAN,
                                                NewPxeReplyReceived:
                                                    *mut BOOLEAN,
                                                NewPxeBisReplyReceived:
                                                    *mut BOOLEAN,
                                                NewDhcpDiscover:
                                                    *mut EFI_PXE_BASE_CODE_PACKET,
                                                NewDhcpAck:
                                                    *mut EFI_PXE_BASE_CODE_PACKET,
                                                NewProxyOffer:
                                                    *mut EFI_PXE_BASE_CODE_PACKET,
                                                NewPxeDiscover:
                                                    *mut EFI_PXE_BASE_CODE_PACKET,
                                                NewPxeReply:
                                                    *mut EFI_PXE_BASE_CODE_PACKET,
                                                NewPxeBisReply:
                                                    *mut EFI_PXE_BASE_CODE_PACKET)
                               -> EFI_STATUS>;
pub type EFI_PXE_BASE_CODE = _EFI_PXE_BASE_CODE;
#[repr(C)]

pub struct _EFI_PXE_BASE_CODE_CALLBACK {
    pub Revision: UINT64,
    pub Callback: EFI_PXE_CALLBACK,
}
#[test]
fn bindgen_test_layout__EFI_PXE_BASE_CODE_CALLBACK() {
    assert_eq!(::core::mem::size_of::<_EFI_PXE_BASE_CODE_CALLBACK>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _EFI_PXE_BASE_CODE_CALLBACK ) ));
    assert_eq! (::core::mem::align_of::<_EFI_PXE_BASE_CODE_CALLBACK>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _EFI_PXE_BASE_CODE_CALLBACK )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE_CALLBACK ) ) .
                Revision as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_PXE_BASE_CODE_CALLBACK ) , "::" , stringify ! ( Revision
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PXE_BASE_CODE_CALLBACK ) ) .
                Callback as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_PXE_BASE_CODE_CALLBACK ) , "::" , stringify ! ( Callback
                ) ));
}
impl Clone for _EFI_PXE_BASE_CODE_CALLBACK {
    fn clone(&self) -> Self { unimplemented!() }
}
pub const EFI_PXE_BASE_CODE_FUNCTION_EFI_PXE_BASE_CODE_FUNCTION_FIRST:
          EFI_PXE_BASE_CODE_FUNCTION =
    0;
pub const EFI_PXE_BASE_CODE_FUNCTION_EFI_PXE_BASE_CODE_FUNCTION_DHCP:
          EFI_PXE_BASE_CODE_FUNCTION =
    1;
pub const EFI_PXE_BASE_CODE_FUNCTION_EFI_PXE_BASE_CODE_FUNCTION_DISCOVER:
          EFI_PXE_BASE_CODE_FUNCTION =
    2;
pub const EFI_PXE_BASE_CODE_FUNCTION_EFI_PXE_BASE_CODE_FUNCTION_MTFTP:
          EFI_PXE_BASE_CODE_FUNCTION =
    3;
pub const EFI_PXE_BASE_CODE_FUNCTION_EFI_PXE_BASE_CODE_FUNCTION_UDP_WRITE:
          EFI_PXE_BASE_CODE_FUNCTION =
    4;
pub const EFI_PXE_BASE_CODE_FUNCTION_EFI_PXE_BASE_CODE_FUNCTION_UDP_READ:
          EFI_PXE_BASE_CODE_FUNCTION =
    5;
pub const EFI_PXE_BASE_CODE_FUNCTION_EFI_PXE_BASE_CODE_FUNCTION_ARP:
          EFI_PXE_BASE_CODE_FUNCTION =
    6;
pub const EFI_PXE_BASE_CODE_FUNCTION_EFI_PXE_BASE_CODE_FUNCTION_IGMP:
          EFI_PXE_BASE_CODE_FUNCTION =
    7;
pub const EFI_PXE_BASE_CODE_FUNCTION_EFI_PXE_BASE_CODE_PXE_FUNCTION_LAST:
          EFI_PXE_BASE_CODE_FUNCTION =
    8;
pub type EFI_PXE_BASE_CODE_FUNCTION = ::ctypes::c_uint;
pub const EFI_PXE_BASE_CODE_CALLBACK_STATUS_EFI_PXE_BASE_CODE_CALLBACK_STATUS_FIRST:
          EFI_PXE_BASE_CODE_CALLBACK_STATUS =
    0;
pub const EFI_PXE_BASE_CODE_CALLBACK_STATUS_EFI_PXE_BASE_CODE_CALLBACK_STATUS_CONTINUE:
          EFI_PXE_BASE_CODE_CALLBACK_STATUS =
    1;
pub const EFI_PXE_BASE_CODE_CALLBACK_STATUS_EFI_PXE_BASE_CODE_CALLBACK_STATUS_ABORT:
          EFI_PXE_BASE_CODE_CALLBACK_STATUS =
    2;
pub const EFI_PXE_BASE_CODE_CALLBACK_STATUS_EFI_PXE_BASE_CODE_CALLBACK_STATUS_LAST:
          EFI_PXE_BASE_CODE_CALLBACK_STATUS =
    3;
pub type EFI_PXE_BASE_CODE_CALLBACK_STATUS = ::ctypes::c_uint;
pub type EFI_PXE_CALLBACK =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_PXE_BASE_CODE_CALLBACK,
                                                Function:
                                                    EFI_PXE_BASE_CODE_FUNCTION,
                                                Received: BOOLEAN,
                                                PacketLen: UINT32,
                                                Packet:
                                                    *mut EFI_PXE_BASE_CODE_PACKET)
                               -> EFI_PXE_BASE_CODE_CALLBACK_STATUS>;
pub type EFI_PXE_BASE_CODE_CALLBACK = _EFI_PXE_BASE_CODE_CALLBACK;
#[repr(C)]

pub struct _EFI_SIMPLE_NETWORK {
    pub Revision: UINT64,
    pub Start: EFI_SIMPLE_NETWORK_START,
    pub Stop: EFI_SIMPLE_NETWORK_STOP,
    pub Initialize: EFI_SIMPLE_NETWORK_INITIALIZE,
    pub Reset: EFI_SIMPLE_NETWORK_RESET,
    pub Shutdown: EFI_SIMPLE_NETWORK_SHUTDOWN,
    pub ReceiveFilters: EFI_SIMPLE_NETWORK_RECEIVE_FILTERS,
    pub StationAddress: EFI_SIMPLE_NETWORK_STATION_ADDRESS,
    pub Statistics: EFI_SIMPLE_NETWORK_STATISTICS,
    pub MCastIpToMac: EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC,
    pub NvData: EFI_SIMPLE_NETWORK_NVDATA,
    pub GetStatus: EFI_SIMPLE_NETWORK_GET_STATUS,
    pub Transmit: EFI_SIMPLE_NETWORK_TRANSMIT,
    pub Receive: EFI_SIMPLE_NETWORK_RECEIVE,
    pub WaitForPacket: EFI_EVENT,
    pub Mode: *mut EFI_SIMPLE_NETWORK_MODE,
}
#[test]
fn bindgen_test_layout__EFI_SIMPLE_NETWORK() {
    assert_eq!(::core::mem::size_of::<_EFI_SIMPLE_NETWORK>() , 128usize ,
               concat ! ( "Size of: " , stringify ! ( _EFI_SIMPLE_NETWORK )
               ));
    assert_eq! (::core::mem::align_of::<_EFI_SIMPLE_NETWORK>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _EFI_SIMPLE_NETWORK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . Revision as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( Revision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . Start as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( Start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . Stop as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( Stop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . Initialize as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( Initialize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . Reset as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( Reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . Shutdown as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( Shutdown ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . ReceiveFilters
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( ReceiveFilters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . StationAddress
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( StationAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . Statistics as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( Statistics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . MCastIpToMac as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( MCastIpToMac ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . NvData as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( NvData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . GetStatus as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( GetStatus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . Transmit as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( Transmit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . Receive as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( Receive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . WaitForPacket
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( WaitForPacket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_NETWORK ) ) . Mode as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_NETWORK ) ,
                "::" , stringify ! ( Mode ) ));
}
impl Clone for _EFI_SIMPLE_NETWORK {
    fn clone(&self) -> Self { unimplemented!() }
}
///////////////////////////////////////////////////////////////////////////////
#[repr(C)]

pub struct EFI_NETWORK_STATISTICS {
    pub RxTotalFrames: UINT64,
    pub RxGoodFrames: UINT64,
    pub RxUndersizeFrames: UINT64,
    pub RxOversizeFrames: UINT64,
    pub RxDroppedFrames: UINT64,
    pub RxUnicastFrames: UINT64,
    pub RxBroadcastFrames: UINT64,
    pub RxMulticastFrames: UINT64,
    pub RxCrcErrorFrames: UINT64,
    pub RxTotalBytes: UINT64,
    pub TxTotalFrames: UINT64,
    pub TxGoodFrames: UINT64,
    pub TxUndersizeFrames: UINT64,
    pub TxOversizeFrames: UINT64,
    pub TxDroppedFrames: UINT64,
    pub TxUnicastFrames: UINT64,
    pub TxBroadcastFrames: UINT64,
    pub TxMulticastFrames: UINT64,
    pub TxCrcErrorFrames: UINT64,
    pub TxTotalBytes: UINT64,
    pub Collisions: UINT64,
    pub UnsupportedProtocol: UINT64,
}
#[test]
fn bindgen_test_layout_EFI_NETWORK_STATISTICS() {
    assert_eq!(::core::mem::size_of::<EFI_NETWORK_STATISTICS>() , 176usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_NETWORK_STATISTICS )
               ));
    assert_eq! (::core::mem::align_of::<EFI_NETWORK_STATISTICS>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_NETWORK_STATISTICS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                RxTotalFrames as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( RxTotalFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) . RxGoodFrames
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( RxGoodFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                RxUndersizeFrames as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( RxUndersizeFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                RxOversizeFrames as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( RxOversizeFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                RxDroppedFrames as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( RxDroppedFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                RxUnicastFrames as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( RxUnicastFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                RxBroadcastFrames as * const _ as usize } , 48usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( RxBroadcastFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                RxMulticastFrames as * const _ as usize } , 56usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( RxMulticastFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                RxCrcErrorFrames as * const _ as usize } , 64usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( RxCrcErrorFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) . RxTotalBytes
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( RxTotalBytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                TxTotalFrames as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( TxTotalFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) . TxGoodFrames
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( TxGoodFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                TxUndersizeFrames as * const _ as usize } , 96usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( TxUndersizeFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                TxOversizeFrames as * const _ as usize } , 104usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( TxOversizeFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                TxDroppedFrames as * const _ as usize } , 112usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( TxDroppedFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                TxUnicastFrames as * const _ as usize } , 120usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( TxUnicastFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                TxBroadcastFrames as * const _ as usize } , 128usize , concat
                ! (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( TxBroadcastFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                TxMulticastFrames as * const _ as usize } , 136usize , concat
                ! (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( TxMulticastFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                TxCrcErrorFrames as * const _ as usize } , 144usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( TxCrcErrorFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) . TxTotalBytes
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( TxTotalBytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) . Collisions
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( Collisions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_NETWORK_STATISTICS ) ) .
                UnsupportedProtocol as * const _ as usize } , 168usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( EFI_NETWORK_STATISTICS
                ) , "::" , stringify ! ( UnsupportedProtocol ) ));
}
impl Clone for EFI_NETWORK_STATISTICS {
    fn clone(&self) -> Self { unimplemented!() }
}
pub const EFI_SIMPLE_NETWORK_STATE_EfiSimpleNetworkStopped:
          EFI_SIMPLE_NETWORK_STATE =
    0;
pub const EFI_SIMPLE_NETWORK_STATE_EfiSimpleNetworkStarted:
          EFI_SIMPLE_NETWORK_STATE =
    1;
pub const EFI_SIMPLE_NETWORK_STATE_EfiSimpleNetworkInitialized:
          EFI_SIMPLE_NETWORK_STATE =
    2;
pub const EFI_SIMPLE_NETWORK_STATE_EfiSimpleNetworkMaxState:
          EFI_SIMPLE_NETWORK_STATE =
    3;
///////////////////////////////////////////////////////////////////////////////
pub type EFI_SIMPLE_NETWORK_STATE = ::ctypes::c_uint;
#[repr(C)]

pub struct EFI_SIMPLE_NETWORK_MODE {
    pub State: UINT32,
    pub HwAddressSize: UINT32,
    pub MediaHeaderSize: UINT32,
    pub MaxPacketSize: UINT32,
    pub NvRamSize: UINT32,
    pub NvRamAccessSize: UINT32,
    pub ReceiveFilterMask: UINT32,
    pub ReceiveFilterSetting: UINT32,
    pub MaxMCastFilterCount: UINT32,
    pub MCastFilterCount: UINT32,
    pub MCastFilter: [EFI_MAC_ADDRESS; 16usize],
    pub CurrentAddress: EFI_MAC_ADDRESS,
    pub BroadcastAddress: EFI_MAC_ADDRESS,
    pub PermanentAddress: EFI_MAC_ADDRESS,
    pub IfType: UINT8,
    pub MacAddressChangeable: BOOLEAN,
    pub MultipleTxSupported: BOOLEAN,
    pub MediaPresentSupported: BOOLEAN,
    pub MediaPresent: BOOLEAN,
}
#[test]
fn bindgen_test_layout_EFI_SIMPLE_NETWORK_MODE() {
    assert_eq!(::core::mem::size_of::<EFI_SIMPLE_NETWORK_MODE>() , 656usize ,
               concat ! (
               "Size of: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE ) ));
    assert_eq! (::core::mem::align_of::<EFI_SIMPLE_NETWORK_MODE>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_SIMPLE_NETWORK_MODE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) . State as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( State ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                HwAddressSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( HwAddressSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                MediaHeaderSize as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( MediaHeaderSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                MaxPacketSize as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( MaxPacketSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) . NvRamSize
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( NvRamSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                NvRamAccessSize as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( NvRamAccessSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                ReceiveFilterMask as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( ReceiveFilterMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                ReceiveFilterSetting as * const _ as usize } , 28usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( ReceiveFilterSetting ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                MaxMCastFilterCount as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( MaxMCastFilterCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                MCastFilterCount as * const _ as usize } , 36usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( MCastFilterCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) . MCastFilter
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( MCastFilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                CurrentAddress as * const _ as usize } , 552usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( CurrentAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                BroadcastAddress as * const _ as usize } , 584usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( BroadcastAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                PermanentAddress as * const _ as usize } , 616usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( PermanentAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) . IfType as *
                const _ as usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( IfType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                MacAddressChangeable as * const _ as usize } , 649usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( MacAddressChangeable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                MultipleTxSupported as * const _ as usize } , 650usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( MultipleTxSupported ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                MediaPresentSupported as * const _ as usize } , 651usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( MediaPresentSupported ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_NETWORK_MODE ) ) .
                MediaPresent as * const _ as usize } , 652usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_NETWORK_MODE
                ) , "::" , stringify ! ( MediaPresent ) ));
}
impl Clone for EFI_SIMPLE_NETWORK_MODE {
    fn clone(&self) -> Self { unimplemented!() }
}
///////////////////////////////////////////////////////////////////////////////
pub type EFI_SIMPLE_NETWORK_START =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_NETWORK)
                               -> EFI_STATUS>;
///////////////////////////////////////////////////////////////////////////////
pub type EFI_SIMPLE_NETWORK_STOP =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_NETWORK)
                               -> EFI_STATUS>;
///////////////////////////////////////////////////////////////////////////////
pub type EFI_SIMPLE_NETWORK_INITIALIZE =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_NETWORK,
                                                ExtraRxBufferSize: UINTN,
                                                ExtraTxBufferSize: UINTN)
                               -> EFI_STATUS>;
///////////////////////////////////////////////////////////////////////////////
pub type EFI_SIMPLE_NETWORK_RESET =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_NETWORK,
                                                ExtendedVerification: BOOLEAN)
                               -> EFI_STATUS>;
///////////////////////////////////////////////////////////////////////////////
pub type EFI_SIMPLE_NETWORK_SHUTDOWN =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_NETWORK)
                               -> EFI_STATUS>;
///////////////////////////////////////////////////////////////////////////////
pub type EFI_SIMPLE_NETWORK_RECEIVE_FILTERS =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_NETWORK,
                                                Enable: UINT32,
                                                Disable: UINT32,
                                                ResetMCastFilter: BOOLEAN,
                                                MCastFilterCnt: UINTN,
                                                MCastFilter:
                                                    *mut EFI_MAC_ADDRESS)
                               -> EFI_STATUS>;
///////////////////////////////////////////////////////////////////////////////
pub type EFI_SIMPLE_NETWORK_STATION_ADDRESS =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_NETWORK,
                                                Reset: BOOLEAN,
                                                New: *mut EFI_MAC_ADDRESS)
                               -> EFI_STATUS>;
///////////////////////////////////////////////////////////////////////////////
pub type EFI_SIMPLE_NETWORK_STATISTICS =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_NETWORK,
                                                Reset: BOOLEAN,
                                                StatisticsSize: *mut UINTN,
                                                StatisticsTable:
                                                    *mut EFI_NETWORK_STATISTICS)
                               -> EFI_STATUS>;
///////////////////////////////////////////////////////////////////////////////
pub type EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_NETWORK,
                                                IPv6: BOOLEAN,
                                                IP: *mut EFI_IP_ADDRESS,
                                                MAC: *mut EFI_MAC_ADDRESS)
                               -> EFI_STATUS>;
///////////////////////////////////////////////////////////////////////////////
pub type EFI_SIMPLE_NETWORK_NVDATA =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_NETWORK,
                                                ReadWrite: BOOLEAN,
                                                Offset: UINTN,
                                                BufferSize: UINTN,
                                                Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
///////////////////////////////////////////////////////////////////////////////
pub type EFI_SIMPLE_NETWORK_GET_STATUS =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_NETWORK,
                                                InterruptStatus: *mut UINT32,
                                                TxBuf:
                                                    *mut *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
///////////////////////////////////////////////////////////////////////////////
pub type EFI_SIMPLE_NETWORK_TRANSMIT =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_NETWORK,
                                                HeaderSize: UINTN,
                                                BufferSize: UINTN,
                                                Buffer: *mut ::ctypes::c_void,
                                                SrcAddr: *mut EFI_MAC_ADDRESS,
                                                DestAddr:
                                                    *mut EFI_MAC_ADDRESS,
                                                Protocol: *mut UINT16)
                               -> EFI_STATUS>;
///////////////////////////////////////////////////////////////////////////////
pub type EFI_SIMPLE_NETWORK_RECEIVE =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_NETWORK,
                                                HeaderSize: *mut UINTN,
                                                BufferSize: *mut UINTN,
                                                Buffer: *mut ::ctypes::c_void,
                                                SrcAddr: *mut EFI_MAC_ADDRESS,
                                                DestAddr:
                                                    *mut EFI_MAC_ADDRESS,
                                                Protocol: *mut UINT16)
                               -> EFI_STATUS>;
pub type EFI_SIMPLE_NETWORK = _EFI_SIMPLE_NETWORK;
#[repr(C)]

pub struct _EFI_SYSTEM_TABLE {
    pub Hdr: EFI_TABLE_HEADER,
    pub FirmwareVendor: *mut CHAR16,
    pub FirmwareRevision: UINT32,
    pub ConsoleInHandle: EFI_HANDLE,
    pub ConIn: *mut SIMPLE_INPUT_INTERFACE,
    pub ConsoleOutHandle: EFI_HANDLE,
    pub ConOut: *mut SIMPLE_TEXT_OUTPUT_INTERFACE,
    pub StandardErrorHandle: EFI_HANDLE,
    pub StdErr: *mut SIMPLE_TEXT_OUTPUT_INTERFACE,
    pub RuntimeServices: *mut EFI_RUNTIME_SERVICES,
    pub BootServices: *mut EFI_BOOT_SERVICES,
    pub NumberOfTableEntries: UINTN,
    pub ConfigurationTable: *mut EFI_CONFIGURATION_TABLE,
}
#[test]
fn bindgen_test_layout__EFI_SYSTEM_TABLE() {
    assert_eq!(::core::mem::size_of::<_EFI_SYSTEM_TABLE>() , 120usize , concat
               ! ( "Size of: " , stringify ! ( _EFI_SYSTEM_TABLE ) ));
    assert_eq! (::core::mem::align_of::<_EFI_SYSTEM_TABLE>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _EFI_SYSTEM_TABLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SYSTEM_TABLE ) ) . Hdr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SYSTEM_TABLE ) ,
                "::" , stringify ! ( Hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SYSTEM_TABLE ) ) . FirmwareVendor as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SYSTEM_TABLE ) ,
                "::" , stringify ! ( FirmwareVendor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SYSTEM_TABLE ) ) . FirmwareRevision
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SYSTEM_TABLE ) ,
                "::" , stringify ! ( FirmwareRevision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SYSTEM_TABLE ) ) . ConsoleInHandle
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SYSTEM_TABLE ) ,
                "::" , stringify ! ( ConsoleInHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SYSTEM_TABLE ) ) . ConIn as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SYSTEM_TABLE ) ,
                "::" , stringify ! ( ConIn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SYSTEM_TABLE ) ) . ConsoleOutHandle
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SYSTEM_TABLE ) ,
                "::" , stringify ! ( ConsoleOutHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SYSTEM_TABLE ) ) . ConOut as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SYSTEM_TABLE ) ,
                "::" , stringify ! ( ConOut ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SYSTEM_TABLE ) ) .
                StandardErrorHandle as * const _ as usize } , 72usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _EFI_SYSTEM_TABLE ) ,
                "::" , stringify ! ( StandardErrorHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SYSTEM_TABLE ) ) . StdErr as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SYSTEM_TABLE ) ,
                "::" , stringify ! ( StdErr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SYSTEM_TABLE ) ) . RuntimeServices
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SYSTEM_TABLE ) ,
                "::" , stringify ! ( RuntimeServices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SYSTEM_TABLE ) ) . BootServices as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SYSTEM_TABLE ) ,
                "::" , stringify ! ( BootServices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SYSTEM_TABLE ) ) .
                NumberOfTableEntries as * const _ as usize } , 104usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SYSTEM_TABLE ) ,
                "::" , stringify ! ( NumberOfTableEntries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SYSTEM_TABLE ) ) .
                ConfigurationTable as * const _ as usize } , 112usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _EFI_SYSTEM_TABLE ) ,
                "::" , stringify ! ( ConfigurationTable ) ));
}
impl Clone for _EFI_SYSTEM_TABLE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_ALLOCATE_PAGES =
    ::core::option::Option<unsafe extern "win64" fn(Type: EFI_ALLOCATE_TYPE,
                                                MemoryType: EFI_MEMORY_TYPE,
                                                NoPages: UINTN,
                                                Memory:
                                                    *mut EFI_PHYSICAL_ADDRESS)
                               -> EFI_STATUS>;
pub type EFI_FREE_PAGES =
    ::core::option::Option<unsafe extern "win64" fn(Memory: EFI_PHYSICAL_ADDRESS,
                                                NoPages: UINTN)
                               -> EFI_STATUS>;
pub type EFI_GET_MEMORY_MAP =
    ::core::option::Option<unsafe extern "win64" fn(MemoryMapSize: *mut UINTN,
                                                MemoryMap:
                                                    *mut EFI_MEMORY_DESCRIPTOR,
                                                MapKey: *mut UINTN,
                                                DescriptorSize: *mut UINTN,
                                                DescriptorVersion:
                                                    *mut UINT32)
                               -> EFI_STATUS>;
pub type EFI_ALLOCATE_POOL =
    ::core::option::Option<unsafe extern "win64" fn(PoolType: EFI_MEMORY_TYPE,
                                                Size: UINTN,
                                                Buffer:
                                                    *mut *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_FREE_POOL =
    ::core::option::Option<unsafe extern "win64" fn(Buffer: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_SET_VIRTUAL_ADDRESS_MAP =
    ::core::option::Option<unsafe extern "win64" fn(MemoryMapSize: UINTN,
                                                DescriptorSize: UINTN,
                                                DescriptorVersion: UINT32,
                                                VirtualMap:
                                                    *mut EFI_MEMORY_DESCRIPTOR)
                               -> EFI_STATUS>;
pub type EFI_CONVERT_POINTER =
    ::core::option::Option<unsafe extern "win64" fn(DebugDisposition: UINTN,
                                                Address:
                                                    *mut *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_EVENT_NOTIFY =
    ::core::option::Option<unsafe extern "win64" fn(Event: EFI_EVENT,
                                                Context:
                                                    *mut ::ctypes::c_void)>;
pub type EFI_CREATE_EVENT =
    ::core::option::Option<unsafe extern "win64" fn(Type: UINT32,
                                                NotifyTpl: EFI_TPL,
                                                NotifyFunction:
                                                    EFI_EVENT_NOTIFY,
                                                NotifyContext:
                                                    *mut ::ctypes::c_void,
                                                Event: *mut EFI_EVENT)
                               -> EFI_STATUS>;
pub const EFI_TIMER_DELAY_TimerCancel: EFI_TIMER_DELAY = 0;
pub const EFI_TIMER_DELAY_TimerPeriodic: EFI_TIMER_DELAY = 1;
pub const EFI_TIMER_DELAY_TimerRelative: EFI_TIMER_DELAY = 2;
pub const EFI_TIMER_DELAY_TimerTypeMax: EFI_TIMER_DELAY = 3;
pub type EFI_TIMER_DELAY = ::ctypes::c_uint;
pub type EFI_SET_TIMER =
    ::core::option::Option<unsafe extern "win64" fn(Event: EFI_EVENT,
                                                Type: EFI_TIMER_DELAY,
                                                TriggerTime: UINT64)
                               -> EFI_STATUS>;
pub type EFI_SIGNAL_EVENT =
    ::core::option::Option<unsafe extern "win64" fn(Event: EFI_EVENT)
                               -> EFI_STATUS>;
pub type EFI_WAIT_FOR_EVENT =
    ::core::option::Option<unsafe extern "win64" fn(NumberOfEvents: UINTN,
                                                Event: *mut EFI_EVENT,
                                                Index: *mut UINTN)
                               -> EFI_STATUS>;
pub type EFI_CLOSE_EVENT =
    ::core::option::Option<unsafe extern "win64" fn(Event: EFI_EVENT)
                               -> EFI_STATUS>;
pub type EFI_CHECK_EVENT =
    ::core::option::Option<unsafe extern "win64" fn(Event: EFI_EVENT)
                               -> EFI_STATUS>;
pub type EFI_RAISE_TPL =
    ::core::option::Option<unsafe extern "win64" fn(NewTpl: EFI_TPL) -> EFI_TPL>;
pub type EFI_RESTORE_TPL =
    ::core::option::Option<unsafe extern "win64" fn(OldTpl: EFI_TPL)>;
pub type EFI_GET_VARIABLE =
    ::core::option::Option<unsafe extern "win64" fn(VariableName: *mut CHAR16,
                                                VendorGuid: *mut EFI_GUID,
                                                Attributes: *mut UINT32,
                                                DataSize: *mut UINTN,
                                                Data: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_GET_NEXT_VARIABLE_NAME =
    ::core::option::Option<unsafe extern "win64" fn(VariableNameSize: *mut UINTN,
                                                VariableName: *mut CHAR16,
                                                VendorGuid: *mut EFI_GUID)
                               -> EFI_STATUS>;
pub type EFI_SET_VARIABLE =
    ::core::option::Option<unsafe extern "win64" fn(VariableName: *mut CHAR16,
                                                VendorGuid: *mut EFI_GUID,
                                                Attributes: UINT32,
                                                DataSize: UINTN,
                                                Data: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_TIME_CAPABILITIES {
    pub Resolution: UINT32,
    pub Accuracy: UINT32,
    pub SetsToZero: BOOLEAN,
}
#[test]
fn bindgen_test_layout_EFI_TIME_CAPABILITIES() {
    assert_eq!(::core::mem::size_of::<EFI_TIME_CAPABILITIES>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TIME_CAPABILITIES )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TIME_CAPABILITIES>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TIME_CAPABILITIES ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TIME_CAPABILITIES ) ) . Resolution as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TIME_CAPABILITIES )
                , "::" , stringify ! ( Resolution ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TIME_CAPABILITIES ) ) . Accuracy as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TIME_CAPABILITIES )
                , "::" , stringify ! ( Accuracy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TIME_CAPABILITIES ) ) . SetsToZero as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TIME_CAPABILITIES )
                , "::" , stringify ! ( SetsToZero ) ));
}
impl Clone for EFI_TIME_CAPABILITIES {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_GET_TIME =
    ::core::option::Option<unsafe extern "win64" fn(Time: *mut EFI_TIME,
                                                Capabilities:
                                                    *mut EFI_TIME_CAPABILITIES)
                               -> EFI_STATUS>;
pub type EFI_SET_TIME =
    ::core::option::Option<unsafe extern "win64" fn(Time: *mut EFI_TIME)
                               -> EFI_STATUS>;
pub type EFI_GET_WAKEUP_TIME =
    ::core::option::Option<unsafe extern "win64" fn(Enabled: *mut BOOLEAN,
                                                Pending: *mut BOOLEAN,
                                                Time: *mut EFI_TIME)
                               -> EFI_STATUS>;
pub type EFI_SET_WAKEUP_TIME =
    ::core::option::Option<unsafe extern "win64" fn(Enable: BOOLEAN,
                                                Time: *mut EFI_TIME)
                               -> EFI_STATUS>;
pub type EFI_IMAGE_ENTRY_POINT =
    ::core::option::Option<unsafe extern "win64" fn(ImageHandle: EFI_HANDLE,
                                                SystemTable:
                                                    *mut _EFI_SYSTEM_TABLE)
                               -> EFI_STATUS>;
pub type EFI_IMAGE_LOAD =
    ::core::option::Option<unsafe extern "win64" fn(BootPolicy: BOOLEAN,
                                                ParentImageHandle: EFI_HANDLE,
                                                FilePath:
                                                    *mut EFI_DEVICE_PATH,
                                                SourceBuffer:
                                                    *mut ::ctypes::c_void,
                                                SourceSize: UINTN,
                                                ImageHandle: *mut EFI_HANDLE)
                               -> EFI_STATUS>;
pub type EFI_IMAGE_START =
    ::core::option::Option<unsafe extern "win64" fn(ImageHandle: EFI_HANDLE,
                                                ExitDataSize: *mut UINTN,
                                                ExitData: *mut *mut CHAR16)
                               -> EFI_STATUS>;
pub type EFI_EXIT =
    ::core::option::Option<unsafe extern "win64" fn(ImageHandle: EFI_HANDLE,
                                                ExitStatus: EFI_STATUS,
                                                ExitDataSize: UINTN,
                                                ExitData: *mut CHAR16)
                               -> EFI_STATUS>;
pub type EFI_IMAGE_UNLOAD =
    ::core::option::Option<unsafe extern "win64" fn(ImageHandle: EFI_HANDLE)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_LOADED_IMAGE {
    pub Revision: UINT32,
    pub ParentHandle: EFI_HANDLE,
    pub SystemTable: *mut _EFI_SYSTEM_TABLE,
    pub DeviceHandle: EFI_HANDLE,
    pub FilePath: *mut EFI_DEVICE_PATH,
    pub Reserved: *mut ::ctypes::c_void,
    pub LoadOptionsSize: UINT32,
    pub LoadOptions: *mut ::ctypes::c_void,
    pub ImageBase: *mut ::ctypes::c_void,
    pub ImageSize: UINT64,
    pub ImageCodeType: EFI_MEMORY_TYPE,
    pub ImageDataType: EFI_MEMORY_TYPE,
    pub Unload: EFI_IMAGE_UNLOAD,
}
#[test]
fn bindgen_test_layout_EFI_LOADED_IMAGE() {
    assert_eq!(::core::mem::size_of::<EFI_LOADED_IMAGE>() , 96usize , concat !
               ( "Size of: " , stringify ! ( EFI_LOADED_IMAGE ) ));
    assert_eq! (::core::mem::align_of::<EFI_LOADED_IMAGE>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( EFI_LOADED_IMAGE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_LOADED_IMAGE ) ) . Revision as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_LOADED_IMAGE ) ,
                "::" , stringify ! ( Revision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_LOADED_IMAGE ) ) . ParentHandle as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_LOADED_IMAGE ) ,
                "::" , stringify ! ( ParentHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_LOADED_IMAGE ) ) . SystemTable as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_LOADED_IMAGE ) ,
                "::" , stringify ! ( SystemTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_LOADED_IMAGE ) ) . DeviceHandle as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_LOADED_IMAGE ) ,
                "::" , stringify ! ( DeviceHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_LOADED_IMAGE ) ) . FilePath as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_LOADED_IMAGE ) ,
                "::" , stringify ! ( FilePath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_LOADED_IMAGE ) ) . Reserved as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_LOADED_IMAGE ) ,
                "::" , stringify ! ( Reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_LOADED_IMAGE ) ) . LoadOptionsSize as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_LOADED_IMAGE ) ,
                "::" , stringify ! ( LoadOptionsSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_LOADED_IMAGE ) ) . LoadOptions as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_LOADED_IMAGE ) ,
                "::" , stringify ! ( LoadOptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_LOADED_IMAGE ) ) . ImageBase as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_LOADED_IMAGE ) ,
                "::" , stringify ! ( ImageBase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_LOADED_IMAGE ) ) . ImageSize as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_LOADED_IMAGE ) ,
                "::" , stringify ! ( ImageSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_LOADED_IMAGE ) ) . ImageCodeType as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_LOADED_IMAGE ) ,
                "::" , stringify ! ( ImageCodeType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_LOADED_IMAGE ) ) . ImageDataType as *
                const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_LOADED_IMAGE ) ,
                "::" , stringify ! ( ImageDataType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_LOADED_IMAGE ) ) . Unload as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_LOADED_IMAGE ) ,
                "::" , stringify ! ( Unload ) ));
}
impl Clone for EFI_LOADED_IMAGE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_EXIT_BOOT_SERVICES =
    ::core::option::Option<unsafe extern "win64" fn(ImageHandle: EFI_HANDLE,
                                                MapKey: UINTN) -> EFI_STATUS>;
pub type EFI_STALL =
    ::core::option::Option<unsafe extern "win64" fn(Microseconds: UINTN)
                               -> EFI_STATUS>;
pub type EFI_SET_WATCHDOG_TIMER =
    ::core::option::Option<unsafe extern "win64" fn(Timeout: UINTN,
                                                WatchdogCode: UINT64,
                                                DataSize: UINTN,
                                                WatchdogData: *mut CHAR16)
                               -> EFI_STATUS>;
pub type EFI_CONNECT_CONTROLLER =
    ::core::option::Option<unsafe extern "win64" fn(ControllerHandle: EFI_HANDLE,
                                                DriverImageHandle:
                                                    *mut EFI_HANDLE,
                                                RemainingDevicePath:
                                                    *mut EFI_DEVICE_PATH,
                                                Recursive: BOOLEAN)
                               -> EFI_STATUS>;
pub type EFI_DISCONNECT_CONTROLLER =
    ::core::option::Option<unsafe extern "win64" fn(ControllerHandle: EFI_HANDLE,
                                                DriverImageHandle: EFI_HANDLE,
                                                ChildHandle: EFI_HANDLE)
                               -> EFI_STATUS>;
pub type EFI_OPEN_PROTOCOL =
    ::core::option::Option<unsafe extern "win64" fn(Handle: EFI_HANDLE,
                                                Protocol: *mut EFI_GUID,
                                                Interface:
                                                    *mut *mut ::ctypes::c_void,
                                                AgentHandle: EFI_HANDLE,
                                                ControllerHandle: EFI_HANDLE,
                                                Attributes: UINT32)
                               -> EFI_STATUS>;
pub type EFI_CLOSE_PROTOCOL =
    ::core::option::Option<unsafe extern "win64" fn(Handle: EFI_HANDLE,
                                                Protocol: *mut EFI_GUID,
                                                AgentHandle: EFI_HANDLE,
                                                ControllerHandle: EFI_HANDLE)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_OPEN_PROTOCOL_INFORMATION_ENTRY {
    pub AgentHandle: EFI_HANDLE,
    pub ControllerHandle: EFI_HANDLE,
    pub Attributes: UINT32,
    pub OpenCount: UINT32,
}
#[test]
fn bindgen_test_layout_EFI_OPEN_PROTOCOL_INFORMATION_ENTRY() {
    assert_eq!(::core::mem::size_of::<EFI_OPEN_PROTOCOL_INFORMATION_ENTRY>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( EFI_OPEN_PROTOCOL_INFORMATION_ENTRY
               ) ));
    assert_eq! (::core::mem::align_of::<EFI_OPEN_PROTOCOL_INFORMATION_ENTRY>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_OPEN_PROTOCOL_INFORMATION_ENTRY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_OPEN_PROTOCOL_INFORMATION_ENTRY ) ) .
                AgentHandle as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_OPEN_PROTOCOL_INFORMATION_ENTRY ) , "::" , stringify ! (
                AgentHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_OPEN_PROTOCOL_INFORMATION_ENTRY ) ) .
                ControllerHandle as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_OPEN_PROTOCOL_INFORMATION_ENTRY ) , "::" , stringify ! (
                ControllerHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_OPEN_PROTOCOL_INFORMATION_ENTRY ) ) .
                Attributes as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_OPEN_PROTOCOL_INFORMATION_ENTRY ) , "::" , stringify ! (
                Attributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_OPEN_PROTOCOL_INFORMATION_ENTRY ) ) .
                OpenCount as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_OPEN_PROTOCOL_INFORMATION_ENTRY ) , "::" , stringify ! (
                OpenCount ) ));
}
impl Clone for EFI_OPEN_PROTOCOL_INFORMATION_ENTRY {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_OPEN_PROTOCOL_INFORMATION =
    ::core::option::Option<unsafe extern "win64" fn(Handle: EFI_HANDLE,
                                                Protocol: *mut EFI_GUID,
                                                EntryBuffer:
                                                    *mut *mut EFI_OPEN_PROTOCOL_INFORMATION_ENTRY,
                                                EntryCount: *mut UINTN)
                               -> EFI_STATUS>;
pub type EFI_PROTOCOLS_PER_HANDLE =
    ::core::option::Option<unsafe extern "win64" fn(Handle: EFI_HANDLE,
                                                ProtocolBuffer:
                                                    *mut *mut *mut EFI_GUID,
                                                ProtocolBufferCount:
                                                    *mut UINTN)
                               -> EFI_STATUS>;
pub const EFI_LOCATE_SEARCH_TYPE_AllHandles: EFI_LOCATE_SEARCH_TYPE = 0;
pub const EFI_LOCATE_SEARCH_TYPE_ByRegisterNotify: EFI_LOCATE_SEARCH_TYPE = 1;
pub const EFI_LOCATE_SEARCH_TYPE_ByProtocol: EFI_LOCATE_SEARCH_TYPE = 2;
pub type EFI_LOCATE_SEARCH_TYPE = ::ctypes::c_uint;
pub type EFI_LOCATE_HANDLE_BUFFER =
    ::core::option::Option<unsafe extern "win64" fn(SearchType:
                                                    EFI_LOCATE_SEARCH_TYPE,
                                                Protocol: *mut EFI_GUID,
                                                SearchKey:
                                                    *mut ::ctypes::c_void,
                                                NoHandles: *mut UINTN,
                                                Buffer: *mut *mut EFI_HANDLE)
                               -> EFI_STATUS>;
pub type EFI_LOCATE_PROTOCOL =
    ::core::option::Option<unsafe extern "win64" fn(Protocol: *mut EFI_GUID,
                                                Registration:
                                                    *mut ::ctypes::c_void,
                                                Interface:
                                                    *mut *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_CALCULATE_CRC32 =
    ::core::option::Option<unsafe extern "win64" fn(Data: *mut ::ctypes::c_void,
                                                DataSize: UINTN,
                                                Crc32: *mut UINT32)
                               -> EFI_STATUS>;
pub type EFI_COPY_MEM =
    ::core::option::Option<unsafe extern "win64" fn(Destination:
                                                    *mut ::ctypes::c_void,
                                                Source: *mut ::ctypes::c_void,
                                                Length: UINTN)>;
pub type EFI_SET_MEM =
    ::core::option::Option<unsafe extern "win64" fn(Buffer: *mut ::ctypes::c_void,
                                                Size: UINTN, Value: UINT8)>;
pub type EFI_CREATE_EVENT_EX =
    ::core::option::Option<unsafe extern "win64" fn(Type: UINT32,
                                                NotifyTpl: EFI_TPL,
                                                NotifyFunction:
                                                    EFI_EVENT_NOTIFY,
                                                NotifyContext:
                                                    *const ::ctypes::c_void,
                                                EventGroup: EFI_GUID,
                                                Event: *mut EFI_EVENT)
                               -> EFI_STATUS>;
pub const EFI_RESET_TYPE_EfiResetCold: EFI_RESET_TYPE = 0;
pub const EFI_RESET_TYPE_EfiResetWarm: EFI_RESET_TYPE = 1;
pub const EFI_RESET_TYPE_EfiResetShutdown: EFI_RESET_TYPE = 2;
pub type EFI_RESET_TYPE = ::ctypes::c_uint;
pub type EFI_RESET_SYSTEM =
    ::core::option::Option<unsafe extern "win64" fn(ResetType: EFI_RESET_TYPE,
                                                ResetStatus: EFI_STATUS,
                                                DataSize: UINTN,
                                                ResetData: *mut CHAR16)
                               -> EFI_STATUS>;
pub type EFI_GET_NEXT_MONOTONIC_COUNT =
    ::core::option::Option<unsafe extern "win64" fn(Count: *mut UINT64)
                               -> EFI_STATUS>;
pub type EFI_GET_NEXT_HIGH_MONO_COUNT =
    ::core::option::Option<unsafe extern "win64" fn(HighCount: *mut UINT32)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_CAPSULE_BLOCK_DESCRIPTOR {
    pub Length: UINT64,
    pub Union: EFI_CAPSULE_BLOCK_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]

pub union EFI_CAPSULE_BLOCK_DESCRIPTOR__bindgen_ty_1 {
    pub DataBlock: EFI_PHYSICAL_ADDRESS,
    pub ContinuationPointer: EFI_PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout_EFI_CAPSULE_BLOCK_DESCRIPTOR__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<EFI_CAPSULE_BLOCK_DESCRIPTOR__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               EFI_CAPSULE_BLOCK_DESCRIPTOR__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<EFI_CAPSULE_BLOCK_DESCRIPTOR__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_CAPSULE_BLOCK_DESCRIPTOR__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_CAPSULE_BLOCK_DESCRIPTOR__bindgen_ty_1 )
                ) . DataBlock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_CAPSULE_BLOCK_DESCRIPTOR__bindgen_ty_1 ) , "::" ,
                stringify ! ( DataBlock ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const EFI_CAPSULE_BLOCK_DESCRIPTOR__bindgen_ty_1 )
                ) . ContinuationPointer as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                EFI_CAPSULE_BLOCK_DESCRIPTOR__bindgen_ty_1 ) , "::" ,
                stringify ! ( ContinuationPointer ) ));
}
impl Clone for EFI_CAPSULE_BLOCK_DESCRIPTOR__bindgen_ty_1 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[test]
fn bindgen_test_layout_EFI_CAPSULE_BLOCK_DESCRIPTOR() {
    assert_eq!(::core::mem::size_of::<EFI_CAPSULE_BLOCK_DESCRIPTOR>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( EFI_CAPSULE_BLOCK_DESCRIPTOR ) ));
    assert_eq! (::core::mem::align_of::<EFI_CAPSULE_BLOCK_DESCRIPTOR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( EFI_CAPSULE_BLOCK_DESCRIPTOR )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_CAPSULE_BLOCK_DESCRIPTOR ) ) . Length
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_CAPSULE_BLOCK_DESCRIPTOR ) , "::" , stringify ! ( Length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_CAPSULE_BLOCK_DESCRIPTOR ) ) . Union
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_CAPSULE_BLOCK_DESCRIPTOR ) , "::" , stringify ! ( Union )
                ));
}
impl Clone for EFI_CAPSULE_BLOCK_DESCRIPTOR {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_CAPSULE_HEADER {
    pub CapsuleGuid: EFI_GUID,
    pub HeaderSize: UINT32,
    pub Flags: UINT32,
    pub CapsuleImageSize: UINT32,
}
#[test]
fn bindgen_test_layout_EFI_CAPSULE_HEADER() {
    assert_eq!(::core::mem::size_of::<EFI_CAPSULE_HEADER>() , 28usize , concat
               ! ( "Size of: " , stringify ! ( EFI_CAPSULE_HEADER ) ));
    assert_eq! (::core::mem::align_of::<EFI_CAPSULE_HEADER>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_CAPSULE_HEADER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_CAPSULE_HEADER ) ) . CapsuleGuid as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_CAPSULE_HEADER ) ,
                "::" , stringify ! ( CapsuleGuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_CAPSULE_HEADER ) ) . HeaderSize as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_CAPSULE_HEADER ) ,
                "::" , stringify ! ( HeaderSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_CAPSULE_HEADER ) ) . Flags as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_CAPSULE_HEADER ) ,
                "::" , stringify ! ( Flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_CAPSULE_HEADER ) ) . CapsuleImageSize
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_CAPSULE_HEADER ) ,
                "::" , stringify ! ( CapsuleImageSize ) ));
}
impl Clone for EFI_CAPSULE_HEADER {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_UPDATE_CAPSULE =
    ::core::option::Option<unsafe extern "win64" fn(CapsuleHeaderArray:
                                                    *mut *mut EFI_CAPSULE_HEADER,
                                                CapsuleCount: UINTN,
                                                ScatterGatherList:
                                                    EFI_PHYSICAL_ADDRESS)
                               -> EFI_STATUS>;
pub type EFI_QUERY_CAPSULE_CAPABILITIES =
    ::core::option::Option<unsafe extern "win64" fn(CapsuleHeaderArray:
                                                    *mut *mut EFI_CAPSULE_HEADER,
                                                CapsuleCount: UINTN,
                                                MaximumCapsuleSize:
                                                    *mut UINT64,
                                                ResetType:
                                                    *mut EFI_RESET_TYPE)
                               -> EFI_STATUS>;
pub type EFI_QUERY_VARIABLE_INFO =
    ::core::option::Option<unsafe extern "win64" fn(Attributes: UINT32,
                                                MaximumVariableStorageSize:
                                                    *mut UINT64,
                                                RemainingVariableStorageSize:
                                                    *mut UINT64,
                                                MaximumVariableSize:
                                                    *mut UINT64)
                               -> EFI_STATUS>;
pub const EFI_INTERFACE_TYPE_EFI_NATIVE_INTERFACE: EFI_INTERFACE_TYPE = 0;
pub const EFI_INTERFACE_TYPE_EFI_PCODE_INTERFACE: EFI_INTERFACE_TYPE = 1;
pub type EFI_INTERFACE_TYPE = ::ctypes::c_uint;
pub type EFI_INSTALL_PROTOCOL_INTERFACE =
    ::core::option::Option<unsafe extern "win64" fn(Handle: *mut EFI_HANDLE,
                                                Protocol: *mut EFI_GUID,
                                                InterfaceType:
                                                    EFI_INTERFACE_TYPE,
                                                Interface:
                                                    *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_REINSTALL_PROTOCOL_INTERFACE =
    ::core::option::Option<unsafe extern "win64" fn(Handle: EFI_HANDLE,
                                                Protocol: *mut EFI_GUID,
                                                OldInterface:
                                                    *mut ::ctypes::c_void,
                                                NewInterface:
                                                    *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_UNINSTALL_PROTOCOL_INTERFACE =
    ::core::option::Option<unsafe extern "win64" fn(Handle: EFI_HANDLE,
                                                Protocol: *mut EFI_GUID,
                                                Interface:
                                                    *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_HANDLE_PROTOCOL =
    ::core::option::Option<unsafe extern "win64" fn(Handle: EFI_HANDLE,
                                                Protocol: *mut EFI_GUID,
                                                Interface:
                                                    *mut *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_REGISTER_PROTOCOL_NOTIFY =
    ::core::option::Option<unsafe extern "win64" fn(Protocol: *mut EFI_GUID,
                                                Event: EFI_EVENT,
                                                Registration:
                                                    *mut *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_LOCATE_HANDLE =
    ::core::option::Option<unsafe extern "win64" fn(SearchType:
                                                    EFI_LOCATE_SEARCH_TYPE,
                                                Protocol: *mut EFI_GUID,
                                                SearchKey:
                                                    *mut ::ctypes::c_void,
                                                BufferSize: *mut UINTN,
                                                Buffer: *mut EFI_HANDLE)
                               -> EFI_STATUS>;
pub type EFI_LOCATE_DEVICE_PATH =
    ::core::option::Option<unsafe extern "win64" fn(Protocol: *mut EFI_GUID,
                                                DevicePath:
                                                    *mut *mut EFI_DEVICE_PATH,
                                                Device: *mut EFI_HANDLE)
                               -> EFI_STATUS>;
pub type EFI_INSTALL_CONFIGURATION_TABLE =
    ::core::option::Option<unsafe extern "win64" fn(Guid: *mut EFI_GUID,
                                                Table: *mut ::ctypes::c_void)
                               -> EFI_STATUS>;
pub type EFI_RESERVED_SERVICE =
    ::core::option::Option<unsafe extern "win64" fn() -> EFI_STATUS>;
#[repr(C)]

pub struct _EFI_TABLE_HEADER {
    pub Signature: UINT64,
    pub Revision: UINT32,
    pub HeaderSize: UINT32,
    pub CRC32: UINT32,
    pub Reserved: UINT32,
}
#[test]
fn bindgen_test_layout__EFI_TABLE_HEADER() {
    assert_eq!(::core::mem::size_of::<_EFI_TABLE_HEADER>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( _EFI_TABLE_HEADER ) ));
    assert_eq! (::core::mem::align_of::<_EFI_TABLE_HEADER>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _EFI_TABLE_HEADER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TABLE_HEADER ) ) . Signature as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TABLE_HEADER ) ,
                "::" , stringify ! ( Signature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TABLE_HEADER ) ) . Revision as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TABLE_HEADER ) ,
                "::" , stringify ! ( Revision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TABLE_HEADER ) ) . HeaderSize as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TABLE_HEADER ) ,
                "::" , stringify ! ( HeaderSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TABLE_HEADER ) ) . CRC32 as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TABLE_HEADER ) ,
                "::" , stringify ! ( CRC32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TABLE_HEADER ) ) . Reserved as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TABLE_HEADER ) ,
                "::" , stringify ! ( Reserved ) ));
}
impl Clone for _EFI_TABLE_HEADER {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_TABLE_HEADER = _EFI_TABLE_HEADER;
#[repr(C)]

pub struct EFI_RUNTIME_SERVICES {
    pub Hdr: EFI_TABLE_HEADER,
    pub GetTime: EFI_GET_TIME,
    pub SetTime: EFI_SET_TIME,
    pub GetWakeupTime: EFI_GET_WAKEUP_TIME,
    pub SetWakeupTime: EFI_SET_WAKEUP_TIME,
    pub SetVirtualAddressMap: EFI_SET_VIRTUAL_ADDRESS_MAP,
    pub ConvertPointer: EFI_CONVERT_POINTER,
    pub GetVariable: EFI_GET_VARIABLE,
    pub GetNextVariableName: EFI_GET_NEXT_VARIABLE_NAME,
    pub SetVariable: EFI_SET_VARIABLE,
    pub GetNextHighMonotonicCount: EFI_GET_NEXT_HIGH_MONO_COUNT,
    pub ResetSystem: EFI_RESET_SYSTEM,
    pub UpdateCapsule: EFI_UPDATE_CAPSULE,
    pub QueryCapsuleCapabilities: EFI_QUERY_CAPSULE_CAPABILITIES,
    pub QueryVariableInfo: EFI_QUERY_VARIABLE_INFO,
}
#[test]
fn bindgen_test_layout_EFI_RUNTIME_SERVICES() {
    assert_eq!(::core::mem::size_of::<EFI_RUNTIME_SERVICES>() , 136usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_RUNTIME_SERVICES )
               ));
    assert_eq! (::core::mem::align_of::<EFI_RUNTIME_SERVICES>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_RUNTIME_SERVICES ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) . Hdr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( Hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) . GetTime as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( GetTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) . SetTime as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( SetTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) . GetWakeupTime
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( GetWakeupTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) . SetWakeupTime
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( SetWakeupTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) .
                SetVirtualAddressMap as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( SetVirtualAddressMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) . ConvertPointer
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( ConvertPointer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) . GetVariable as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( GetVariable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) .
                GetNextVariableName as * const _ as usize } , 80usize , concat
                ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( GetNextVariableName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) . SetVariable as
                * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( SetVariable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) .
                GetNextHighMonotonicCount as * const _ as usize } , 96usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( GetNextHighMonotonicCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) . ResetSystem as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( ResetSystem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) . UpdateCapsule
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( UpdateCapsule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) .
                QueryCapsuleCapabilities as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( QueryCapsuleCapabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RUNTIME_SERVICES ) ) .
                QueryVariableInfo as * const _ as usize } , 128usize , concat
                ! (
                "Alignment of field: " , stringify ! ( EFI_RUNTIME_SERVICES )
                , "::" , stringify ! ( QueryVariableInfo ) ));
}
impl Clone for EFI_RUNTIME_SERVICES {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct _EFI_BOOT_SERVICES {
    pub Hdr: EFI_TABLE_HEADER,
    pub RaiseTPL: EFI_RAISE_TPL,
    pub RestoreTPL: EFI_RESTORE_TPL,
    pub AllocatePages: EFI_ALLOCATE_PAGES,
    pub FreePages: EFI_FREE_PAGES,
    pub GetMemoryMap: EFI_GET_MEMORY_MAP,
    pub AllocatePool: EFI_ALLOCATE_POOL,
    pub FreePool: EFI_FREE_POOL,
    pub CreateEvent: EFI_CREATE_EVENT,
    pub SetTimer: EFI_SET_TIMER,
    pub WaitForEvent: EFI_WAIT_FOR_EVENT,
    pub SignalEvent: EFI_SIGNAL_EVENT,
    pub CloseEvent: EFI_CLOSE_EVENT,
    pub CheckEvent: EFI_CHECK_EVENT,
    pub InstallProtocolInterface: EFI_INSTALL_PROTOCOL_INTERFACE,
    pub ReinstallProtocolInterface: EFI_REINSTALL_PROTOCOL_INTERFACE,
    pub UninstallProtocolInterface: EFI_UNINSTALL_PROTOCOL_INTERFACE,
    pub HandleProtocol: EFI_HANDLE_PROTOCOL,
    pub PCHandleProtocol: EFI_HANDLE_PROTOCOL,
    pub RegisterProtocolNotify: EFI_REGISTER_PROTOCOL_NOTIFY,
    pub LocateHandle: EFI_LOCATE_HANDLE,
    pub LocateDevicePath: EFI_LOCATE_DEVICE_PATH,
    pub InstallConfigurationTable: EFI_INSTALL_CONFIGURATION_TABLE,
    pub LoadImage: EFI_IMAGE_LOAD,
    pub StartImage: EFI_IMAGE_START,
    pub Exit: EFI_EXIT,
    pub UnloadImage: EFI_IMAGE_UNLOAD,
    pub ExitBootServices: EFI_EXIT_BOOT_SERVICES,
    pub GetNextMonotonicCount: EFI_GET_NEXT_MONOTONIC_COUNT,
    pub Stall: EFI_STALL,
    pub SetWatchdogTimer: EFI_SET_WATCHDOG_TIMER,
    pub ConnectController: EFI_CONNECT_CONTROLLER,
    pub DisconnectController: EFI_DISCONNECT_CONTROLLER,
    pub OpenProtocol: EFI_OPEN_PROTOCOL,
    pub CloseProtocol: EFI_CLOSE_PROTOCOL,
    pub OpenProtocolInformation: EFI_OPEN_PROTOCOL_INFORMATION,
    pub ProtocolsPerHandle: EFI_PROTOCOLS_PER_HANDLE,
    pub LocateHandleBuffer: EFI_LOCATE_HANDLE_BUFFER,
    pub LocateProtocol: EFI_LOCATE_PROTOCOL,
    pub InstallMultipleProtocolInterfaces: EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES,
    pub UninstallMultipleProtocolInterfaces: EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES,
    pub CalculateCrc32: EFI_CALCULATE_CRC32,
    pub CopyMem: EFI_COPY_MEM,
    pub SetMem: EFI_SET_MEM,
    pub CreateEventEx: EFI_CREATE_EVENT_EX,
}
#[test]
fn bindgen_test_layout__EFI_BOOT_SERVICES() {
    assert_eq!(::core::mem::size_of::<_EFI_BOOT_SERVICES>() , 376usize ,
               concat ! ( "Size of: " , stringify ! ( _EFI_BOOT_SERVICES ) ));
    assert_eq! (::core::mem::align_of::<_EFI_BOOT_SERVICES>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _EFI_BOOT_SERVICES ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . Hdr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( Hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . RaiseTPL as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( RaiseTPL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . RestoreTPL as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( RestoreTPL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . AllocatePages as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( AllocatePages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . FreePages as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( FreePages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . GetMemoryMap as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( GetMemoryMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . AllocatePool as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( AllocatePool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . FreePool as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( FreePool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . CreateEvent as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( CreateEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . SetTimer as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( SetTimer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . WaitForEvent as
                * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( WaitForEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . SignalEvent as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( SignalEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . CloseEvent as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( CloseEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . CheckEvent as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( CheckEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) .
                InstallProtocolInterface as * const _ as usize } , 128usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( InstallProtocolInterface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) .
                ReinstallProtocolInterface as * const _ as usize } , 136usize
                , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( ReinstallProtocolInterface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) .
                UninstallProtocolInterface as * const _ as usize } , 144usize
                , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( UninstallProtocolInterface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . HandleProtocol
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( HandleProtocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . PCHandleProtocol
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( PCHandleProtocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) .
                RegisterProtocolNotify as * const _ as usize } , 168usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( RegisterProtocolNotify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . LocateHandle as
                * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( LocateHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . LocateDevicePath
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( LocateDevicePath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) .
                InstallConfigurationTable as * const _ as usize } , 192usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( InstallConfigurationTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . LoadImage as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( LoadImage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . StartImage as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( StartImage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . Exit as * const
                _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( Exit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . UnloadImage as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( UnloadImage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . ExitBootServices
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( ExitBootServices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) .
                GetNextMonotonicCount as * const _ as usize } , 240usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( GetNextMonotonicCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . Stall as * const
                _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( Stall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . SetWatchdogTimer
                as * const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( SetWatchdogTimer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) .
                ConnectController as * const _ as usize } , 264usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( ConnectController ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) .
                DisconnectController as * const _ as usize } , 272usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( DisconnectController ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . OpenProtocol as
                * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( OpenProtocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . CloseProtocol as
                * const _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( CloseProtocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) .
                OpenProtocolInformation as * const _ as usize } , 296usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( OpenProtocolInformation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) .
                ProtocolsPerHandle as * const _ as usize } , 304usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( ProtocolsPerHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) .
                LocateHandleBuffer as * const _ as usize } , 312usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( LocateHandleBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . LocateProtocol
                as * const _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( LocateProtocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) .
                InstallMultipleProtocolInterfaces as * const _ as usize } ,
                328usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( InstallMultipleProtocolInterfaces ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) .
                UninstallMultipleProtocolInterfaces as * const _ as usize } ,
                336usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( UninstallMultipleProtocolInterfaces ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . CalculateCrc32
                as * const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( CalculateCrc32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . CopyMem as *
                const _ as usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( CopyMem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . SetMem as *
                const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( SetMem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_BOOT_SERVICES ) ) . CreateEventEx as
                * const _ as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_BOOT_SERVICES ) ,
                "::" , stringify ! ( CreateEventEx ) ));
}
impl Clone for _EFI_BOOT_SERVICES {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_BOOT_SERVICES = _EFI_BOOT_SERVICES;
#[repr(C)]

pub struct _EFI_CONFIGURATION_TABLE {
    pub VendorGuid: EFI_GUID,
    pub VendorTable: *mut ::ctypes::c_void,
}
#[test]
fn bindgen_test_layout__EFI_CONFIGURATION_TABLE() {
    assert_eq!(::core::mem::size_of::<_EFI_CONFIGURATION_TABLE>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( _EFI_CONFIGURATION_TABLE ) ));
    assert_eq! (::core::mem::align_of::<_EFI_CONFIGURATION_TABLE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _EFI_CONFIGURATION_TABLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_CONFIGURATION_TABLE ) ) . VendorGuid
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_CONFIGURATION_TABLE ) , "::" , stringify ! ( VendorGuid )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_CONFIGURATION_TABLE ) ) .
                VendorTable as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_CONFIGURATION_TABLE ) , "::" , stringify ! ( VendorTable
                ) ));
}
impl Clone for _EFI_CONFIGURATION_TABLE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_CONFIGURATION_TABLE = _EFI_CONFIGURATION_TABLE;
pub type EFI_SYSTEM_TABLE = _EFI_SYSTEM_TABLE;
#[repr(C)]

pub struct _EFI_PARTITION_HEADER {
    pub Hdr: EFI_TABLE_HEADER,
    pub DirectoryAllocationNumber: UINT32,
    pub BlockSize: UINT32,
    pub FirstUsableLba: EFI_LBA,
    pub LastUsableLba: EFI_LBA,
    pub UnusableSpace: EFI_LBA,
    pub FreeSpace: EFI_LBA,
    pub RootFile: EFI_LBA,
    pub SecutiryFile: EFI_LBA,
}
#[test]
fn bindgen_test_layout__EFI_PARTITION_HEADER() {
    assert_eq!(::core::mem::size_of::<_EFI_PARTITION_HEADER>() , 80usize ,
               concat ! ( "Size of: " , stringify ! ( _EFI_PARTITION_HEADER )
               ));
    assert_eq! (::core::mem::align_of::<_EFI_PARTITION_HEADER>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _EFI_PARTITION_HEADER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PARTITION_HEADER ) ) . Hdr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PARTITION_HEADER )
                , "::" , stringify ! ( Hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PARTITION_HEADER ) ) .
                DirectoryAllocationNumber as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PARTITION_HEADER )
                , "::" , stringify ! ( DirectoryAllocationNumber ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PARTITION_HEADER ) ) . BlockSize as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PARTITION_HEADER )
                , "::" , stringify ! ( BlockSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PARTITION_HEADER ) ) .
                FirstUsableLba as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PARTITION_HEADER )
                , "::" , stringify ! ( FirstUsableLba ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PARTITION_HEADER ) ) . LastUsableLba
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PARTITION_HEADER )
                , "::" , stringify ! ( LastUsableLba ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PARTITION_HEADER ) ) . UnusableSpace
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PARTITION_HEADER )
                , "::" , stringify ! ( UnusableSpace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PARTITION_HEADER ) ) . FreeSpace as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PARTITION_HEADER )
                , "::" , stringify ! ( FreeSpace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PARTITION_HEADER ) ) . RootFile as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PARTITION_HEADER )
                , "::" , stringify ! ( RootFile ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_PARTITION_HEADER ) ) . SecutiryFile
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_PARTITION_HEADER )
                , "::" , stringify ! ( SecutiryFile ) ));
}
impl Clone for _EFI_PARTITION_HEADER {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_PARTITION_HEADER = _EFI_PARTITION_HEADER;
#[repr(C)]
pub struct _EFI_FILE_HEADER {
    pub Hdr: EFI_TABLE_HEADER,
    pub Class: UINT32,
    pub LBALOffset: UINT32,
    pub Parent: EFI_LBA,
    pub FileSize: UINT64,
    pub FileAttributes: UINT64,
    pub FileCreateTime: EFI_TIME,
    pub FileModificationTime: EFI_TIME,
    pub VendorGuid: EFI_GUID,
    pub FileString: [CHAR16; 260usize],
}
#[test]
fn bindgen_test_layout__EFI_FILE_HEADER() {
    assert_eq!(::core::mem::size_of::<_EFI_FILE_HEADER>() , 624usize , concat
               ! ( "Size of: " , stringify ! ( _EFI_FILE_HEADER ) ));
    assert_eq! (::core::mem::align_of::<_EFI_FILE_HEADER>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _EFI_FILE_HEADER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HEADER ) ) . Hdr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HEADER ) ,
                "::" , stringify ! ( Hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HEADER ) ) . Class as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HEADER ) ,
                "::" , stringify ! ( Class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HEADER ) ) . LBALOffset as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HEADER ) ,
                "::" , stringify ! ( LBALOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HEADER ) ) . Parent as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HEADER ) ,
                "::" , stringify ! ( Parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HEADER ) ) . FileSize as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HEADER ) ,
                "::" , stringify ! ( FileSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HEADER ) ) . FileAttributes as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HEADER ) ,
                "::" , stringify ! ( FileAttributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HEADER ) ) . FileCreateTime as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HEADER ) ,
                "::" , stringify ! ( FileCreateTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HEADER ) ) .
                FileModificationTime as * const _ as usize } , 72usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HEADER ) ,
                "::" , stringify ! ( FileModificationTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HEADER ) ) . VendorGuid as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HEADER ) ,
                "::" , stringify ! ( VendorGuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_FILE_HEADER ) ) . FileString as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_FILE_HEADER ) ,
                "::" , stringify ! ( FileString ) ));
}
pub type EFI_FILE_HEADER = _EFI_FILE_HEADER;
#[repr(C)]

pub struct _EFI_LBAL {
    pub Hdr: EFI_TABLE_HEADER,
    pub Class: UINT32,
    pub Parent: EFI_LBA,
    pub Next: EFI_LBA,
    pub ArraySize: UINT32,
    pub ArrayCount: UINT32,
}
#[test]
fn bindgen_test_layout__EFI_LBAL() {
    assert_eq!(::core::mem::size_of::<_EFI_LBAL>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _EFI_LBAL ) ));
    assert_eq! (::core::mem::align_of::<_EFI_LBAL>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _EFI_LBAL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_LBAL ) ) . Hdr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_LBAL ) , "::" ,
                stringify ! ( Hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_LBAL ) ) . Class as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_LBAL ) , "::" ,
                stringify ! ( Class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_LBAL ) ) . Parent as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_LBAL ) , "::" ,
                stringify ! ( Parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_LBAL ) ) . Next as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_LBAL ) , "::" ,
                stringify ! ( Next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_LBAL ) ) . ArraySize as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_LBAL ) , "::" ,
                stringify ! ( ArraySize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_LBAL ) ) . ArrayCount as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_LBAL ) , "::" ,
                stringify ! ( ArrayCount ) ));
}
impl Clone for _EFI_LBAL {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_LBAL = _EFI_LBAL;
#[repr(C)]

pub struct EFI_RL {
    pub Start: EFI_LBA,
    pub Length: UINT64,
}
#[test]
fn bindgen_test_layout_EFI_RL() {
    assert_eq!(::core::mem::size_of::<EFI_RL>() , 16usize , concat ! (
               "Size of: " , stringify ! ( EFI_RL ) ));
    assert_eq! (::core::mem::align_of::<EFI_RL>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( EFI_RL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RL ) ) . Start as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_RL ) , "::" ,
                stringify ! ( Start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_RL ) ) . Length as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_RL ) , "::" ,
                stringify ! ( Length ) ));
}
impl Clone for EFI_RL {
    fn clone(&self) -> Self { unimplemented!() }
}
pub const UI_STRING_TYPE_UiDeviceString: UI_STRING_TYPE = 0;
pub const UI_STRING_TYPE_UiVendorString: UI_STRING_TYPE = 1;
pub const UI_STRING_TYPE_UiMaxString: UI_STRING_TYPE = 2;
pub type UI_STRING_TYPE = ::ctypes::c_uint;
#[repr(C)]

pub struct UI_STRING_ENTRY {
    pub LangCode: *mut ISO_639_2,
    pub UiString: *mut CHAR16,
}
#[test]
fn bindgen_test_layout_UI_STRING_ENTRY() {
    assert_eq!(::core::mem::size_of::<UI_STRING_ENTRY>() , 16usize , concat !
               ( "Size of: " , stringify ! ( UI_STRING_ENTRY ) ));
    assert_eq! (::core::mem::align_of::<UI_STRING_ENTRY>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( UI_STRING_ENTRY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UI_STRING_ENTRY ) ) . LangCode as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( UI_STRING_ENTRY ) ,
                "::" , stringify ! ( LangCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const UI_STRING_ENTRY ) ) . UiString as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( UI_STRING_ENTRY ) ,
                "::" , stringify ! ( UiString ) ));
}
impl Clone for UI_STRING_ENTRY {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct _UI_INTERFACE {
    pub Version: UINT32,
    pub Entry: *mut UI_STRING_ENTRY,
}
#[test]
fn bindgen_test_layout__UI_INTERFACE() {
    assert_eq!(::core::mem::size_of::<_UI_INTERFACE>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _UI_INTERFACE ) ));
    assert_eq! (::core::mem::align_of::<_UI_INTERFACE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _UI_INTERFACE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _UI_INTERFACE ) ) . Version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _UI_INTERFACE ) , "::"
                , stringify ! ( Version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _UI_INTERFACE ) ) . Entry as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _UI_INTERFACE ) , "::"
                , stringify ! ( Entry ) ));
}
impl Clone for _UI_INTERFACE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type UI_INTERFACE = _UI_INTERFACE;
#[repr(C)]

pub struct _EFI_IP4 {
    pub GetModeData: EFI_IP4_GET_MODE_DATA,
    pub Configure: EFI_IP4_CONFIGURE,
    pub Groups: EFI_IP4_GROUPS,
    pub Routes: EFI_IP4_ROUTES,
    pub Transmit: EFI_IP4_TRANSMIT,
    pub Receive: EFI_IP4_RECEIVE,
    pub Cancel: EFI_IP4_CANCEL,
    pub Poll: EFI_IP4_POLL,
}
#[test]
fn bindgen_test_layout__EFI_IP4() {
    assert_eq!(::core::mem::size_of::<_EFI_IP4>() , 64usize , concat ! (
               "Size of: " , stringify ! ( _EFI_IP4 ) ));
    assert_eq! (::core::mem::align_of::<_EFI_IP4>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _EFI_IP4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP4 ) ) . GetModeData as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP4 ) , "::" ,
                stringify ! ( GetModeData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP4 ) ) . Configure as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP4 ) , "::" ,
                stringify ! ( Configure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP4 ) ) . Groups as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP4 ) , "::" ,
                stringify ! ( Groups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP4 ) ) . Routes as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP4 ) , "::" ,
                stringify ! ( Routes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP4 ) ) . Transmit as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP4 ) , "::" ,
                stringify ! ( Transmit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP4 ) ) . Receive as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP4 ) , "::" ,
                stringify ! ( Receive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP4 ) ) . Cancel as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP4 ) , "::" ,
                stringify ! ( Cancel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP4 ) ) . Poll as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP4 ) , "::" ,
                stringify ! ( Poll ) ));
}
impl Clone for _EFI_IP4 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct _EFI_IP6 {
    pub GetModeData: EFI_IP6_GET_MODE_DATA,
    pub Configure: EFI_IP6_CONFIGURE,
    pub Groups: EFI_IP6_GROUPS,
    pub Routes: EFI_IP6_ROUTES,
    pub Neighbors: EFI_IP6_NEIGHBORS,
    pub Transmit: EFI_IP6_TRANSMIT,
    pub Receive: EFI_IP6_RECEIVE,
    pub Cancel: EFI_IP6_CANCEL,
    pub Poll: EFI_IP6_POLL,
}
#[test]
fn bindgen_test_layout__EFI_IP6() {
    assert_eq!(::core::mem::size_of::<_EFI_IP6>() , 72usize , concat ! (
               "Size of: " , stringify ! ( _EFI_IP6 ) ));
    assert_eq! (::core::mem::align_of::<_EFI_IP6>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _EFI_IP6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6 ) ) . GetModeData as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6 ) , "::" ,
                stringify ! ( GetModeData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6 ) ) . Configure as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6 ) , "::" ,
                stringify ! ( Configure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6 ) ) . Groups as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6 ) , "::" ,
                stringify ! ( Groups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6 ) ) . Routes as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6 ) , "::" ,
                stringify ! ( Routes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6 ) ) . Neighbors as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6 ) , "::" ,
                stringify ! ( Neighbors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6 ) ) . Transmit as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6 ) , "::" ,
                stringify ! ( Transmit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6 ) ) . Receive as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6 ) , "::" ,
                stringify ! ( Receive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6 ) ) . Cancel as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6 ) , "::" ,
                stringify ! ( Cancel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6 ) ) . Poll as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6 ) , "::" ,
                stringify ! ( Poll ) ));
}
impl Clone for _EFI_IP6 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IP4_ADDRESS_PAIR {
    pub InstanceHandle: EFI_HANDLE,
    pub Ip4Address: EFI_IPv4_ADDRESS,
    pub SubnetMask: EFI_IPv4_ADDRESS,
}
#[test]
fn bindgen_test_layout_EFI_IP4_ADDRESS_PAIR() {
    assert_eq!(::core::mem::size_of::<EFI_IP4_ADDRESS_PAIR>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_IP4_ADDRESS_PAIR )
               ));
    assert_eq! (::core::mem::align_of::<EFI_IP4_ADDRESS_PAIR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_IP4_ADDRESS_PAIR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_ADDRESS_PAIR ) ) . InstanceHandle
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_ADDRESS_PAIR )
                , "::" , stringify ! ( InstanceHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_ADDRESS_PAIR ) ) . Ip4Address as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_ADDRESS_PAIR )
                , "::" , stringify ! ( Ip4Address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_ADDRESS_PAIR ) ) . SubnetMask as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_ADDRESS_PAIR )
                , "::" , stringify ! ( SubnetMask ) ));
}
impl Clone for EFI_IP4_ADDRESS_PAIR {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IP4_VARIABLE_DATA {
    pub DriverHandle: EFI_HANDLE,
    pub AddressCount: UINT32,
    pub AddressPairs: [EFI_IP4_ADDRESS_PAIR; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_IP4_VARIABLE_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_IP4_VARIABLE_DATA>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_IP4_VARIABLE_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_IP4_VARIABLE_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_IP4_VARIABLE_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_VARIABLE_DATA ) ) . DriverHandle
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_VARIABLE_DATA )
                , "::" , stringify ! ( DriverHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_VARIABLE_DATA ) ) . AddressCount
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_VARIABLE_DATA )
                , "::" , stringify ! ( AddressCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_VARIABLE_DATA ) ) . AddressPairs
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_VARIABLE_DATA )
                , "::" , stringify ! ( AddressPairs ) ));
}
impl Clone for EFI_IP4_VARIABLE_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IP4_CONFIG_DATA {
    pub DefaultProtocol: UINT8,
    pub AcceptAnyProtocol: BOOLEAN,
    pub AcceptIcmpErrors: BOOLEAN,
    pub AcceptBroadcast: BOOLEAN,
    pub AcceptPromiscuous: BOOLEAN,
    pub UseDefaultAddress: BOOLEAN,
    pub StationAddress: EFI_IPv4_ADDRESS,
    pub SubnetMask: EFI_IPv4_ADDRESS,
    pub TypeOfService: UINT8,
    pub TimeToLive: UINT8,
    pub DoNotFragment: BOOLEAN,
    pub RawData: BOOLEAN,
    pub ReceiveTimeout: UINT32,
    pub TransmitTimeout: UINT32,
}
#[test]
fn bindgen_test_layout_EFI_IP4_CONFIG_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_IP4_CONFIG_DATA>() , 28usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_IP4_CONFIG_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_IP4_CONFIG_DATA>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_IP4_CONFIG_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_CONFIG_DATA ) ) . DefaultProtocol
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_CONFIG_DATA ) ,
                "::" , stringify ! ( DefaultProtocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_CONFIG_DATA ) ) .
                AcceptAnyProtocol as * const _ as usize } , 1usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_IP4_CONFIG_DATA ) ,
                "::" , stringify ! ( AcceptAnyProtocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_CONFIG_DATA ) ) .
                AcceptIcmpErrors as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_CONFIG_DATA ) ,
                "::" , stringify ! ( AcceptIcmpErrors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_CONFIG_DATA ) ) . AcceptBroadcast
                as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_CONFIG_DATA ) ,
                "::" , stringify ! ( AcceptBroadcast ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_CONFIG_DATA ) ) .
                AcceptPromiscuous as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_IP4_CONFIG_DATA ) ,
                "::" , stringify ! ( AcceptPromiscuous ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_CONFIG_DATA ) ) .
                UseDefaultAddress as * const _ as usize } , 5usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_IP4_CONFIG_DATA ) ,
                "::" , stringify ! ( UseDefaultAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_CONFIG_DATA ) ) . StationAddress
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_CONFIG_DATA ) ,
                "::" , stringify ! ( StationAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_CONFIG_DATA ) ) . SubnetMask as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_CONFIG_DATA ) ,
                "::" , stringify ! ( SubnetMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_CONFIG_DATA ) ) . TypeOfService
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_CONFIG_DATA ) ,
                "::" , stringify ! ( TypeOfService ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_CONFIG_DATA ) ) . TimeToLive as *
                const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_CONFIG_DATA ) ,
                "::" , stringify ! ( TimeToLive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_CONFIG_DATA ) ) . DoNotFragment
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_CONFIG_DATA ) ,
                "::" , stringify ! ( DoNotFragment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_CONFIG_DATA ) ) . RawData as *
                const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_CONFIG_DATA ) ,
                "::" , stringify ! ( RawData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_CONFIG_DATA ) ) . ReceiveTimeout
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_CONFIG_DATA ) ,
                "::" , stringify ! ( ReceiveTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_CONFIG_DATA ) ) . TransmitTimeout
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_CONFIG_DATA ) ,
                "::" , stringify ! ( TransmitTimeout ) ));
}
impl Clone for EFI_IP4_CONFIG_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IP4_ROUTE_TABLE {
    pub SubnetAddress: EFI_IPv4_ADDRESS,
    pub SubnetMask: EFI_IPv4_ADDRESS,
    pub GatewayAddress: EFI_IPv4_ADDRESS,
}
#[test]
fn bindgen_test_layout_EFI_IP4_ROUTE_TABLE() {
    assert_eq!(::core::mem::size_of::<EFI_IP4_ROUTE_TABLE>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_IP4_ROUTE_TABLE )
               ));
    assert_eq! (::core::mem::align_of::<EFI_IP4_ROUTE_TABLE>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_IP4_ROUTE_TABLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_ROUTE_TABLE ) ) . SubnetAddress
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_ROUTE_TABLE ) ,
                "::" , stringify ! ( SubnetAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_ROUTE_TABLE ) ) . SubnetMask as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_ROUTE_TABLE ) ,
                "::" , stringify ! ( SubnetMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_ROUTE_TABLE ) ) . GatewayAddress
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_ROUTE_TABLE ) ,
                "::" , stringify ! ( GatewayAddress ) ));
}
impl Clone for EFI_IP4_ROUTE_TABLE {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IP4_ICMP_TYPE {
    pub Type: UINT8,
    pub Code: UINT8,
}
#[test]
fn bindgen_test_layout_EFI_IP4_ICMP_TYPE() {
    assert_eq!(::core::mem::size_of::<EFI_IP4_ICMP_TYPE>() , 2usize , concat !
               ( "Size of: " , stringify ! ( EFI_IP4_ICMP_TYPE ) ));
    assert_eq! (::core::mem::align_of::<EFI_IP4_ICMP_TYPE>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( EFI_IP4_ICMP_TYPE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_ICMP_TYPE ) ) . Type as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_ICMP_TYPE ) ,
                "::" , stringify ! ( Type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_ICMP_TYPE ) ) . Code as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_ICMP_TYPE ) ,
                "::" , stringify ! ( Code ) ));
}
impl Clone for EFI_IP4_ICMP_TYPE {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IP4_MODE_DATA {
    pub IsStarted: BOOLEAN,
    pub MaxPacketSize: UINT32,
    pub ConfigData: EFI_IP4_CONFIG_DATA,
    pub IsConfigured: BOOLEAN,
    pub GroupCount: UINT32,
    pub GroupTable: *mut EFI_IPv4_ADDRESS,
    pub RouteCount: UINT32,
    pub RouteTable: *mut EFI_IP4_ROUTE_TABLE,
    pub IcmpTypeCount: UINT32,
    pub IcmpTypeList: *mut EFI_IP4_ICMP_TYPE,
}
#[test]
fn bindgen_test_layout_EFI_IP4_MODE_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_IP4_MODE_DATA>() , 88usize , concat
               ! ( "Size of: " , stringify ! ( EFI_IP4_MODE_DATA ) ));
    assert_eq! (::core::mem::align_of::<EFI_IP4_MODE_DATA>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( EFI_IP4_MODE_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_MODE_DATA ) ) . IsStarted as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_MODE_DATA ) ,
                "::" , stringify ! ( IsStarted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_MODE_DATA ) ) . MaxPacketSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_MODE_DATA ) ,
                "::" , stringify ! ( MaxPacketSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_MODE_DATA ) ) . ConfigData as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_MODE_DATA ) ,
                "::" , stringify ! ( ConfigData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_MODE_DATA ) ) . IsConfigured as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_MODE_DATA ) ,
                "::" , stringify ! ( IsConfigured ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_MODE_DATA ) ) . GroupCount as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_MODE_DATA ) ,
                "::" , stringify ! ( GroupCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_MODE_DATA ) ) . GroupTable as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_MODE_DATA ) ,
                "::" , stringify ! ( GroupTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_MODE_DATA ) ) . RouteCount as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_MODE_DATA ) ,
                "::" , stringify ! ( RouteCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_MODE_DATA ) ) . RouteTable as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_MODE_DATA ) ,
                "::" , stringify ! ( RouteTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_MODE_DATA ) ) . IcmpTypeCount as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_MODE_DATA ) ,
                "::" , stringify ! ( IcmpTypeCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_MODE_DATA ) ) . IcmpTypeList as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_MODE_DATA ) ,
                "::" , stringify ! ( IcmpTypeList ) ));
}
impl Clone for EFI_IP4_MODE_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_IP4_GET_MODE_DATA =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP4,
                                                Ip4ModeData:
                                                    *mut EFI_IP4_MODE_DATA,
                                                MnpConfigData:
                                                    *mut EFI_MANAGED_NETWORK_CONFIG_DATA,
                                                SnpModeData:
                                                    *mut EFI_SIMPLE_NETWORK_MODE)
                               -> EFI_STATUS>;
pub type EFI_IP4_CONFIGURE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP4,
                                                IpConfigData:
                                                    *mut EFI_IP4_CONFIG_DATA)
                               -> EFI_STATUS>;
pub type EFI_IP4_GROUPS =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP4,
                                                JoinFlag: BOOLEAN,
                                                GroupAddress:
                                                    *mut EFI_IPv4_ADDRESS)
                               -> EFI_STATUS>;
pub type EFI_IP4_ROUTES =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP4,
                                                DeleteRoute: BOOLEAN,
                                                SubnetAddress:
                                                    *mut EFI_IPv4_ADDRESS,
                                                SubnetMask:
                                                    *mut EFI_IPv4_ADDRESS,
                                                GatewayAddress:
                                                    *mut EFI_IPv4_ADDRESS)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_IP4_HEADER {
    pub _bitfield_1: u8,
    pub TypeOfService: UINT8,
    pub TotalLength: UINT16,
    pub Identification: UINT16,
    pub Fragmentation: UINT16,
    pub TimeToLive: UINT8,
    pub Protocol: UINT8,
    pub Checksum: UINT16,
    pub SourceAddress: EFI_IPv4_ADDRESS,
    pub DestinationAddress: EFI_IPv4_ADDRESS,
}
#[test]
fn bindgen_test_layout_EFI_IP4_HEADER() {
    assert_eq!(::core::mem::size_of::<EFI_IP4_HEADER>() , 20usize , concat ! (
               "Size of: " , stringify ! ( EFI_IP4_HEADER ) ));
    assert_eq! (::core::mem::align_of::<EFI_IP4_HEADER>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( EFI_IP4_HEADER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_HEADER ) ) . TypeOfService as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_HEADER ) , "::"
                , stringify ! ( TypeOfService ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_HEADER ) ) . TotalLength as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_HEADER ) , "::"
                , stringify ! ( TotalLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_HEADER ) ) . Identification as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_HEADER ) , "::"
                , stringify ! ( Identification ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_HEADER ) ) . Fragmentation as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_HEADER ) , "::"
                , stringify ! ( Fragmentation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_HEADER ) ) . TimeToLive as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_HEADER ) , "::"
                , stringify ! ( TimeToLive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_HEADER ) ) . Protocol as * const
                _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_HEADER ) , "::"
                , stringify ! ( Protocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_HEADER ) ) . Checksum as * const
                _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_HEADER ) , "::"
                , stringify ! ( Checksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_HEADER ) ) . SourceAddress as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_HEADER ) , "::"
                , stringify ! ( SourceAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_HEADER ) ) . DestinationAddress
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_HEADER ) , "::"
                , stringify ! ( DestinationAddress ) ));
}
impl Clone for EFI_IP4_HEADER {
    fn clone(&self) -> Self { unimplemented!() }
}
impl EFI_IP4_HEADER {
    #[inline]
    pub fn HeaderLength(&self) -> UINT8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 15u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_HeaderLength(&mut self, val: UINT8) {
        let mask = 15u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn Version(&self) -> UINT8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_Version(&mut self, val: UINT8) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub const fn new_bitfield_1(HeaderLength: UINT8, Version: UINT8) -> u8 {
        ({ ({ 0 } | ((HeaderLength as u8 as u8) << 0usize) & (15u64 as u8)) }
             | ((Version as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
#[repr(C)]

pub struct EFI_IP4_FRAGMENT_DATA {
    pub FragmentLength: UINT32,
    pub FragmentBuffer: *mut ::ctypes::c_void,
}
#[test]
fn bindgen_test_layout_EFI_IP4_FRAGMENT_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_IP4_FRAGMENT_DATA>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_IP4_FRAGMENT_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_IP4_FRAGMENT_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_IP4_FRAGMENT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_FRAGMENT_DATA ) ) .
                FragmentLength as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_FRAGMENT_DATA )
                , "::" , stringify ! ( FragmentLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_FRAGMENT_DATA ) ) .
                FragmentBuffer as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_FRAGMENT_DATA )
                , "::" , stringify ! ( FragmentBuffer ) ));
}
impl Clone for EFI_IP4_FRAGMENT_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IP4_RECEIVE_DATA {
    pub TimeStamp: EFI_TIME,
    pub RecycleSignal: EFI_EVENT,
    pub HeaderLength: UINT32,
    pub Header: *mut EFI_IP4_HEADER,
    pub OptionsLength: UINT32,
    pub Options: *mut ::ctypes::c_void,
    pub DataLength: UINT32,
    pub FragmentCount: UINT32,
    pub FragmentTable: [EFI_IP4_FRAGMENT_DATA; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_IP4_RECEIVE_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_IP4_RECEIVE_DATA>() , 80usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_IP4_RECEIVE_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_IP4_RECEIVE_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_IP4_RECEIVE_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_RECEIVE_DATA ) ) . TimeStamp as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_RECEIVE_DATA )
                , "::" , stringify ! ( TimeStamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_RECEIVE_DATA ) ) . RecycleSignal
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_RECEIVE_DATA )
                , "::" , stringify ! ( RecycleSignal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_RECEIVE_DATA ) ) . HeaderLength
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_RECEIVE_DATA )
                , "::" , stringify ! ( HeaderLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_RECEIVE_DATA ) ) . Header as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_RECEIVE_DATA )
                , "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_RECEIVE_DATA ) ) . OptionsLength
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_RECEIVE_DATA )
                , "::" , stringify ! ( OptionsLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_RECEIVE_DATA ) ) . Options as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_RECEIVE_DATA )
                , "::" , stringify ! ( Options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_RECEIVE_DATA ) ) . DataLength as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_RECEIVE_DATA )
                , "::" , stringify ! ( DataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_RECEIVE_DATA ) ) . FragmentCount
                as * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_RECEIVE_DATA )
                , "::" , stringify ! ( FragmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_RECEIVE_DATA ) ) . FragmentTable
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_RECEIVE_DATA )
                , "::" , stringify ! ( FragmentTable ) ));
}
impl Clone for EFI_IP4_RECEIVE_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IP4_OVERRIDE_DATA {
    pub SourceAddress: EFI_IPv4_ADDRESS,
    pub GatewayAddress: EFI_IPv4_ADDRESS,
    pub Protocol: UINT8,
    pub TypeOfService: UINT8,
    pub TimeToLive: UINT8,
    pub DoNotFragment: BOOLEAN,
}
#[test]
fn bindgen_test_layout_EFI_IP4_OVERRIDE_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_IP4_OVERRIDE_DATA>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_IP4_OVERRIDE_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_IP4_OVERRIDE_DATA>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_IP4_OVERRIDE_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_OVERRIDE_DATA ) ) . SourceAddress
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_OVERRIDE_DATA )
                , "::" , stringify ! ( SourceAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_OVERRIDE_DATA ) ) .
                GatewayAddress as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_OVERRIDE_DATA )
                , "::" , stringify ! ( GatewayAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_OVERRIDE_DATA ) ) . Protocol as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_OVERRIDE_DATA )
                , "::" , stringify ! ( Protocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_OVERRIDE_DATA ) ) . TypeOfService
                as * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_OVERRIDE_DATA )
                , "::" , stringify ! ( TypeOfService ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_OVERRIDE_DATA ) ) . TimeToLive as
                * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_OVERRIDE_DATA )
                , "::" , stringify ! ( TimeToLive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_OVERRIDE_DATA ) ) . DoNotFragment
                as * const _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_OVERRIDE_DATA )
                , "::" , stringify ! ( DoNotFragment ) ));
}
impl Clone for EFI_IP4_OVERRIDE_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IP4_TRANSMIT_DATA {
    pub DestinationAddress: EFI_IPv4_ADDRESS,
    pub OverrideData: *mut EFI_IP4_OVERRIDE_DATA,
    pub OptionsLength: UINT32,
    pub OptionsBuffer: *mut ::ctypes::c_void,
    pub TotalDataLength: UINT32,
    pub FragmentCount: UINT32,
    pub FragmentTable: [EFI_IP4_FRAGMENT_DATA; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_IP4_TRANSMIT_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_IP4_TRANSMIT_DATA>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_IP4_TRANSMIT_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_IP4_TRANSMIT_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_IP4_TRANSMIT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_TRANSMIT_DATA ) ) .
                DestinationAddress as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_IP4_TRANSMIT_DATA )
                , "::" , stringify ! ( DestinationAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_TRANSMIT_DATA ) ) . OverrideData
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_TRANSMIT_DATA )
                , "::" , stringify ! ( OverrideData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_TRANSMIT_DATA ) ) . OptionsLength
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_TRANSMIT_DATA )
                , "::" , stringify ! ( OptionsLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_TRANSMIT_DATA ) ) . OptionsBuffer
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_TRANSMIT_DATA )
                , "::" , stringify ! ( OptionsBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_TRANSMIT_DATA ) ) .
                TotalDataLength as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_TRANSMIT_DATA )
                , "::" , stringify ! ( TotalDataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_TRANSMIT_DATA ) ) . FragmentCount
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_TRANSMIT_DATA )
                , "::" , stringify ! ( FragmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_TRANSMIT_DATA ) ) . FragmentTable
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP4_TRANSMIT_DATA )
                , "::" , stringify ! ( FragmentTable ) ));
}
impl Clone for EFI_IP4_TRANSMIT_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IP4_COMPLETION_TOKEN {
    pub Event: EFI_EVENT,
    pub Status: EFI_STATUS,
    pub Packet: EFI_IP4_COMPLETION_TOKEN__bindgen_ty_1,
}
#[repr(C)]

pub union EFI_IP4_COMPLETION_TOKEN__bindgen_ty_1 {
    pub RxData: *mut EFI_IP4_RECEIVE_DATA,
    pub TxData: *mut EFI_IP4_TRANSMIT_DATA,
}
#[test]
fn bindgen_test_layout_EFI_IP4_COMPLETION_TOKEN__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<EFI_IP4_COMPLETION_TOKEN__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               EFI_IP4_COMPLETION_TOKEN__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<EFI_IP4_COMPLETION_TOKEN__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_IP4_COMPLETION_TOKEN__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_COMPLETION_TOKEN__bindgen_ty_1 )
                ) . RxData as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_IP4_COMPLETION_TOKEN__bindgen_ty_1 ) , "::" , stringify !
                ( RxData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_COMPLETION_TOKEN__bindgen_ty_1 )
                ) . TxData as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_IP4_COMPLETION_TOKEN__bindgen_ty_1 ) , "::" , stringify !
                ( TxData ) ));
}
impl Clone for EFI_IP4_COMPLETION_TOKEN__bindgen_ty_1 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[test]
fn bindgen_test_layout_EFI_IP4_COMPLETION_TOKEN() {
    assert_eq!(::core::mem::size_of::<EFI_IP4_COMPLETION_TOKEN>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( EFI_IP4_COMPLETION_TOKEN ) ));
    assert_eq! (::core::mem::align_of::<EFI_IP4_COMPLETION_TOKEN>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_IP4_COMPLETION_TOKEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_COMPLETION_TOKEN ) ) . Event as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_IP4_COMPLETION_TOKEN ) , "::" , stringify ! ( Event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_COMPLETION_TOKEN ) ) . Status as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_IP4_COMPLETION_TOKEN ) , "::" , stringify ! ( Status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP4_COMPLETION_TOKEN ) ) . Packet as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_IP4_COMPLETION_TOKEN ) , "::" , stringify ! ( Packet ) ));
}
impl Clone for EFI_IP4_COMPLETION_TOKEN {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_IP4_TRANSMIT =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP4,
                                                Token:
                                                    *mut EFI_IP4_COMPLETION_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_IP4_RECEIVE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP4,
                                                Token:
                                                    *mut EFI_IP4_COMPLETION_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_IP4_CANCEL =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP4,
                                                Token:
                                                    *mut EFI_IP4_COMPLETION_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_IP4_POLL =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP4)
                               -> EFI_STATUS>;
pub type EFI_IP4 = _EFI_IP4;
#[repr(C)]

pub struct EFI_IP6_CONFIG_DATA {
    pub DefaultProtocol: UINT8,
    pub AcceptAnyProtocol: BOOLEAN,
    pub AcceptIcmpErrors: BOOLEAN,
    pub AcceptPromiscuous: BOOLEAN,
    pub DestinationAddress: EFI_IPv6_ADDRESS,
    pub StationAddress: EFI_IPv6_ADDRESS,
    pub TrafficClass: UINT8,
    pub HopLimit: UINT8,
    pub FlowLabel: UINT32,
    pub ReceiveTimeout: UINT32,
    pub TransmitTimeout: UINT32,
}
#[test]
fn bindgen_test_layout_EFI_IP6_CONFIG_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_IP6_CONFIG_DATA>() , 52usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_IP6_CONFIG_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_IP6_CONFIG_DATA>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_IP6_CONFIG_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_CONFIG_DATA ) ) . DefaultProtocol
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_CONFIG_DATA ) ,
                "::" , stringify ! ( DefaultProtocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_CONFIG_DATA ) ) .
                AcceptAnyProtocol as * const _ as usize } , 1usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_IP6_CONFIG_DATA ) ,
                "::" , stringify ! ( AcceptAnyProtocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_CONFIG_DATA ) ) .
                AcceptIcmpErrors as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_CONFIG_DATA ) ,
                "::" , stringify ! ( AcceptIcmpErrors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_CONFIG_DATA ) ) .
                AcceptPromiscuous as * const _ as usize } , 3usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_IP6_CONFIG_DATA ) ,
                "::" , stringify ! ( AcceptPromiscuous ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_CONFIG_DATA ) ) .
                DestinationAddress as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_IP6_CONFIG_DATA ) ,
                "::" , stringify ! ( DestinationAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_CONFIG_DATA ) ) . StationAddress
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_CONFIG_DATA ) ,
                "::" , stringify ! ( StationAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_CONFIG_DATA ) ) . TrafficClass as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_CONFIG_DATA ) ,
                "::" , stringify ! ( TrafficClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_CONFIG_DATA ) ) . HopLimit as *
                const _ as usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_CONFIG_DATA ) ,
                "::" , stringify ! ( HopLimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_CONFIG_DATA ) ) . FlowLabel as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_CONFIG_DATA ) ,
                "::" , stringify ! ( FlowLabel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_CONFIG_DATA ) ) . ReceiveTimeout
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_CONFIG_DATA ) ,
                "::" , stringify ! ( ReceiveTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_CONFIG_DATA ) ) . TransmitTimeout
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_CONFIG_DATA ) ,
                "::" , stringify ! ( TransmitTimeout ) ));
}
impl Clone for EFI_IP6_CONFIG_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IP6_ADDRESS_INFO {
    pub Address: EFI_IPv6_ADDRESS,
    pub PrefixLength: UINT8,
}
#[test]
fn bindgen_test_layout_EFI_IP6_ADDRESS_INFO() {
    assert_eq!(::core::mem::size_of::<EFI_IP6_ADDRESS_INFO>() , 17usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_IP6_ADDRESS_INFO )
               ));
    assert_eq! (::core::mem::align_of::<EFI_IP6_ADDRESS_INFO>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_IP6_ADDRESS_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_ADDRESS_INFO ) ) . Address as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_ADDRESS_INFO )
                , "::" , stringify ! ( Address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_ADDRESS_INFO ) ) . PrefixLength
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_ADDRESS_INFO )
                , "::" , stringify ! ( PrefixLength ) ));
}
impl Clone for EFI_IP6_ADDRESS_INFO {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IP6_ROUTE_TABLE {
    pub Gateway: EFI_IPv6_ADDRESS,
    pub Destination: EFI_IPv6_ADDRESS,
    pub PrefixLength: UINT8,
}
#[test]
fn bindgen_test_layout_EFI_IP6_ROUTE_TABLE() {
    assert_eq!(::core::mem::size_of::<EFI_IP6_ROUTE_TABLE>() , 33usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_IP6_ROUTE_TABLE )
               ));
    assert_eq! (::core::mem::align_of::<EFI_IP6_ROUTE_TABLE>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_IP6_ROUTE_TABLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_ROUTE_TABLE ) ) . Gateway as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_ROUTE_TABLE ) ,
                "::" , stringify ! ( Gateway ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_ROUTE_TABLE ) ) . Destination as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_ROUTE_TABLE ) ,
                "::" , stringify ! ( Destination ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_ROUTE_TABLE ) ) . PrefixLength as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_ROUTE_TABLE ) ,
                "::" , stringify ! ( PrefixLength ) ));
}
impl Clone for EFI_IP6_ROUTE_TABLE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub const EFI_IP6_NEIGHBOR_STATE_EfiNeighborInComplete: EFI_IP6_NEIGHBOR_STATE
          =
    0;
pub const EFI_IP6_NEIGHBOR_STATE_EfiNeighborReachable: EFI_IP6_NEIGHBOR_STATE
          =
    1;
pub const EFI_IP6_NEIGHBOR_STATE_EfiNeighborStale: EFI_IP6_NEIGHBOR_STATE = 2;
pub const EFI_IP6_NEIGHBOR_STATE_EfiNeighborDelay: EFI_IP6_NEIGHBOR_STATE = 3;
pub const EFI_IP6_NEIGHBOR_STATE_EfiNeighborProbe: EFI_IP6_NEIGHBOR_STATE = 4;
pub type EFI_IP6_NEIGHBOR_STATE = ::ctypes::c_uint;
#[repr(C)]

pub struct EFI_IP6_NEIGHBOR_CACHE {
    pub Neighbor: EFI_IPv6_ADDRESS,
    pub LinkAddress: EFI_MAC_ADDRESS,
    pub State: EFI_IP6_NEIGHBOR_STATE,
}
#[test]
fn bindgen_test_layout_EFI_IP6_NEIGHBOR_CACHE() {
    assert_eq!(::core::mem::size_of::<EFI_IP6_NEIGHBOR_CACHE>() , 52usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_IP6_NEIGHBOR_CACHE )
               ));
    assert_eq! (::core::mem::align_of::<EFI_IP6_NEIGHBOR_CACHE>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_IP6_NEIGHBOR_CACHE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_NEIGHBOR_CACHE ) ) . Neighbor as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_NEIGHBOR_CACHE
                ) , "::" , stringify ! ( Neighbor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_NEIGHBOR_CACHE ) ) . LinkAddress
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_NEIGHBOR_CACHE
                ) , "::" , stringify ! ( LinkAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_NEIGHBOR_CACHE ) ) . State as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_NEIGHBOR_CACHE
                ) , "::" , stringify ! ( State ) ));
}
impl Clone for EFI_IP6_NEIGHBOR_CACHE {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IP6_ICMP_TYPE {
    pub Type: UINT8,
    pub Code: UINT8,
}
#[test]
fn bindgen_test_layout_EFI_IP6_ICMP_TYPE() {
    assert_eq!(::core::mem::size_of::<EFI_IP6_ICMP_TYPE>() , 2usize , concat !
               ( "Size of: " , stringify ! ( EFI_IP6_ICMP_TYPE ) ));
    assert_eq! (::core::mem::align_of::<EFI_IP6_ICMP_TYPE>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( EFI_IP6_ICMP_TYPE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_ICMP_TYPE ) ) . Type as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_ICMP_TYPE ) ,
                "::" , stringify ! ( Type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_ICMP_TYPE ) ) . Code as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_ICMP_TYPE ) ,
                "::" , stringify ! ( Code ) ));
}
impl Clone for EFI_IP6_ICMP_TYPE {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_IP6_MODE_DATA {
    pub IsStarted: BOOLEAN,
    pub MaxPacketSize: UINT32,
    pub ConfigData: EFI_IP6_CONFIG_DATA,
    pub IsConfigured: BOOLEAN,
    pub AddressCount: UINT32,
    pub AddressList: *mut EFI_IP6_ADDRESS_INFO,
    pub GroupCount: UINT32,
    pub GroupTable: *mut EFI_IPv6_ADDRESS,
    pub RouteCount: UINT32,
    pub RouteTable: *mut EFI_IP6_ROUTE_TABLE,
    pub NeighborCount: UINT32,
    pub NeighborCache: *mut EFI_IP6_NEIGHBOR_CACHE,
    pub PrefixCount: UINT32,
    pub PrefixTable: *mut EFI_IP6_ADDRESS_INFO,
    pub IcmpTypeCount: UINT32,
    pub IcmpTypeList: *mut EFI_IP6_ICMP_TYPE,
}
#[test]
fn bindgen_test_layout_EFI_IP6_MODE_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_IP6_MODE_DATA>() , 160usize , concat
               ! ( "Size of: " , stringify ! ( EFI_IP6_MODE_DATA ) ));
    assert_eq! (::core::mem::align_of::<EFI_IP6_MODE_DATA>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( EFI_IP6_MODE_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . IsStarted as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( IsStarted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . MaxPacketSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( MaxPacketSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . ConfigData as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( ConfigData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . IsConfigured as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( IsConfigured ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . AddressCount as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( AddressCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . AddressList as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( AddressList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . GroupCount as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( GroupCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . GroupTable as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( GroupTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . RouteCount as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( RouteCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . RouteTable as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( RouteTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . NeighborCount as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( NeighborCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . NeighborCache as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( NeighborCache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . PrefixCount as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( PrefixCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . PrefixTable as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( PrefixTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . IcmpTypeCount as
                * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( IcmpTypeCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_MODE_DATA ) ) . IcmpTypeList as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_IP6_MODE_DATA ) ,
                "::" , stringify ! ( IcmpTypeList ) ));
}
impl Clone for EFI_IP6_MODE_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_IP6_GET_MODE_DATA =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP6,
                                                Ip6ModeData:
                                                    *mut EFI_IP6_MODE_DATA,
                                                MnpConfigData:
                                                    *mut EFI_MANAGED_NETWORK_CONFIG_DATA,
                                                SnpModeData:
                                                    *mut EFI_SIMPLE_NETWORK_MODE)
                               -> EFI_STATUS>;
pub type EFI_IP6_CONFIGURE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP6,
                                                Ip6ConfigData:
                                                    *mut EFI_IP6_CONFIG_DATA)
                               -> EFI_STATUS>;
pub type EFI_IP6_GROUPS =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP6,
                                                JoinFlag: BOOLEAN,
                                                GroupAddress:
                                                    *mut EFI_IPv6_ADDRESS)
                               -> EFI_STATUS>;
pub type EFI_IP6_ROUTES =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP6,
                                                DeleteRoute: BOOLEAN,
                                                Destination:
                                                    *mut EFI_IPv6_ADDRESS,
                                                PrefixLength: UINT8,
                                                GatewayAddress:
                                                    *mut EFI_IPv6_ADDRESS)
                               -> EFI_STATUS>;
pub type EFI_IP6_NEIGHBORS =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP6,
                                                DeleteFlag: BOOLEAN,
                                                TargetIp6Address:
                                                    *mut EFI_IPv6_ADDRESS,
                                                TargetLinkAddress:
                                                    *mut EFI_MAC_ADDRESS,
                                                Timeout: UINT32,
                                                Override: BOOLEAN)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct _EFI_IP6_FRAGMENT_DATA {
    pub FragmentLength: UINT32,
    pub FragmentBuffer: *mut ::ctypes::c_void,
}
#[test]
fn bindgen_test_layout__EFI_IP6_FRAGMENT_DATA() {
    assert_eq!(::core::mem::size_of::<_EFI_IP6_FRAGMENT_DATA>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _EFI_IP6_FRAGMENT_DATA )
               ));
    assert_eq! (::core::mem::align_of::<_EFI_IP6_FRAGMENT_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _EFI_IP6_FRAGMENT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_FRAGMENT_DATA ) ) .
                FragmentLength as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_FRAGMENT_DATA
                ) , "::" , stringify ! ( FragmentLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_FRAGMENT_DATA ) ) .
                FragmentBuffer as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_FRAGMENT_DATA
                ) , "::" , stringify ! ( FragmentBuffer ) ));
}
impl Clone for _EFI_IP6_FRAGMENT_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_IP6_FRAGMENT_DATA = _EFI_IP6_FRAGMENT_DATA;
#[repr(C)]

pub struct _EFI_IP6_OVERRIDE_DATA {
    pub Protocol: UINT8,
    pub HopLimit: UINT8,
    pub FlowLabel: UINT32,
}
#[test]
fn bindgen_test_layout__EFI_IP6_OVERRIDE_DATA() {
    assert_eq!(::core::mem::size_of::<_EFI_IP6_OVERRIDE_DATA>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( _EFI_IP6_OVERRIDE_DATA )
               ));
    assert_eq! (::core::mem::align_of::<_EFI_IP6_OVERRIDE_DATA>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( _EFI_IP6_OVERRIDE_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_OVERRIDE_DATA ) ) . Protocol as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_OVERRIDE_DATA
                ) , "::" , stringify ! ( Protocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_OVERRIDE_DATA ) ) . HopLimit as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_OVERRIDE_DATA
                ) , "::" , stringify ! ( HopLimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_OVERRIDE_DATA ) ) . FlowLabel as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_OVERRIDE_DATA
                ) , "::" , stringify ! ( FlowLabel ) ));
}
impl Clone for _EFI_IP6_OVERRIDE_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_IP6_OVERRIDE_DATA = _EFI_IP6_OVERRIDE_DATA;
#[repr(C)]

pub struct _EFI_IP6_TRANSMIT_DATA {
    pub DestinationAddress: EFI_IPv6_ADDRESS,
    pub OverrideData: *mut EFI_IP6_OVERRIDE_DATA,
    pub ExtHdrsLength: UINT32,
    pub ExtHdrs: *mut ::ctypes::c_void,
    pub NextHeader: UINT8,
    pub DataLength: UINT32,
    pub FragmentCount: UINT32,
    pub FragmentTable: [EFI_IP6_FRAGMENT_DATA; 1usize],
}
#[test]
fn bindgen_test_layout__EFI_IP6_TRANSMIT_DATA() {
    assert_eq!(::core::mem::size_of::<_EFI_IP6_TRANSMIT_DATA>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( _EFI_IP6_TRANSMIT_DATA )
               ));
    assert_eq! (::core::mem::align_of::<_EFI_IP6_TRANSMIT_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _EFI_IP6_TRANSMIT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_TRANSMIT_DATA ) ) .
                DestinationAddress as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( _EFI_IP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( DestinationAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_TRANSMIT_DATA ) ) . OverrideData
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( OverrideData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_TRANSMIT_DATA ) ) .
                ExtHdrsLength as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( ExtHdrsLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_TRANSMIT_DATA ) ) . ExtHdrs as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( ExtHdrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_TRANSMIT_DATA ) ) . NextHeader
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( NextHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_TRANSMIT_DATA ) ) . DataLength
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( DataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_TRANSMIT_DATA ) ) .
                FragmentCount as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( FragmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_TRANSMIT_DATA ) ) .
                FragmentTable as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( FragmentTable ) ));
}
impl Clone for _EFI_IP6_TRANSMIT_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_IP6_TRANSMIT_DATA = _EFI_IP6_TRANSMIT_DATA;
#[repr(C)]

pub struct _EFI_IP6_HEADER {
    pub _bitfield_1: [u8; 2usize],
    pub FlowLabelL: UINT16,
    pub PayloadLength: UINT16,
    pub NextHeader: UINT8,
    pub HopLimit: UINT8,
    pub SourceAddress: EFI_IPv6_ADDRESS,
    pub DestinationAddress: EFI_IPv6_ADDRESS,
}
#[test]
fn bindgen_test_layout__EFI_IP6_HEADER() {
    assert_eq!(::core::mem::size_of::<_EFI_IP6_HEADER>() , 40usize , concat !
               ( "Size of: " , stringify ! ( _EFI_IP6_HEADER ) ));
    assert_eq! (::core::mem::align_of::<_EFI_IP6_HEADER>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( _EFI_IP6_HEADER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_HEADER ) ) . FlowLabelL as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_HEADER ) ,
                "::" , stringify ! ( FlowLabelL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_HEADER ) ) . PayloadLength as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_HEADER ) ,
                "::" , stringify ! ( PayloadLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_HEADER ) ) . NextHeader as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_HEADER ) ,
                "::" , stringify ! ( NextHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_HEADER ) ) . HopLimit as * const
                _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_HEADER ) ,
                "::" , stringify ! ( HopLimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_HEADER ) ) . SourceAddress as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_HEADER ) ,
                "::" , stringify ! ( SourceAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_HEADER ) ) . DestinationAddress
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_HEADER ) ,
                "::" , stringify ! ( DestinationAddress ) ));
}
impl Clone for _EFI_IP6_HEADER {
    fn clone(&self) -> Self { unimplemented!() }
}
impl _EFI_IP6_HEADER {
    #[inline]
    pub fn TrafficClassH(&self) -> UINT8 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 15u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_TrafficClassH(&mut self, val: UINT8) {
        let mask = 15u64 as u16;
        let val = val as u8 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn Version(&self) -> UINT8 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 240u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_Version(&mut self, val: UINT8) {
        let mask = 240u64 as u16;
        let val = val as u8 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn FlowLabelH(&self) -> UINT8 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 3840u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_FlowLabelH(&mut self, val: UINT8) {
        let mask = 3840u64 as u16;
        let val = val as u8 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn TrafficClassL(&self) -> UINT8 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 61440u64 as u16;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_TrafficClassL(&mut self, val: UINT8) {
        let mask = 61440u64 as u16;
        let val = val as u8 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub const fn new_bitfield_1(TrafficClassH: UINT8, Version: UINT8,
                                FlowLabelH: UINT8, TrafficClassL: UINT8)
     -> u16 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((TrafficClassH as u8 as u16) << 0usize) &
                                (15u64 as u16))
                   } | ((Version as u8 as u16) << 4usize) & (240u64 as u16))
              } | ((FlowLabelH as u8 as u16) << 8usize) & (3840u64 as u16))
         } | ((TrafficClassL as u8 as u16) << 12usize) & (61440u64 as u16))
    }
}
pub type EFI_IP6_HEADER = _EFI_IP6_HEADER;
#[repr(C)]

pub struct _EFI_IP6_RECEIVE_DATA {
    pub TimeStamp: EFI_TIME,
    pub RecycleSignal: EFI_EVENT,
    pub HeaderLength: UINT32,
    pub Header: *mut EFI_IP6_HEADER,
    pub DataLength: UINT32,
    pub FragmentCount: UINT32,
    pub FragmentTable: [EFI_IP6_FRAGMENT_DATA; 1usize],
}
#[test]
fn bindgen_test_layout__EFI_IP6_RECEIVE_DATA() {
    assert_eq!(::core::mem::size_of::<_EFI_IP6_RECEIVE_DATA>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _EFI_IP6_RECEIVE_DATA )
               ));
    assert_eq! (::core::mem::align_of::<_EFI_IP6_RECEIVE_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _EFI_IP6_RECEIVE_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_RECEIVE_DATA ) ) . TimeStamp as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_RECEIVE_DATA )
                , "::" , stringify ! ( TimeStamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_RECEIVE_DATA ) ) . RecycleSignal
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_RECEIVE_DATA )
                , "::" , stringify ! ( RecycleSignal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_RECEIVE_DATA ) ) . HeaderLength
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_RECEIVE_DATA )
                , "::" , stringify ! ( HeaderLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_RECEIVE_DATA ) ) . Header as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_RECEIVE_DATA )
                , "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_RECEIVE_DATA ) ) . DataLength as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_RECEIVE_DATA )
                , "::" , stringify ! ( DataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_RECEIVE_DATA ) ) . FragmentCount
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_RECEIVE_DATA )
                , "::" , stringify ! ( FragmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_IP6_RECEIVE_DATA ) ) . FragmentTable
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_IP6_RECEIVE_DATA )
                , "::" , stringify ! ( FragmentTable ) ));
}
impl Clone for _EFI_IP6_RECEIVE_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_IP6_RECEIVE_DATA = _EFI_IP6_RECEIVE_DATA;
#[repr(C)]

pub struct EFI_IP6_COMPLETION_TOKEN {
    pub Event: EFI_EVENT,
    pub Status: EFI_STATUS,
    pub Packet: EFI_IP6_COMPLETION_TOKEN__bindgen_ty_1,
}
#[repr(C)]

pub union EFI_IP6_COMPLETION_TOKEN__bindgen_ty_1 {
    pub RxData: *mut EFI_IP6_RECEIVE_DATA,
    pub TxData: *mut EFI_IP6_TRANSMIT_DATA,
}
#[test]
fn bindgen_test_layout_EFI_IP6_COMPLETION_TOKEN__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<EFI_IP6_COMPLETION_TOKEN__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               EFI_IP6_COMPLETION_TOKEN__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<EFI_IP6_COMPLETION_TOKEN__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_IP6_COMPLETION_TOKEN__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_COMPLETION_TOKEN__bindgen_ty_1 )
                ) . RxData as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_IP6_COMPLETION_TOKEN__bindgen_ty_1 ) , "::" , stringify !
                ( RxData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_COMPLETION_TOKEN__bindgen_ty_1 )
                ) . TxData as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_IP6_COMPLETION_TOKEN__bindgen_ty_1 ) , "::" , stringify !
                ( TxData ) ));
}
impl Clone for EFI_IP6_COMPLETION_TOKEN__bindgen_ty_1 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[test]
fn bindgen_test_layout_EFI_IP6_COMPLETION_TOKEN() {
    assert_eq!(::core::mem::size_of::<EFI_IP6_COMPLETION_TOKEN>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( EFI_IP6_COMPLETION_TOKEN ) ));
    assert_eq! (::core::mem::align_of::<EFI_IP6_COMPLETION_TOKEN>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_IP6_COMPLETION_TOKEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_COMPLETION_TOKEN ) ) . Event as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_IP6_COMPLETION_TOKEN ) , "::" , stringify ! ( Event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_COMPLETION_TOKEN ) ) . Status as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_IP6_COMPLETION_TOKEN ) , "::" , stringify ! ( Status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_IP6_COMPLETION_TOKEN ) ) . Packet as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_IP6_COMPLETION_TOKEN ) , "::" , stringify ! ( Packet ) ));
}
impl Clone for EFI_IP6_COMPLETION_TOKEN {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_IP6_TRANSMIT =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP6,
                                                Token:
                                                    *mut EFI_IP6_COMPLETION_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_IP6_RECEIVE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP6,
                                                Token:
                                                    *mut EFI_IP6_COMPLETION_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_IP6_CANCEL =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP6,
                                                Token:
                                                    *mut EFI_IP6_COMPLETION_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_IP6_POLL =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_IP6)
                               -> EFI_STATUS>;
pub type EFI_IP6 = _EFI_IP6;
#[repr(C)]

pub struct _EFI_UDP4 {
    pub GetModeData: EFI_UDP4_GET_MODE_DATA,
    pub Configure: EFI_UDP4_CONFIGURE,
    pub Groups: EFI_UDP4_GROUPS,
    pub Routes: EFI_UDP4_ROUTES,
    pub Transmit: EFI_UDP4_TRANSMIT,
    pub Receive: EFI_UDP4_RECEIVE,
    pub Cancel: EFI_UDP4_CANCEL,
    pub Poll: EFI_UDP4_POLL,
}
#[test]
fn bindgen_test_layout__EFI_UDP4() {
    assert_eq!(::core::mem::size_of::<_EFI_UDP4>() , 64usize , concat ! (
               "Size of: " , stringify ! ( _EFI_UDP4 ) ));
    assert_eq! (::core::mem::align_of::<_EFI_UDP4>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _EFI_UDP4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP4 ) ) . GetModeData as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP4 ) , "::" ,
                stringify ! ( GetModeData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP4 ) ) . Configure as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP4 ) , "::" ,
                stringify ! ( Configure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP4 ) ) . Groups as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP4 ) , "::" ,
                stringify ! ( Groups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP4 ) ) . Routes as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP4 ) , "::" ,
                stringify ! ( Routes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP4 ) ) . Transmit as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP4 ) , "::" ,
                stringify ! ( Transmit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP4 ) ) . Receive as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP4 ) , "::" ,
                stringify ! ( Receive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP4 ) ) . Cancel as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP4 ) , "::" ,
                stringify ! ( Cancel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP4 ) ) . Poll as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP4 ) , "::" ,
                stringify ! ( Poll ) ));
}
impl Clone for _EFI_UDP4 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct _EFI_UDP6 {
    pub GetModeData: EFI_UDP6_GET_MODE_DATA,
    pub Configure: EFI_UDP6_CONFIGURE,
    pub Groups: EFI_UDP6_GROUPS,
    pub Transmit: EFI_UDP6_TRANSMIT,
    pub Receive: EFI_UDP6_RECEIVE,
    pub Cancel: EFI_UDP6_CANCEL,
    pub Poll: EFI_UDP6_POLL,
}
#[test]
fn bindgen_test_layout__EFI_UDP6() {
    assert_eq!(::core::mem::size_of::<_EFI_UDP6>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _EFI_UDP6 ) ));
    assert_eq! (::core::mem::align_of::<_EFI_UDP6>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _EFI_UDP6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP6 ) ) . GetModeData as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP6 ) , "::" ,
                stringify ! ( GetModeData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP6 ) ) . Configure as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP6 ) , "::" ,
                stringify ! ( Configure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP6 ) ) . Groups as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP6 ) , "::" ,
                stringify ! ( Groups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP6 ) ) . Transmit as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP6 ) , "::" ,
                stringify ! ( Transmit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP6 ) ) . Receive as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP6 ) , "::" ,
                stringify ! ( Receive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP6 ) ) . Cancel as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP6 ) , "::" ,
                stringify ! ( Cancel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_UDP6 ) ) . Poll as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_UDP6 ) , "::" ,
                stringify ! ( Poll ) ));
}
impl Clone for _EFI_UDP6 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_UDP4_CONFIG_DATA {
    pub AcceptBroadcast: BOOLEAN,
    pub AcceptPromiscuous: BOOLEAN,
    pub AcceptAnyPort: BOOLEAN,
    pub AllowDuplicatePort: BOOLEAN,
    pub TypeOfService: UINT8,
    pub TimeToLive: UINT8,
    pub DoNotFragment: BOOLEAN,
    pub ReceiveTimeout: UINT32,
    pub TransmitTimeout: UINT32,
    pub UseDefaultAddress: BOOLEAN,
    pub StationAddress: EFI_IPv4_ADDRESS,
    pub SubnetMask: EFI_IPv4_ADDRESS,
    pub StationPort: UINT16,
    pub RemoteAddress: EFI_IPv4_ADDRESS,
    pub RemotePort: UINT16,
}
#[test]
fn bindgen_test_layout_EFI_UDP4_CONFIG_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_UDP4_CONFIG_DATA>() , 36usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_UDP4_CONFIG_DATA>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_UDP4_CONFIG_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) .
                AcceptBroadcast as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( AcceptBroadcast ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) .
                AcceptPromiscuous as * const _ as usize } , 1usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( AcceptPromiscuous ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) . AcceptAnyPort
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( AcceptAnyPort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) .
                AllowDuplicatePort as * const _ as usize } , 3usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( AllowDuplicatePort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) . TypeOfService
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( TypeOfService ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) . TimeToLive as
                * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( TimeToLive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) . DoNotFragment
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( DoNotFragment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) . ReceiveTimeout
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( ReceiveTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) .
                TransmitTimeout as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( TransmitTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) .
                UseDefaultAddress as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( UseDefaultAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) . StationAddress
                as * const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( StationAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) . SubnetMask as
                * const _ as usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( SubnetMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) . StationPort as
                * const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( StationPort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) . RemoteAddress
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( RemoteAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_CONFIG_DATA ) ) . RemotePort as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_CONFIG_DATA )
                , "::" , stringify ! ( RemotePort ) ));
}
impl Clone for EFI_UDP4_CONFIG_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_UDP4_GET_MODE_DATA =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP4,
                                                Udp4ConfigData:
                                                    *mut EFI_UDP4_CONFIG_DATA,
                                                Ip4ModeData:
                                                    *mut EFI_IP4_MODE_DATA,
                                                MnpConfigData:
                                                    *mut EFI_MANAGED_NETWORK_CONFIG_DATA,
                                                SnpModeData:
                                                    *mut EFI_SIMPLE_NETWORK_MODE)
                               -> EFI_STATUS>;
pub type EFI_UDP4_CONFIGURE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP4,
                                                UdpConfigData:
                                                    *mut EFI_UDP4_CONFIG_DATA)
                               -> EFI_STATUS>;
pub type EFI_UDP4_GROUPS =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP4,
                                                JoinFlag: BOOLEAN,
                                                MulticastAddress:
                                                    *mut EFI_IPv4_ADDRESS)
                               -> EFI_STATUS>;
pub type EFI_UDP4_ROUTES =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP4,
                                                DeleteRoute: BOOLEAN,
                                                SubnetAddress:
                                                    *mut EFI_IPv4_ADDRESS,
                                                SubnetMask:
                                                    *mut EFI_IPv4_ADDRESS,
                                                GatewayAddress:
                                                    *mut EFI_IPv4_ADDRESS)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_UDP4_SESSION_DATA {
    pub SourceAddress: EFI_IPv4_ADDRESS,
    pub SourcePort: UINT16,
    pub DestinationAddress: EFI_IPv4_ADDRESS,
    pub DestinationPort: UINT16,
}
#[test]
fn bindgen_test_layout_EFI_UDP4_SESSION_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_UDP4_SESSION_DATA>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_UDP4_SESSION_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_UDP4_SESSION_DATA>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_UDP4_SESSION_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_SESSION_DATA ) ) . SourceAddress
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_SESSION_DATA )
                , "::" , stringify ! ( SourceAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_SESSION_DATA ) ) . SourcePort as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_SESSION_DATA )
                , "::" , stringify ! ( SourcePort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_SESSION_DATA ) ) .
                DestinationAddress as * const _ as usize } , 6usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_UDP4_SESSION_DATA )
                , "::" , stringify ! ( DestinationAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_SESSION_DATA ) ) .
                DestinationPort as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_SESSION_DATA )
                , "::" , stringify ! ( DestinationPort ) ));
}
impl Clone for EFI_UDP4_SESSION_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_UDP4_FRAGMENT_DATA {
    pub FragmentLength: UINT32,
    pub FragmentBuffer: *mut ::ctypes::c_void,
}
#[test]
fn bindgen_test_layout_EFI_UDP4_FRAGMENT_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_UDP4_FRAGMENT_DATA>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_UDP4_FRAGMENT_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_UDP4_FRAGMENT_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_UDP4_FRAGMENT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_FRAGMENT_DATA ) ) .
                FragmentLength as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_FRAGMENT_DATA
                ) , "::" , stringify ! ( FragmentLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_FRAGMENT_DATA ) ) .
                FragmentBuffer as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_FRAGMENT_DATA
                ) , "::" , stringify ! ( FragmentBuffer ) ));
}
impl Clone for EFI_UDP4_FRAGMENT_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_UDP4_RECEIVE_DATA {
    pub TimeStamp: EFI_TIME,
    pub RecycleSignal: EFI_EVENT,
    pub UdpSession: EFI_UDP4_SESSION_DATA,
    pub DataLength: UINT32,
    pub FragmentCount: UINT32,
    pub FragmentTable: [EFI_UDP4_FRAGMENT_DATA; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_UDP4_RECEIVE_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_UDP4_RECEIVE_DATA>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_UDP4_RECEIVE_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_UDP4_RECEIVE_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_UDP4_RECEIVE_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_RECEIVE_DATA ) ) . TimeStamp as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_RECEIVE_DATA )
                , "::" , stringify ! ( TimeStamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_RECEIVE_DATA ) ) . RecycleSignal
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_RECEIVE_DATA )
                , "::" , stringify ! ( RecycleSignal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_RECEIVE_DATA ) ) . UdpSession as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_RECEIVE_DATA )
                , "::" , stringify ! ( UdpSession ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_RECEIVE_DATA ) ) . DataLength as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_RECEIVE_DATA )
                , "::" , stringify ! ( DataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_RECEIVE_DATA ) ) . FragmentCount
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_RECEIVE_DATA )
                , "::" , stringify ! ( FragmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_RECEIVE_DATA ) ) . FragmentTable
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_RECEIVE_DATA )
                , "::" , stringify ! ( FragmentTable ) ));
}
impl Clone for EFI_UDP4_RECEIVE_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_UDP4_TRANSMIT_DATA {
    pub UdpSessionData: *mut EFI_UDP4_SESSION_DATA,
    pub GatewayAddress: *mut EFI_IPv4_ADDRESS,
    pub DataLength: UINT32,
    pub FragmentCount: UINT32,
    pub FragmentTable: [EFI_UDP4_FRAGMENT_DATA; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_UDP4_TRANSMIT_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_UDP4_TRANSMIT_DATA>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_UDP4_TRANSMIT_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_UDP4_TRANSMIT_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_UDP4_TRANSMIT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_TRANSMIT_DATA ) ) .
                UdpSessionData as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_TRANSMIT_DATA
                ) , "::" , stringify ! ( UdpSessionData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_TRANSMIT_DATA ) ) .
                GatewayAddress as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_TRANSMIT_DATA
                ) , "::" , stringify ! ( GatewayAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_TRANSMIT_DATA ) ) . DataLength
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_TRANSMIT_DATA
                ) , "::" , stringify ! ( DataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_TRANSMIT_DATA ) ) .
                FragmentCount as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_TRANSMIT_DATA
                ) , "::" , stringify ! ( FragmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_TRANSMIT_DATA ) ) .
                FragmentTable as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP4_TRANSMIT_DATA
                ) , "::" , stringify ! ( FragmentTable ) ));
}
impl Clone for EFI_UDP4_TRANSMIT_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_UDP4_COMPLETION_TOKEN {
    pub Event: EFI_EVENT,
    pub Status: EFI_STATUS,
    pub Packet: EFI_UDP4_COMPLETION_TOKEN__bindgen_ty_1,
}
#[repr(C)]

pub union EFI_UDP4_COMPLETION_TOKEN__bindgen_ty_1 {
    pub RxData: *mut EFI_UDP4_RECEIVE_DATA,
    pub TxData: *mut EFI_UDP4_TRANSMIT_DATA,
}
#[test]
fn bindgen_test_layout_EFI_UDP4_COMPLETION_TOKEN__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<EFI_UDP4_COMPLETION_TOKEN__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               EFI_UDP4_COMPLETION_TOKEN__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<EFI_UDP4_COMPLETION_TOKEN__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_UDP4_COMPLETION_TOKEN__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_COMPLETION_TOKEN__bindgen_ty_1 )
                ) . RxData as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_UDP4_COMPLETION_TOKEN__bindgen_ty_1 ) , "::" , stringify !
                ( RxData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_COMPLETION_TOKEN__bindgen_ty_1 )
                ) . TxData as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_UDP4_COMPLETION_TOKEN__bindgen_ty_1 ) , "::" , stringify !
                ( TxData ) ));
}
impl Clone for EFI_UDP4_COMPLETION_TOKEN__bindgen_ty_1 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[test]
fn bindgen_test_layout_EFI_UDP4_COMPLETION_TOKEN() {
    assert_eq!(::core::mem::size_of::<EFI_UDP4_COMPLETION_TOKEN>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( EFI_UDP4_COMPLETION_TOKEN ) ));
    assert_eq! (::core::mem::align_of::<EFI_UDP4_COMPLETION_TOKEN>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( EFI_UDP4_COMPLETION_TOKEN )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_COMPLETION_TOKEN ) ) . Event as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_UDP4_COMPLETION_TOKEN ) , "::" , stringify ! ( Event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_COMPLETION_TOKEN ) ) . Status as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_UDP4_COMPLETION_TOKEN ) , "::" , stringify ! ( Status )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP4_COMPLETION_TOKEN ) ) . Packet as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_UDP4_COMPLETION_TOKEN ) , "::" , stringify ! ( Packet )
                ));
}
impl Clone for EFI_UDP4_COMPLETION_TOKEN {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_UDP4_TRANSMIT =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP4,
                                                Token:
                                                    *mut EFI_UDP4_COMPLETION_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_UDP4_RECEIVE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP4,
                                                Token:
                                                    *mut EFI_UDP4_COMPLETION_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_UDP4_CANCEL =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP4,
                                                Token:
                                                    *mut EFI_UDP4_COMPLETION_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_UDP4_POLL =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP4)
                               -> EFI_STATUS>;
pub type EFI_UDP4 = _EFI_UDP4;
#[repr(C)]

pub struct EFI_UDP6_CONFIG_DATA {
    pub AcceptPromiscuous: BOOLEAN,
    pub AcceptAnyPort: BOOLEAN,
    pub AllowDuplicatePort: BOOLEAN,
    pub TrafficClass: UINT8,
    pub HopLimit: UINT8,
    pub ReceiveTimeout: UINT32,
    pub TransmitTimeout: UINT32,
    pub StationAddress: EFI_IPv6_ADDRESS,
    pub StationPort: UINT16,
    pub RemoteAddress: EFI_IPv6_ADDRESS,
    pub RemotePort: UINT16,
}
#[test]
fn bindgen_test_layout_EFI_UDP6_CONFIG_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_UDP6_CONFIG_DATA>() , 52usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_UDP6_CONFIG_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_UDP6_CONFIG_DATA>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_UDP6_CONFIG_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_CONFIG_DATA ) ) .
                AcceptPromiscuous as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_UDP6_CONFIG_DATA )
                , "::" , stringify ! ( AcceptPromiscuous ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_CONFIG_DATA ) ) . AcceptAnyPort
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_CONFIG_DATA )
                , "::" , stringify ! ( AcceptAnyPort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_CONFIG_DATA ) ) .
                AllowDuplicatePort as * const _ as usize } , 2usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_UDP6_CONFIG_DATA )
                , "::" , stringify ! ( AllowDuplicatePort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_CONFIG_DATA ) ) . TrafficClass
                as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_CONFIG_DATA )
                , "::" , stringify ! ( TrafficClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_CONFIG_DATA ) ) . HopLimit as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_CONFIG_DATA )
                , "::" , stringify ! ( HopLimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_CONFIG_DATA ) ) . ReceiveTimeout
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_CONFIG_DATA )
                , "::" , stringify ! ( ReceiveTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_CONFIG_DATA ) ) .
                TransmitTimeout as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_CONFIG_DATA )
                , "::" , stringify ! ( TransmitTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_CONFIG_DATA ) ) . StationAddress
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_CONFIG_DATA )
                , "::" , stringify ! ( StationAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_CONFIG_DATA ) ) . StationPort as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_CONFIG_DATA )
                , "::" , stringify ! ( StationPort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_CONFIG_DATA ) ) . RemoteAddress
                as * const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_CONFIG_DATA )
                , "::" , stringify ! ( RemoteAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_CONFIG_DATA ) ) . RemotePort as
                * const _ as usize } , 50usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_CONFIG_DATA )
                , "::" , stringify ! ( RemotePort ) ));
}
impl Clone for EFI_UDP6_CONFIG_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_UDP6_GET_MODE_DATA =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP6,
                                                Udp6ConfigData:
                                                    *mut EFI_UDP6_CONFIG_DATA,
                                                Ip6ModeData:
                                                    *mut EFI_IP6_MODE_DATA,
                                                MnpConfigData:
                                                    *mut EFI_MANAGED_NETWORK_CONFIG_DATA,
                                                SnpModeData:
                                                    *mut EFI_SIMPLE_NETWORK_MODE)
                               -> EFI_STATUS>;
pub type EFI_UDP6_CONFIGURE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP6,
                                                UdpConfigData:
                                                    *mut EFI_UDP6_CONFIG_DATA)
                               -> EFI_STATUS>;
pub type EFI_UDP6_GROUPS =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP6,
                                                JoinFlag: BOOLEAN,
                                                MulticastAddress:
                                                    *mut EFI_IPv6_ADDRESS)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_UDP6_SESSION_DATA {
    pub SourceAddress: EFI_IPv6_ADDRESS,
    pub SourcePort: UINT16,
    pub DestinationAddress: EFI_IPv6_ADDRESS,
    pub DestinationPort: UINT16,
}
#[test]
fn bindgen_test_layout_EFI_UDP6_SESSION_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_UDP6_SESSION_DATA>() , 36usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_UDP6_SESSION_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_UDP6_SESSION_DATA>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_UDP6_SESSION_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_SESSION_DATA ) ) . SourceAddress
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_SESSION_DATA )
                , "::" , stringify ! ( SourceAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_SESSION_DATA ) ) . SourcePort as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_SESSION_DATA )
                , "::" , stringify ! ( SourcePort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_SESSION_DATA ) ) .
                DestinationAddress as * const _ as usize } , 18usize , concat
                ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_SESSION_DATA )
                , "::" , stringify ! ( DestinationAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_SESSION_DATA ) ) .
                DestinationPort as * const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_SESSION_DATA )
                , "::" , stringify ! ( DestinationPort ) ));
}
impl Clone for EFI_UDP6_SESSION_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_UDP6_FRAGMENT_DATA {
    pub FragmentLength: UINT32,
    pub FragmentBuffer: *mut ::ctypes::c_void,
}
#[test]
fn bindgen_test_layout_EFI_UDP6_FRAGMENT_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_UDP6_FRAGMENT_DATA>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_UDP6_FRAGMENT_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_UDP6_FRAGMENT_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_UDP6_FRAGMENT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_FRAGMENT_DATA ) ) .
                FragmentLength as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_FRAGMENT_DATA
                ) , "::" , stringify ! ( FragmentLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_FRAGMENT_DATA ) ) .
                FragmentBuffer as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_FRAGMENT_DATA
                ) , "::" , stringify ! ( FragmentBuffer ) ));
}
impl Clone for EFI_UDP6_FRAGMENT_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_UDP6_RECEIVE_DATA {
    pub TimeStamp: EFI_TIME,
    pub RecycleSignal: EFI_EVENT,
    pub UdpSession: EFI_UDP6_SESSION_DATA,
    pub DataLength: UINT32,
    pub FragmentCount: UINT32,
    pub FragmentTable: [EFI_UDP6_FRAGMENT_DATA; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_UDP6_RECEIVE_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_UDP6_RECEIVE_DATA>() , 88usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_UDP6_RECEIVE_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_UDP6_RECEIVE_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_UDP6_RECEIVE_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_RECEIVE_DATA ) ) . TimeStamp as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_RECEIVE_DATA )
                , "::" , stringify ! ( TimeStamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_RECEIVE_DATA ) ) . RecycleSignal
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_RECEIVE_DATA )
                , "::" , stringify ! ( RecycleSignal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_RECEIVE_DATA ) ) . UdpSession as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_RECEIVE_DATA )
                , "::" , stringify ! ( UdpSession ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_RECEIVE_DATA ) ) . DataLength as
                * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_RECEIVE_DATA )
                , "::" , stringify ! ( DataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_RECEIVE_DATA ) ) . FragmentCount
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_RECEIVE_DATA )
                , "::" , stringify ! ( FragmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_RECEIVE_DATA ) ) . FragmentTable
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_RECEIVE_DATA )
                , "::" , stringify ! ( FragmentTable ) ));
}
impl Clone for EFI_UDP6_RECEIVE_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_UDP6_TRANSMIT_DATA {
    pub UdpSessionData: *mut EFI_UDP6_SESSION_DATA,
    pub DataLength: UINT32,
    pub FragmentCount: UINT32,
    pub FragmentTable: [EFI_UDP6_FRAGMENT_DATA; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_UDP6_TRANSMIT_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_UDP6_TRANSMIT_DATA>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_UDP6_TRANSMIT_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_UDP6_TRANSMIT_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_UDP6_TRANSMIT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_TRANSMIT_DATA ) ) .
                UdpSessionData as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( UdpSessionData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_TRANSMIT_DATA ) ) . DataLength
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( DataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_TRANSMIT_DATA ) ) .
                FragmentCount as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( FragmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_TRANSMIT_DATA ) ) .
                FragmentTable as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_UDP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( FragmentTable ) ));
}
impl Clone for EFI_UDP6_TRANSMIT_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_UDP6_COMPLETION_TOKEN {
    pub Event: EFI_EVENT,
    pub Status: EFI_STATUS,
    pub Packet: EFI_UDP6_COMPLETION_TOKEN__bindgen_ty_1,
}
#[repr(C)]

pub union EFI_UDP6_COMPLETION_TOKEN__bindgen_ty_1 {
    pub RxData: *mut EFI_UDP6_RECEIVE_DATA,
    pub TxData: *mut EFI_UDP6_TRANSMIT_DATA,
}
#[test]
fn bindgen_test_layout_EFI_UDP6_COMPLETION_TOKEN__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<EFI_UDP6_COMPLETION_TOKEN__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               EFI_UDP6_COMPLETION_TOKEN__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<EFI_UDP6_COMPLETION_TOKEN__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_UDP6_COMPLETION_TOKEN__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_COMPLETION_TOKEN__bindgen_ty_1 )
                ) . RxData as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_UDP6_COMPLETION_TOKEN__bindgen_ty_1 ) , "::" , stringify !
                ( RxData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_COMPLETION_TOKEN__bindgen_ty_1 )
                ) . TxData as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_UDP6_COMPLETION_TOKEN__bindgen_ty_1 ) , "::" , stringify !
                ( TxData ) ));
}
impl Clone for EFI_UDP6_COMPLETION_TOKEN__bindgen_ty_1 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[test]
fn bindgen_test_layout_EFI_UDP6_COMPLETION_TOKEN() {
    assert_eq!(::core::mem::size_of::<EFI_UDP6_COMPLETION_TOKEN>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( EFI_UDP6_COMPLETION_TOKEN ) ));
    assert_eq! (::core::mem::align_of::<EFI_UDP6_COMPLETION_TOKEN>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( EFI_UDP6_COMPLETION_TOKEN )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_COMPLETION_TOKEN ) ) . Event as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_UDP6_COMPLETION_TOKEN ) , "::" , stringify ! ( Event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_COMPLETION_TOKEN ) ) . Status as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_UDP6_COMPLETION_TOKEN ) , "::" , stringify ! ( Status )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_UDP6_COMPLETION_TOKEN ) ) . Packet as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_UDP6_COMPLETION_TOKEN ) , "::" , stringify ! ( Packet )
                ));
}
impl Clone for EFI_UDP6_COMPLETION_TOKEN {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_UDP6_TRANSMIT =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP6,
                                                Token:
                                                    *mut EFI_UDP6_COMPLETION_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_UDP6_RECEIVE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP6,
                                                Token:
                                                    *mut EFI_UDP6_COMPLETION_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_UDP6_CANCEL =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP6,
                                                Token:
                                                    *mut EFI_UDP6_COMPLETION_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_UDP6_POLL =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_UDP6)
                               -> EFI_STATUS>;
pub type EFI_UDP6 = _EFI_UDP6;
#[repr(C)]

pub struct _EFI_TCP4 {
    pub GetModeData: EFI_TCP4_GET_MODE_DATA,
    pub Configure: EFI_TCP4_CONFIGURE,
    pub Routes: EFI_TCP4_ROUTES,
    pub Connect: EFI_TCP4_CONNECT,
    pub Accept: EFI_TCP4_ACCEPT,
    pub Transmit: EFI_TCP4_TRANSMIT,
    pub Receive: EFI_TCP4_RECEIVE,
    pub Close: EFI_TCP4_CLOSE,
    pub Cancel: EFI_TCP4_CANCEL,
    pub Poll: EFI_TCP4_POLL,
}
#[test]
fn bindgen_test_layout__EFI_TCP4() {
    assert_eq!(::core::mem::size_of::<_EFI_TCP4>() , 80usize , concat ! (
               "Size of: " , stringify ! ( _EFI_TCP4 ) ));
    assert_eq! (::core::mem::align_of::<_EFI_TCP4>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _EFI_TCP4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP4 ) ) . GetModeData as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP4 ) , "::" ,
                stringify ! ( GetModeData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP4 ) ) . Configure as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP4 ) , "::" ,
                stringify ! ( Configure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP4 ) ) . Routes as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP4 ) , "::" ,
                stringify ! ( Routes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP4 ) ) . Connect as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP4 ) , "::" ,
                stringify ! ( Connect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP4 ) ) . Accept as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP4 ) , "::" ,
                stringify ! ( Accept ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP4 ) ) . Transmit as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP4 ) , "::" ,
                stringify ! ( Transmit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP4 ) ) . Receive as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP4 ) , "::" ,
                stringify ! ( Receive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP4 ) ) . Close as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP4 ) , "::" ,
                stringify ! ( Close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP4 ) ) . Cancel as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP4 ) , "::" ,
                stringify ! ( Cancel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP4 ) ) . Poll as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP4 ) , "::" ,
                stringify ! ( Poll ) ));
}
impl Clone for _EFI_TCP4 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct _EFI_TCP6 {
    pub GetModeData: EFI_TCP6_GET_MODE_DATA,
    pub Configure: EFI_TCP6_CONFIGURE,
    pub Connect: EFI_TCP6_CONNECT,
    pub Accept: EFI_TCP6_ACCEPT,
    pub Transmit: EFI_TCP6_TRANSMIT,
    pub Receive: EFI_TCP6_RECEIVE,
    pub Close: EFI_TCP6_CLOSE,
    pub Cancel: EFI_TCP6_CANCEL,
    pub Poll: EFI_TCP6_POLL,
}
#[test]
fn bindgen_test_layout__EFI_TCP6() {
    assert_eq!(::core::mem::size_of::<_EFI_TCP6>() , 72usize , concat ! (
               "Size of: " , stringify ! ( _EFI_TCP6 ) ));
    assert_eq! (::core::mem::align_of::<_EFI_TCP6>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _EFI_TCP6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP6 ) ) . GetModeData as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP6 ) , "::" ,
                stringify ! ( GetModeData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP6 ) ) . Configure as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP6 ) , "::" ,
                stringify ! ( Configure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP6 ) ) . Connect as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP6 ) , "::" ,
                stringify ! ( Connect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP6 ) ) . Accept as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP6 ) , "::" ,
                stringify ! ( Accept ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP6 ) ) . Transmit as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP6 ) , "::" ,
                stringify ! ( Transmit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP6 ) ) . Receive as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP6 ) , "::" ,
                stringify ! ( Receive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP6 ) ) . Close as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP6 ) , "::" ,
                stringify ! ( Close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP6 ) ) . Cancel as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP6 ) , "::" ,
                stringify ! ( Cancel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_TCP6 ) ) . Poll as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_TCP6 ) , "::" ,
                stringify ! ( Poll ) ));
}
impl Clone for _EFI_TCP6 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_TCP4_ACCESS_POINT {
    pub UseDefaultAddress: BOOLEAN,
    pub StationAddress: EFI_IPv4_ADDRESS,
    pub SubnetMask: EFI_IPv4_ADDRESS,
    pub StationPort: UINT16,
    pub RemoteAddress: EFI_IPv4_ADDRESS,
    pub RemotePort: UINT16,
    pub ActiveFlag: BOOLEAN,
}
#[test]
fn bindgen_test_layout_EFI_TCP4_ACCESS_POINT() {
    assert_eq!(::core::mem::size_of::<EFI_TCP4_ACCESS_POINT>() , 20usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TCP4_ACCESS_POINT )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP4_ACCESS_POINT>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TCP4_ACCESS_POINT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_ACCESS_POINT ) ) .
                UseDefaultAddress as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( EFI_TCP4_ACCESS_POINT )
                , "::" , stringify ! ( UseDefaultAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_ACCESS_POINT ) ) .
                StationAddress as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_ACCESS_POINT )
                , "::" , stringify ! ( StationAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_ACCESS_POINT ) ) . SubnetMask as
                * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_ACCESS_POINT )
                , "::" , stringify ! ( SubnetMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_ACCESS_POINT ) ) . StationPort
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_ACCESS_POINT )
                , "::" , stringify ! ( StationPort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_ACCESS_POINT ) ) . RemoteAddress
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_ACCESS_POINT )
                , "::" , stringify ! ( RemoteAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_ACCESS_POINT ) ) . RemotePort as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_ACCESS_POINT )
                , "::" , stringify ! ( RemotePort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_ACCESS_POINT ) ) . ActiveFlag as
                * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_ACCESS_POINT )
                , "::" , stringify ! ( ActiveFlag ) ));
}
impl Clone for EFI_TCP4_ACCESS_POINT {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_TCP4_OPTION {
    pub ReceiveBufferSize: UINT32,
    pub SendBufferSize: UINT32,
    pub MaxSynBackLog: UINT32,
    pub ConnectionTimeout: UINT32,
    pub DataRetries: UINT32,
    pub FinTimeout: UINT32,
    pub TimeWaitTimeout: UINT32,
    pub KeepAliveProbes: UINT32,
    pub KeepAliveTime: UINT32,
    pub KeepAliveInterval: UINT32,
    pub EnableNagle: BOOLEAN,
    pub EnableTimeStamp: BOOLEAN,
    pub EnableWindowScaling: BOOLEAN,
    pub EnableSelectiveAck: BOOLEAN,
    pub EnablePAthMtuDiscovery: BOOLEAN,
}
#[test]
fn bindgen_test_layout_EFI_TCP4_OPTION() {
    assert_eq!(::core::mem::size_of::<EFI_TCP4_OPTION>() , 48usize , concat !
               ( "Size of: " , stringify ! ( EFI_TCP4_OPTION ) ));
    assert_eq! (::core::mem::align_of::<EFI_TCP4_OPTION>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( EFI_TCP4_OPTION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) . ReceiveBufferSize
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( ReceiveBufferSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) . SendBufferSize as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( SendBufferSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) . MaxSynBackLog as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( MaxSynBackLog ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) . ConnectionTimeout
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( ConnectionTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) . DataRetries as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( DataRetries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) . FinTimeout as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( FinTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) . TimeWaitTimeout as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( TimeWaitTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) . KeepAliveProbes as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( KeepAliveProbes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) . KeepAliveTime as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( KeepAliveTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) . KeepAliveInterval
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( KeepAliveInterval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) . EnableNagle as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( EnableNagle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) . EnableTimeStamp as
                * const _ as usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( EnableTimeStamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) . EnableWindowScaling
                as * const _ as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( EnableWindowScaling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) . EnableSelectiveAck
                as * const _ as usize } , 43usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( EnableSelectiveAck ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_OPTION ) ) .
                EnablePAthMtuDiscovery as * const _ as usize } , 44usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_OPTION ) ,
                "::" , stringify ! ( EnablePAthMtuDiscovery ) ));
}
impl Clone for EFI_TCP4_OPTION {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_TCP4_CONFIG_DATA {
    pub TypeOfService: UINT8,
    pub TimeToLive: UINT8,
    pub AccessPoint: EFI_TCP4_ACCESS_POINT,
    pub ControlOption: *mut EFI_TCP4_OPTION,
}
#[test]
fn bindgen_test_layout_EFI_TCP4_CONFIG_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_TCP4_CONFIG_DATA>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TCP4_CONFIG_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP4_CONFIG_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TCP4_CONFIG_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_CONFIG_DATA ) ) . TypeOfService
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_CONFIG_DATA )
                , "::" , stringify ! ( TypeOfService ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_CONFIG_DATA ) ) . TimeToLive as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_CONFIG_DATA )
                , "::" , stringify ! ( TimeToLive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_CONFIG_DATA ) ) . AccessPoint as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_CONFIG_DATA )
                , "::" , stringify ! ( AccessPoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_CONFIG_DATA ) ) . ControlOption
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_CONFIG_DATA )
                , "::" , stringify ! ( ControlOption ) ));
}
impl Clone for EFI_TCP4_CONFIG_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
pub const EFI_TCP4_CONNECTION_STATE_Tcp4StateClosed: EFI_TCP4_CONNECTION_STATE
          =
    0;
pub const EFI_TCP4_CONNECTION_STATE_Tcp4StateListen: EFI_TCP4_CONNECTION_STATE
          =
    1;
pub const EFI_TCP4_CONNECTION_STATE_Tcp4StateSynSent:
          EFI_TCP4_CONNECTION_STATE =
    2;
pub const EFI_TCP4_CONNECTION_STATE_Tcp4StateSynReceived:
          EFI_TCP4_CONNECTION_STATE =
    3;
pub const EFI_TCP4_CONNECTION_STATE_Tcp4StateEstablished:
          EFI_TCP4_CONNECTION_STATE =
    4;
pub const EFI_TCP4_CONNECTION_STATE_Tcp4StateFinWait1:
          EFI_TCP4_CONNECTION_STATE =
    5;
pub const EFI_TCP4_CONNECTION_STATE_Tcp4StateFinWait2:
          EFI_TCP4_CONNECTION_STATE =
    6;
pub const EFI_TCP4_CONNECTION_STATE_Tcp4StateClosing:
          EFI_TCP4_CONNECTION_STATE =
    7;
pub const EFI_TCP4_CONNECTION_STATE_Tcp4StateTimeWait:
          EFI_TCP4_CONNECTION_STATE =
    8;
pub const EFI_TCP4_CONNECTION_STATE_Tcp4StateCloseWait:
          EFI_TCP4_CONNECTION_STATE =
    9;
pub const EFI_TCP4_CONNECTION_STATE_Tcp4StateLastAck:
          EFI_TCP4_CONNECTION_STATE =
    10;
pub type EFI_TCP4_CONNECTION_STATE = ::ctypes::c_uint;
pub type EFI_TCP4_GET_MODE_DATA =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP4,
                                                Tcp4State:
                                                    *mut EFI_TCP4_CONNECTION_STATE,
                                                Tcp4ConfigData:
                                                    *mut EFI_TCP4_CONFIG_DATA,
                                                Ip4ModeData:
                                                    *mut EFI_IP4_MODE_DATA,
                                                MnpConfigData:
                                                    *mut EFI_MANAGED_NETWORK_CONFIG_DATA,
                                                SnpModeData:
                                                    *mut EFI_SIMPLE_NETWORK_MODE)
                               -> EFI_STATUS>;
pub type EFI_TCP4_CONFIGURE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP4,
                                                TcpConfigData:
                                                    *mut EFI_TCP4_CONFIG_DATA)
                               -> EFI_STATUS>;
pub type EFI_TCP4_ROUTES =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP4,
                                                DeleteRoute: BOOLEAN,
                                                SubnetAddress:
                                                    *mut EFI_IPv4_ADDRESS,
                                                SubnetMask:
                                                    *mut EFI_IPv4_ADDRESS,
                                                GatewayAddress:
                                                    *mut EFI_IPv4_ADDRESS)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_TCP4_COMPLETION_TOKEN {
    pub Event: EFI_EVENT,
    pub Status: EFI_STATUS,
}
#[test]
fn bindgen_test_layout_EFI_TCP4_COMPLETION_TOKEN() {
    assert_eq!(::core::mem::size_of::<EFI_TCP4_COMPLETION_TOKEN>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( EFI_TCP4_COMPLETION_TOKEN ) ));
    assert_eq! (::core::mem::align_of::<EFI_TCP4_COMPLETION_TOKEN>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( EFI_TCP4_COMPLETION_TOKEN )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_COMPLETION_TOKEN ) ) . Event as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_TCP4_COMPLETION_TOKEN ) , "::" , stringify ! ( Event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_COMPLETION_TOKEN ) ) . Status as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_TCP4_COMPLETION_TOKEN ) , "::" , stringify ! ( Status )
                ));
}
impl Clone for EFI_TCP4_COMPLETION_TOKEN {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_TCP4_CONNECTION_TOKEN {
    pub CompletionToken: EFI_TCP4_COMPLETION_TOKEN,
}
#[test]
fn bindgen_test_layout_EFI_TCP4_CONNECTION_TOKEN() {
    assert_eq!(::core::mem::size_of::<EFI_TCP4_CONNECTION_TOKEN>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( EFI_TCP4_CONNECTION_TOKEN ) ));
    assert_eq! (::core::mem::align_of::<EFI_TCP4_CONNECTION_TOKEN>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( EFI_TCP4_CONNECTION_TOKEN )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_CONNECTION_TOKEN ) ) .
                CompletionToken as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_TCP4_CONNECTION_TOKEN ) , "::" , stringify ! (
                CompletionToken ) ));
}
impl Clone for EFI_TCP4_CONNECTION_TOKEN {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_TCP4_CONNECT =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP4,
                                                ConnectionToken:
                                                    *mut EFI_TCP4_CONNECTION_TOKEN)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_TCP4_LISTEN_TOKEN {
    pub CompletionToken: EFI_TCP4_COMPLETION_TOKEN,
    pub NewChildHandle: EFI_HANDLE,
}
#[test]
fn bindgen_test_layout_EFI_TCP4_LISTEN_TOKEN() {
    assert_eq!(::core::mem::size_of::<EFI_TCP4_LISTEN_TOKEN>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TCP4_LISTEN_TOKEN )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP4_LISTEN_TOKEN>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TCP4_LISTEN_TOKEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_LISTEN_TOKEN ) ) .
                CompletionToken as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_LISTEN_TOKEN )
                , "::" , stringify ! ( CompletionToken ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_LISTEN_TOKEN ) ) .
                NewChildHandle as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_LISTEN_TOKEN )
                , "::" , stringify ! ( NewChildHandle ) ));
}
impl Clone for EFI_TCP4_LISTEN_TOKEN {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_TCP4_ACCEPT =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP4,
                                                ListenToken:
                                                    *mut EFI_TCP4_LISTEN_TOKEN)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_TCP4_FRAGMENT_DATA {
    pub FragmentLength: UINT32,
    pub FragmentBuffer: *mut ::ctypes::c_void,
}
#[test]
fn bindgen_test_layout_EFI_TCP4_FRAGMENT_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_TCP4_FRAGMENT_DATA>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TCP4_FRAGMENT_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP4_FRAGMENT_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TCP4_FRAGMENT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_FRAGMENT_DATA ) ) .
                FragmentLength as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_FRAGMENT_DATA
                ) , "::" , stringify ! ( FragmentLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_FRAGMENT_DATA ) ) .
                FragmentBuffer as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_FRAGMENT_DATA
                ) , "::" , stringify ! ( FragmentBuffer ) ));
}
impl Clone for EFI_TCP4_FRAGMENT_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_TCP4_RECEIVE_DATA {
    pub UrgentFlag: BOOLEAN,
    pub DataLength: UINT32,
    pub FragmentCount: UINT32,
    pub FragmentTable: [EFI_TCP4_FRAGMENT_DATA; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_TCP4_RECEIVE_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_TCP4_RECEIVE_DATA>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TCP4_RECEIVE_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP4_RECEIVE_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TCP4_RECEIVE_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_RECEIVE_DATA ) ) . UrgentFlag as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_RECEIVE_DATA )
                , "::" , stringify ! ( UrgentFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_RECEIVE_DATA ) ) . DataLength as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_RECEIVE_DATA )
                , "::" , stringify ! ( DataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_RECEIVE_DATA ) ) . FragmentCount
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_RECEIVE_DATA )
                , "::" , stringify ! ( FragmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_RECEIVE_DATA ) ) . FragmentTable
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_RECEIVE_DATA )
                , "::" , stringify ! ( FragmentTable ) ));
}
impl Clone for EFI_TCP4_RECEIVE_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_TCP4_TRANSMIT_DATA {
    pub Push: BOOLEAN,
    pub Urgent: BOOLEAN,
    pub DataLength: UINT32,
    pub FragmentCount: UINT32,
    pub FragmentTable: [EFI_TCP4_FRAGMENT_DATA; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_TCP4_TRANSMIT_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_TCP4_TRANSMIT_DATA>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TCP4_TRANSMIT_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP4_TRANSMIT_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TCP4_TRANSMIT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_TRANSMIT_DATA ) ) . Push as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_TRANSMIT_DATA
                ) , "::" , stringify ! ( Push ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_TRANSMIT_DATA ) ) . Urgent as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_TRANSMIT_DATA
                ) , "::" , stringify ! ( Urgent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_TRANSMIT_DATA ) ) . DataLength
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_TRANSMIT_DATA
                ) , "::" , stringify ! ( DataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_TRANSMIT_DATA ) ) .
                FragmentCount as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_TRANSMIT_DATA
                ) , "::" , stringify ! ( FragmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_TRANSMIT_DATA ) ) .
                FragmentTable as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_TRANSMIT_DATA
                ) , "::" , stringify ! ( FragmentTable ) ));
}
impl Clone for EFI_TCP4_TRANSMIT_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_TCP4_IO_TOKEN {
    pub CompletionToken: EFI_TCP4_COMPLETION_TOKEN,
    pub Packet: EFI_TCP4_IO_TOKEN__bindgen_ty_1,
}
#[repr(C)]

pub union EFI_TCP4_IO_TOKEN__bindgen_ty_1 {
    pub RxData: *mut EFI_TCP4_RECEIVE_DATA,
    pub TxData: *mut EFI_TCP4_TRANSMIT_DATA,
}
#[test]
fn bindgen_test_layout_EFI_TCP4_IO_TOKEN__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<EFI_TCP4_IO_TOKEN__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( EFI_TCP4_IO_TOKEN__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP4_IO_TOKEN__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_TCP4_IO_TOKEN__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_IO_TOKEN__bindgen_ty_1 ) ) .
                RxData as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_TCP4_IO_TOKEN__bindgen_ty_1 ) , "::" , stringify ! (
                RxData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_IO_TOKEN__bindgen_ty_1 ) ) .
                TxData as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_TCP4_IO_TOKEN__bindgen_ty_1 ) , "::" , stringify ! (
                TxData ) ));
}
impl Clone for EFI_TCP4_IO_TOKEN__bindgen_ty_1 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[test]
fn bindgen_test_layout_EFI_TCP4_IO_TOKEN() {
    assert_eq!(::core::mem::size_of::<EFI_TCP4_IO_TOKEN>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( EFI_TCP4_IO_TOKEN ) ));
    assert_eq! (::core::mem::align_of::<EFI_TCP4_IO_TOKEN>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( EFI_TCP4_IO_TOKEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_IO_TOKEN ) ) . CompletionToken
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_IO_TOKEN ) ,
                "::" , stringify ! ( CompletionToken ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_IO_TOKEN ) ) . Packet as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_IO_TOKEN ) ,
                "::" , stringify ! ( Packet ) ));
}
impl Clone for EFI_TCP4_IO_TOKEN {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_TCP4_TRANSMIT =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP4,
                                                Token: *mut EFI_TCP4_IO_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_TCP4_RECEIVE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP4,
                                                Token: *mut EFI_TCP4_IO_TOKEN)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_TCP4_CLOSE_TOKEN {
    pub CompletionToken: EFI_TCP4_COMPLETION_TOKEN,
    pub AbortOnClose: BOOLEAN,
}
#[test]
fn bindgen_test_layout_EFI_TCP4_CLOSE_TOKEN() {
    assert_eq!(::core::mem::size_of::<EFI_TCP4_CLOSE_TOKEN>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TCP4_CLOSE_TOKEN )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP4_CLOSE_TOKEN>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TCP4_CLOSE_TOKEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_CLOSE_TOKEN ) ) .
                CompletionToken as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_CLOSE_TOKEN )
                , "::" , stringify ! ( CompletionToken ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP4_CLOSE_TOKEN ) ) . AbortOnClose
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP4_CLOSE_TOKEN )
                , "::" , stringify ! ( AbortOnClose ) ));
}
impl Clone for EFI_TCP4_CLOSE_TOKEN {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_TCP4_CLOSE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP4,
                                                CloseToken:
                                                    *mut EFI_TCP4_CLOSE_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_TCP4_CANCEL =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP4,
                                                Token:
                                                    *mut EFI_TCP4_COMPLETION_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_TCP4_POLL =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP4)
                               -> EFI_STATUS>;
pub type EFI_TCP4 = _EFI_TCP4;
pub const EFI_TCP6_CONNECTION_STATE_Tcp6StateClosed: EFI_TCP6_CONNECTION_STATE
          =
    0;
pub const EFI_TCP6_CONNECTION_STATE_Tcp6StateListen: EFI_TCP6_CONNECTION_STATE
          =
    1;
pub const EFI_TCP6_CONNECTION_STATE_Tcp6StateSynSent:
          EFI_TCP6_CONNECTION_STATE =
    2;
pub const EFI_TCP6_CONNECTION_STATE_Tcp6StateSynReceived:
          EFI_TCP6_CONNECTION_STATE =
    3;
pub const EFI_TCP6_CONNECTION_STATE_Tcp6StateEstablished:
          EFI_TCP6_CONNECTION_STATE =
    4;
pub const EFI_TCP6_CONNECTION_STATE_Tcp6StateFinWait1:
          EFI_TCP6_CONNECTION_STATE =
    5;
pub const EFI_TCP6_CONNECTION_STATE_Tcp6StateFinWait2:
          EFI_TCP6_CONNECTION_STATE =
    6;
pub const EFI_TCP6_CONNECTION_STATE_Tcp6StateClosing:
          EFI_TCP6_CONNECTION_STATE =
    7;
pub const EFI_TCP6_CONNECTION_STATE_Tcp6StateTimeWait:
          EFI_TCP6_CONNECTION_STATE =
    8;
pub const EFI_TCP6_CONNECTION_STATE_Tcp6StateCloseWait:
          EFI_TCP6_CONNECTION_STATE =
    9;
pub const EFI_TCP6_CONNECTION_STATE_Tcp6StateLastAck:
          EFI_TCP6_CONNECTION_STATE =
    10;
pub type EFI_TCP6_CONNECTION_STATE = ::ctypes::c_uint;
#[repr(C)]

pub struct EFI_TCP6_ACCESS_POINT {
    pub StationAddress: EFI_IPv6_ADDRESS,
    pub StationPort: UINT16,
    pub RemoteAddress: EFI_IPv6_ADDRESS,
    pub RemotePort: UINT16,
    pub ActiveFlag: BOOLEAN,
}
#[test]
fn bindgen_test_layout_EFI_TCP6_ACCESS_POINT() {
    assert_eq!(::core::mem::size_of::<EFI_TCP6_ACCESS_POINT>() , 38usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TCP6_ACCESS_POINT )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP6_ACCESS_POINT>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TCP6_ACCESS_POINT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_ACCESS_POINT ) ) .
                StationAddress as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_ACCESS_POINT )
                , "::" , stringify ! ( StationAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_ACCESS_POINT ) ) . StationPort
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_ACCESS_POINT )
                , "::" , stringify ! ( StationPort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_ACCESS_POINT ) ) . RemoteAddress
                as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_ACCESS_POINT )
                , "::" , stringify ! ( RemoteAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_ACCESS_POINT ) ) . RemotePort as
                * const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_ACCESS_POINT )
                , "::" , stringify ! ( RemotePort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_ACCESS_POINT ) ) . ActiveFlag as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_ACCESS_POINT )
                , "::" , stringify ! ( ActiveFlag ) ));
}
impl Clone for EFI_TCP6_ACCESS_POINT {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_TCP6_OPTION {
    pub ReceiveBufferSize: UINT32,
    pub SendBufferSize: UINT32,
    pub MaxSynBackLog: UINT32,
    pub ConnectionTimeout: UINT32,
    pub DataRetries: UINT32,
    pub FinTimeout: UINT32,
    pub TimeWaitTimeout: UINT32,
    pub KeepAliveProbes: UINT32,
    pub KeepAliveTime: UINT32,
    pub KeepAliveInterval: UINT32,
    pub EnableNagle: BOOLEAN,
    pub EnableTimeStamp: BOOLEAN,
    pub EnableWindbowScaling: BOOLEAN,
    pub EnableSelectiveAck: BOOLEAN,
    pub EnablePathMtuDiscovery: BOOLEAN,
}
#[test]
fn bindgen_test_layout_EFI_TCP6_OPTION() {
    assert_eq!(::core::mem::size_of::<EFI_TCP6_OPTION>() , 48usize , concat !
               ( "Size of: " , stringify ! ( EFI_TCP6_OPTION ) ));
    assert_eq! (::core::mem::align_of::<EFI_TCP6_OPTION>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( EFI_TCP6_OPTION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) . ReceiveBufferSize
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( ReceiveBufferSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) . SendBufferSize as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( SendBufferSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) . MaxSynBackLog as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( MaxSynBackLog ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) . ConnectionTimeout
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( ConnectionTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) . DataRetries as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( DataRetries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) . FinTimeout as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( FinTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) . TimeWaitTimeout as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( TimeWaitTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) . KeepAliveProbes as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( KeepAliveProbes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) . KeepAliveTime as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( KeepAliveTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) . KeepAliveInterval
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( KeepAliveInterval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) . EnableNagle as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( EnableNagle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) . EnableTimeStamp as
                * const _ as usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( EnableTimeStamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) .
                EnableWindbowScaling as * const _ as usize } , 42usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( EnableWindbowScaling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) . EnableSelectiveAck
                as * const _ as usize } , 43usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( EnableSelectiveAck ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_OPTION ) ) .
                EnablePathMtuDiscovery as * const _ as usize } , 44usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_OPTION ) ,
                "::" , stringify ! ( EnablePathMtuDiscovery ) ));
}
impl Clone for EFI_TCP6_OPTION {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_TCP6_CONFIG_DATA {
    pub TrafficClass: UINT8,
    pub HopLimit: UINT8,
    pub AccessPoint: EFI_TCP6_ACCESS_POINT,
    pub ControlOption: *mut EFI_TCP6_OPTION,
}
#[test]
fn bindgen_test_layout_EFI_TCP6_CONFIG_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_TCP6_CONFIG_DATA>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TCP6_CONFIG_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP6_CONFIG_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TCP6_CONFIG_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_CONFIG_DATA ) ) . TrafficClass
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_CONFIG_DATA )
                , "::" , stringify ! ( TrafficClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_CONFIG_DATA ) ) . HopLimit as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_CONFIG_DATA )
                , "::" , stringify ! ( HopLimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_CONFIG_DATA ) ) . AccessPoint as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_CONFIG_DATA )
                , "::" , stringify ! ( AccessPoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_CONFIG_DATA ) ) . ControlOption
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_CONFIG_DATA )
                , "::" , stringify ! ( ControlOption ) ));
}
impl Clone for EFI_TCP6_CONFIG_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_TCP6_GET_MODE_DATA =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP6,
                                                Tcp6State:
                                                    *mut EFI_TCP6_CONNECTION_STATE,
                                                Tcp6ConfigData:
                                                    *mut EFI_TCP6_CONFIG_DATA,
                                                Ip6ModeData:
                                                    *mut EFI_IP6_MODE_DATA,
                                                MnpConfigData:
                                                    *mut EFI_MANAGED_NETWORK_CONFIG_DATA,
                                                SnpModeData:
                                                    *mut EFI_SIMPLE_NETWORK_MODE)
                               -> EFI_STATUS>;
pub type EFI_TCP6_CONFIGURE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP6,
                                                Tcp6ConfigData:
                                                    *mut EFI_TCP6_CONFIG_DATA)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_TCP6_COMPLETION_TOKEN {
    pub Event: EFI_EVENT,
    pub Status: EFI_STATUS,
}
#[test]
fn bindgen_test_layout_EFI_TCP6_COMPLETION_TOKEN() {
    assert_eq!(::core::mem::size_of::<EFI_TCP6_COMPLETION_TOKEN>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( EFI_TCP6_COMPLETION_TOKEN ) ));
    assert_eq! (::core::mem::align_of::<EFI_TCP6_COMPLETION_TOKEN>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( EFI_TCP6_COMPLETION_TOKEN )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_COMPLETION_TOKEN ) ) . Event as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_TCP6_COMPLETION_TOKEN ) , "::" , stringify ! ( Event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_COMPLETION_TOKEN ) ) . Status as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_TCP6_COMPLETION_TOKEN ) , "::" , stringify ! ( Status )
                ));
}
impl Clone for EFI_TCP6_COMPLETION_TOKEN {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_TCP6_CONNECTION_TOKEN {
    pub CompletionToken: EFI_TCP6_COMPLETION_TOKEN,
}
#[test]
fn bindgen_test_layout_EFI_TCP6_CONNECTION_TOKEN() {
    assert_eq!(::core::mem::size_of::<EFI_TCP6_CONNECTION_TOKEN>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( EFI_TCP6_CONNECTION_TOKEN ) ));
    assert_eq! (::core::mem::align_of::<EFI_TCP6_CONNECTION_TOKEN>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( EFI_TCP6_CONNECTION_TOKEN )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_CONNECTION_TOKEN ) ) .
                CompletionToken as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_TCP6_CONNECTION_TOKEN ) , "::" , stringify ! (
                CompletionToken ) ));
}
impl Clone for EFI_TCP6_CONNECTION_TOKEN {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_TCP6_CONNECT =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP6,
                                                ConnectionToken:
                                                    *mut EFI_TCP6_CONNECTION_TOKEN)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_TCP6_LISTEN_TOKEN {
    pub CompletionToken: EFI_TCP6_COMPLETION_TOKEN,
    pub NewChildHandle: EFI_HANDLE,
}
#[test]
fn bindgen_test_layout_EFI_TCP6_LISTEN_TOKEN() {
    assert_eq!(::core::mem::size_of::<EFI_TCP6_LISTEN_TOKEN>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TCP6_LISTEN_TOKEN )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP6_LISTEN_TOKEN>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TCP6_LISTEN_TOKEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_LISTEN_TOKEN ) ) .
                CompletionToken as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_LISTEN_TOKEN )
                , "::" , stringify ! ( CompletionToken ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_LISTEN_TOKEN ) ) .
                NewChildHandle as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_LISTEN_TOKEN )
                , "::" , stringify ! ( NewChildHandle ) ));
}
impl Clone for EFI_TCP6_LISTEN_TOKEN {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_TCP6_ACCEPT =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP6,
                                                ListenToken:
                                                    *mut EFI_TCP6_LISTEN_TOKEN)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_TCP6_FRAGMENT_DATA {
    pub FragmentLength: UINT32,
    pub FragmentBuffer: *mut ::ctypes::c_void,
}
#[test]
fn bindgen_test_layout_EFI_TCP6_FRAGMENT_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_TCP6_FRAGMENT_DATA>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TCP6_FRAGMENT_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP6_FRAGMENT_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TCP6_FRAGMENT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_FRAGMENT_DATA ) ) .
                FragmentLength as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_FRAGMENT_DATA
                ) , "::" , stringify ! ( FragmentLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_FRAGMENT_DATA ) ) .
                FragmentBuffer as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_FRAGMENT_DATA
                ) , "::" , stringify ! ( FragmentBuffer ) ));
}
impl Clone for EFI_TCP6_FRAGMENT_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_TCP6_RECEIVE_DATA {
    pub UrgentFlag: BOOLEAN,
    pub DataLength: UINT32,
    pub FragmentCount: UINT32,
    pub FragmentTable: [EFI_TCP6_FRAGMENT_DATA; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_TCP6_RECEIVE_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_TCP6_RECEIVE_DATA>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TCP6_RECEIVE_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP6_RECEIVE_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TCP6_RECEIVE_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_RECEIVE_DATA ) ) . UrgentFlag as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_RECEIVE_DATA )
                , "::" , stringify ! ( UrgentFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_RECEIVE_DATA ) ) . DataLength as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_RECEIVE_DATA )
                , "::" , stringify ! ( DataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_RECEIVE_DATA ) ) . FragmentCount
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_RECEIVE_DATA )
                , "::" , stringify ! ( FragmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_RECEIVE_DATA ) ) . FragmentTable
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_RECEIVE_DATA )
                , "::" , stringify ! ( FragmentTable ) ));
}
impl Clone for EFI_TCP6_RECEIVE_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_TCP6_TRANSMIT_DATA {
    pub Push: BOOLEAN,
    pub Urgent: BOOLEAN,
    pub DataLength: UINT32,
    pub FragmentCount: UINT32,
    pub FragmentTable: [EFI_TCP6_FRAGMENT_DATA; 1usize],
}
#[test]
fn bindgen_test_layout_EFI_TCP6_TRANSMIT_DATA() {
    assert_eq!(::core::mem::size_of::<EFI_TCP6_TRANSMIT_DATA>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TCP6_TRANSMIT_DATA )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP6_TRANSMIT_DATA>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TCP6_TRANSMIT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_TRANSMIT_DATA ) ) . Push as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( Push ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_TRANSMIT_DATA ) ) . Urgent as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( Urgent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_TRANSMIT_DATA ) ) . DataLength
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( DataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_TRANSMIT_DATA ) ) .
                FragmentCount as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( FragmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_TRANSMIT_DATA ) ) .
                FragmentTable as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_TRANSMIT_DATA
                ) , "::" , stringify ! ( FragmentTable ) ));
}
impl Clone for EFI_TCP6_TRANSMIT_DATA {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_TCP6_IO_TOKEN {
    pub CompletionToken: EFI_TCP6_COMPLETION_TOKEN,
    pub Packet: EFI_TCP6_IO_TOKEN__bindgen_ty_1,
}
#[repr(C)]

pub union EFI_TCP6_IO_TOKEN__bindgen_ty_1 {
    pub RxData: *mut EFI_TCP6_RECEIVE_DATA,
    pub TxData: *mut EFI_TCP6_TRANSMIT_DATA,
}
#[test]
fn bindgen_test_layout_EFI_TCP6_IO_TOKEN__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<EFI_TCP6_IO_TOKEN__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( EFI_TCP6_IO_TOKEN__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP6_IO_TOKEN__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                EFI_TCP6_IO_TOKEN__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_IO_TOKEN__bindgen_ty_1 ) ) .
                RxData as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_TCP6_IO_TOKEN__bindgen_ty_1 ) , "::" , stringify ! (
                RxData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_IO_TOKEN__bindgen_ty_1 ) ) .
                TxData as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_TCP6_IO_TOKEN__bindgen_ty_1 ) , "::" , stringify ! (
                TxData ) ));
}
impl Clone for EFI_TCP6_IO_TOKEN__bindgen_ty_1 {
    fn clone(&self) -> Self { unimplemented!() }
}
#[test]
fn bindgen_test_layout_EFI_TCP6_IO_TOKEN() {
    assert_eq!(::core::mem::size_of::<EFI_TCP6_IO_TOKEN>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( EFI_TCP6_IO_TOKEN ) ));
    assert_eq! (::core::mem::align_of::<EFI_TCP6_IO_TOKEN>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( EFI_TCP6_IO_TOKEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_IO_TOKEN ) ) . CompletionToken
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_IO_TOKEN ) ,
                "::" , stringify ! ( CompletionToken ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_IO_TOKEN ) ) . Packet as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_IO_TOKEN ) ,
                "::" , stringify ! ( Packet ) ));
}
impl Clone for EFI_TCP6_IO_TOKEN {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_TCP6_TRANSMIT =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP6,
                                                Token: *mut EFI_TCP6_IO_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_TCP6_RECEIVE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP6,
                                                Token: *mut EFI_TCP6_IO_TOKEN)
                               -> EFI_STATUS>;
#[repr(C)]

pub struct EFI_TCP6_CLOSE_TOKEN {
    pub CompletionToken: EFI_TCP6_COMPLETION_TOKEN,
    pub AbortOnClose: BOOLEAN,
}
#[test]
fn bindgen_test_layout_EFI_TCP6_CLOSE_TOKEN() {
    assert_eq!(::core::mem::size_of::<EFI_TCP6_CLOSE_TOKEN>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( EFI_TCP6_CLOSE_TOKEN )
               ));
    assert_eq! (::core::mem::align_of::<EFI_TCP6_CLOSE_TOKEN>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_TCP6_CLOSE_TOKEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_CLOSE_TOKEN ) ) .
                CompletionToken as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_CLOSE_TOKEN )
                , "::" , stringify ! ( CompletionToken ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_TCP6_CLOSE_TOKEN ) ) . AbortOnClose
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_TCP6_CLOSE_TOKEN )
                , "::" , stringify ! ( AbortOnClose ) ));
}
impl Clone for EFI_TCP6_CLOSE_TOKEN {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_TCP6_CLOSE =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP6,
                                                CloseToken:
                                                    *mut EFI_TCP6_CLOSE_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_TCP6_CANCEL =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP6,
                                                Token:
                                                    *mut EFI_TCP6_COMPLETION_TOKEN)
                               -> EFI_STATUS>;
pub type EFI_TCP6_POLL =
    ::core::option::Option<unsafe extern "win64" fn(This: *mut _EFI_TCP6)
                               -> EFI_STATUS>;
pub type EFI_TCP6 = _EFI_TCP6;
#[repr(C)]

pub struct _EFI_SIMPLE_POINTER {
    pub Reset: EFI_SIMPLE_POINTER_RESET,
    pub GetState: EFI_SIMPLE_POINTER_GET_STATE,
    pub WaitForInput: EFI_EVENT,
    pub Mode: *mut EFI_SIMPLE_POINTER_MODE,
}
#[test]
fn bindgen_test_layout__EFI_SIMPLE_POINTER() {
    assert_eq!(::core::mem::size_of::<_EFI_SIMPLE_POINTER>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( _EFI_SIMPLE_POINTER )
               ));
    assert_eq! (::core::mem::align_of::<_EFI_SIMPLE_POINTER>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _EFI_SIMPLE_POINTER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_POINTER ) ) . Reset as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_POINTER ) ,
                "::" , stringify ! ( Reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_POINTER ) ) . GetState as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_POINTER ) ,
                "::" , stringify ! ( GetState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_POINTER ) ) . WaitForInput as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_POINTER ) ,
                "::" , stringify ! ( WaitForInput ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_SIMPLE_POINTER ) ) . Mode as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _EFI_SIMPLE_POINTER ) ,
                "::" , stringify ! ( Mode ) ));
}
impl Clone for _EFI_SIMPLE_POINTER {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_SIMPLE_POINTER_STATE {
    pub RelativeMovementX: INT32,
    pub RelativeMovementY: INT32,
    pub RelativeMovementZ: INT32,
    pub LeftButton: BOOLEAN,
    pub RightButton: BOOLEAN,
}
#[test]
fn bindgen_test_layout_EFI_SIMPLE_POINTER_STATE() {
    assert_eq!(::core::mem::size_of::<EFI_SIMPLE_POINTER_STATE>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( EFI_SIMPLE_POINTER_STATE ) ));
    assert_eq! (::core::mem::align_of::<EFI_SIMPLE_POINTER_STATE>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_SIMPLE_POINTER_STATE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_POINTER_STATE ) ) .
                RelativeMovementX as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                EFI_SIMPLE_POINTER_STATE ) , "::" , stringify ! (
                RelativeMovementX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_POINTER_STATE ) ) .
                RelativeMovementY as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! (
                EFI_SIMPLE_POINTER_STATE ) , "::" , stringify ! (
                RelativeMovementY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_POINTER_STATE ) ) .
                RelativeMovementZ as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                EFI_SIMPLE_POINTER_STATE ) , "::" , stringify ! (
                RelativeMovementZ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_POINTER_STATE ) ) . LeftButton
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_SIMPLE_POINTER_STATE ) , "::" , stringify ! ( LeftButton )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_POINTER_STATE ) ) .
                RightButton as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_SIMPLE_POINTER_STATE ) , "::" , stringify ! ( RightButton
                ) ));
}
impl Clone for EFI_SIMPLE_POINTER_STATE {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_SIMPLE_POINTER_MODE {
    pub ResolutionX: UINT64,
    pub ResolutionY: UINT64,
    pub ResolutionZ: UINT64,
    pub LeftButton: BOOLEAN,
    pub RightButton: BOOLEAN,
}
#[test]
fn bindgen_test_layout_EFI_SIMPLE_POINTER_MODE() {
    assert_eq!(::core::mem::size_of::<EFI_SIMPLE_POINTER_MODE>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( EFI_SIMPLE_POINTER_MODE ) ));
    assert_eq! (::core::mem::align_of::<EFI_SIMPLE_POINTER_MODE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EFI_SIMPLE_POINTER_MODE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_POINTER_MODE ) ) . ResolutionX
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_POINTER_MODE
                ) , "::" , stringify ! ( ResolutionX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_POINTER_MODE ) ) . ResolutionY
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_POINTER_MODE
                ) , "::" , stringify ! ( ResolutionY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_POINTER_MODE ) ) . ResolutionZ
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_POINTER_MODE
                ) , "::" , stringify ! ( ResolutionZ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_POINTER_MODE ) ) . LeftButton
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_POINTER_MODE
                ) , "::" , stringify ! ( LeftButton ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_SIMPLE_POINTER_MODE ) ) . RightButton
                as * const _ as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( EFI_SIMPLE_POINTER_MODE
                ) , "::" , stringify ! ( RightButton ) ));
}
impl Clone for EFI_SIMPLE_POINTER_MODE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_SIMPLE_POINTER_RESET =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_POINTER,
                                                ExtendedVerification: BOOLEAN)
                               -> EFI_STATUS>;
pub type EFI_SIMPLE_POINTER_GET_STATE =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_SIMPLE_POINTER,
                                                State:
                                                    *mut EFI_SIMPLE_POINTER_STATE)
                               -> EFI_STATUS>;
pub type EFI_SIMPLE_POINTER_PROTOCOL = _EFI_SIMPLE_POINTER;
#[repr(C)]

pub struct _EFI_ABSOLUTE_POINTER_PROTOCOL {
    pub Reset: EFI_ABSOLUTE_POINTER_RESET,
    pub GetState: EFI_ABSOLUTE_POINTER_GET_STATE,
    pub WaitForInput: EFI_EVENT,
    pub Mode: *mut EFI_ABSOLUTE_POINTER_MODE,
}
#[test]
fn bindgen_test_layout__EFI_ABSOLUTE_POINTER_PROTOCOL() {
    assert_eq!(::core::mem::size_of::<_EFI_ABSOLUTE_POINTER_PROTOCOL>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( _EFI_ABSOLUTE_POINTER_PROTOCOL )
               ));
    assert_eq! (::core::mem::align_of::<_EFI_ABSOLUTE_POINTER_PROTOCOL>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _EFI_ABSOLUTE_POINTER_PROTOCOL
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_ABSOLUTE_POINTER_PROTOCOL ) ) .
                Reset as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_ABSOLUTE_POINTER_PROTOCOL ) , "::" , stringify ! ( Reset
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_ABSOLUTE_POINTER_PROTOCOL ) ) .
                GetState as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_ABSOLUTE_POINTER_PROTOCOL ) , "::" , stringify ! (
                GetState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_ABSOLUTE_POINTER_PROTOCOL ) ) .
                WaitForInput as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_ABSOLUTE_POINTER_PROTOCOL ) , "::" , stringify ! (
                WaitForInput ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _EFI_ABSOLUTE_POINTER_PROTOCOL ) ) . Mode
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _EFI_ABSOLUTE_POINTER_PROTOCOL ) , "::" , stringify ! ( Mode )
                ));
}
impl Clone for _EFI_ABSOLUTE_POINTER_PROTOCOL {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_ABSOLUTE_POINTER_MODE {
    pub AbsoluteMinX: UINT64,
    pub AbsoluteMinY: UINT64,
    pub AbsoluteMinZ: UINT64,
    pub AbsoluteMaxX: UINT64,
    pub AbsoluteMaxY: UINT64,
    pub AbsoluteMaxZ: UINT64,
    pub Attributes: UINT32,
}
#[test]
fn bindgen_test_layout_EFI_ABSOLUTE_POINTER_MODE() {
    assert_eq!(::core::mem::size_of::<EFI_ABSOLUTE_POINTER_MODE>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( EFI_ABSOLUTE_POINTER_MODE ) ));
    assert_eq! (::core::mem::align_of::<EFI_ABSOLUTE_POINTER_MODE>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( EFI_ABSOLUTE_POINTER_MODE )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_ABSOLUTE_POINTER_MODE ) ) .
                AbsoluteMinX as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_ABSOLUTE_POINTER_MODE ) , "::" , stringify ! (
                AbsoluteMinX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_ABSOLUTE_POINTER_MODE ) ) .
                AbsoluteMinY as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_ABSOLUTE_POINTER_MODE ) , "::" , stringify ! (
                AbsoluteMinY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_ABSOLUTE_POINTER_MODE ) ) .
                AbsoluteMinZ as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_ABSOLUTE_POINTER_MODE ) , "::" , stringify ! (
                AbsoluteMinZ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_ABSOLUTE_POINTER_MODE ) ) .
                AbsoluteMaxX as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_ABSOLUTE_POINTER_MODE ) , "::" , stringify ! (
                AbsoluteMaxX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_ABSOLUTE_POINTER_MODE ) ) .
                AbsoluteMaxY as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_ABSOLUTE_POINTER_MODE ) , "::" , stringify ! (
                AbsoluteMaxY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_ABSOLUTE_POINTER_MODE ) ) .
                AbsoluteMaxZ as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_ABSOLUTE_POINTER_MODE ) , "::" , stringify ! (
                AbsoluteMaxZ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_ABSOLUTE_POINTER_MODE ) ) .
                Attributes as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_ABSOLUTE_POINTER_MODE ) , "::" , stringify ! ( Attributes
                ) ));
}
impl Clone for EFI_ABSOLUTE_POINTER_MODE {
    fn clone(&self) -> Self { unimplemented!() }
}
#[repr(C)]

pub struct EFI_ABSOLUTE_POINTER_STATE {
    pub CurrentX: UINT64,
    pub CurrentY: UINT64,
    pub CurrentZ: UINT64,
    pub ActiveButtons: UINT32,
}
#[test]
fn bindgen_test_layout_EFI_ABSOLUTE_POINTER_STATE() {
    assert_eq!(::core::mem::size_of::<EFI_ABSOLUTE_POINTER_STATE>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( EFI_ABSOLUTE_POINTER_STATE ) ));
    assert_eq! (::core::mem::align_of::<EFI_ABSOLUTE_POINTER_STATE>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( EFI_ABSOLUTE_POINTER_STATE )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_ABSOLUTE_POINTER_STATE ) ) . CurrentX
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_ABSOLUTE_POINTER_STATE ) , "::" , stringify ! ( CurrentX )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_ABSOLUTE_POINTER_STATE ) ) . CurrentY
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_ABSOLUTE_POINTER_STATE ) , "::" , stringify ! ( CurrentY )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_ABSOLUTE_POINTER_STATE ) ) . CurrentZ
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_ABSOLUTE_POINTER_STATE ) , "::" , stringify ! ( CurrentZ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EFI_ABSOLUTE_POINTER_STATE ) ) .
                ActiveButtons as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                EFI_ABSOLUTE_POINTER_STATE ) , "::" , stringify ! (
                ActiveButtons ) ));
}
impl Clone for EFI_ABSOLUTE_POINTER_STATE {
    fn clone(&self) -> Self { unimplemented!() }
}
pub type EFI_ABSOLUTE_POINTER_RESET =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_ABSOLUTE_POINTER_PROTOCOL,
                                                ExtendedVerification: BOOLEAN)
                               -> EFI_STATUS>;
pub type EFI_ABSOLUTE_POINTER_GET_STATE =
    ::core::option::Option<unsafe extern "win64" fn(This:
                                                    *mut _EFI_ABSOLUTE_POINTER_PROTOCOL,
                                                State:
                                                    *mut EFI_ABSOLUTE_POINTER_STATE)
                               -> EFI_STATUS>;
pub type EFI_ABSOLUTE_POINTER_PROTOCOL = _EFI_ABSOLUTE_POINTER_PROTOCOL;
#[repr(C)]
pub struct jmp_buf {
    pub Rbx: UINT64,
    pub Rsp: UINT64,
    pub Rbp: UINT64,
    pub Rdi: UINT64,
    pub Rsi: UINT64,
    pub R12: UINT64,
    pub R13: UINT64,
    pub R14: UINT64,
    pub R15: UINT64,
    pub Rip: UINT64,
    pub MxCsr: UINT64,
    pub XmmBuffer: [UINT8; 160usize],
}
#[test]
fn bindgen_test_layout_jmp_buf() {
    assert_eq!(::core::mem::size_of::<jmp_buf>() , 248usize , concat ! (
               "Size of: " , stringify ! ( jmp_buf ) ));
    assert_eq! (::core::mem::align_of::<jmp_buf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( jmp_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const jmp_buf ) ) . Rbx as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( jmp_buf ) , "::" ,
                stringify ! ( Rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const jmp_buf ) ) . Rsp as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( jmp_buf ) , "::" ,
                stringify ! ( Rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const jmp_buf ) ) . Rbp as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( jmp_buf ) , "::" ,
                stringify ! ( Rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const jmp_buf ) ) . Rdi as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( jmp_buf ) , "::" ,
                stringify ! ( Rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const jmp_buf ) ) . Rsi as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( jmp_buf ) , "::" ,
                stringify ! ( Rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const jmp_buf ) ) . R12 as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( jmp_buf ) , "::" ,
                stringify ! ( R12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const jmp_buf ) ) . R13 as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( jmp_buf ) , "::" ,
                stringify ! ( R13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const jmp_buf ) ) . R14 as * const _ as usize }
                , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( jmp_buf ) , "::" ,
                stringify ! ( R14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const jmp_buf ) ) . R15 as * const _ as usize }
                , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( jmp_buf ) , "::" ,
                stringify ! ( R15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const jmp_buf ) ) . Rip as * const _ as usize }
                , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( jmp_buf ) , "::" ,
                stringify ! ( Rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const jmp_buf ) ) . MxCsr as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( jmp_buf ) , "::" ,
                stringify ! ( MxCsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const jmp_buf ) ) . XmmBuffer as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( jmp_buf ) , "::" ,
                stringify ! ( XmmBuffer ) ));
}
